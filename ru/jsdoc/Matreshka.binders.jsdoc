/**
@namespace Matreshka.binders
@importance 1
@desc Пространство имен для байндеров. Этот объект можно расширять собственными свойствами, чтоб не засорять глобальное пространство имен.

Примите во внимание небольшое соглашение: каждое свойство из коллекции ``Matreshka.binders`` должно быть оформлено в виде функции, возвращающей байндер.
@see {@link Matreshka#bindNode}
@see {@link Matreshka.defaultBinders}
@example
MK.binders.myCoolBinder = function(var1, var2) {
	return {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... },
		initialize: function() { ... }
	};
};

this.bindNode('myKey', '.my-element',
	MK.binders.myCoolBinder('Hello', 'World'));
*/

/**
@function Matreshka.binders.html
@importance 2
@since 0.1
@summary Возвращает привязчик, меняющий ``innerHTML`` DOM элемента в зависимости от значения свойства экземпляра класса
@returns {binder}
@example
this.bindNode('myKey', '.my-element', MK.binders.html());
*/

/**
@function Matreshka.binders.display
@importance 2
@since 0.1
@summary Возвращает односторонний привязчик, меняющий видимость DOM элемент (используя ``style.display``), в зависимости от значения свойства экземпляра класса
@param {boolean} [value=true] - Если аргумент равен ``true``, то элемент прячется при ложном значении свойства, если равен ``false``, прячется при правдивом значении
@returns {binder}
@example
this.bindNode('myKey', '.my-element', MK.binders.display(true));
@example
this.bindNode('myKey', '.my-element', MK.binders.display(false));
*/

/**
@function Matreshka.binders.className
@importance 2
@since 0.1
@summary Возвращает привязчик, который переключает имя класса DOM элемента в зависимости от значения свойства экземпляра класса. Если значение свойства нестрого равно ``true``, имя класса добавляется, в противном случае - убирается. Логику можно изменить, добавив восклицательный знак перед именем класса, и, таким образом, имя класса будет добавляться, когда значение свойства нестрого равно ``false`` и наоборот.
@param {string} className
@returns {binder}
@example
this.bindNode('myKey', '.my-element', MK.binders.className('blah'));

this.myKey = true; // добавляет класс 'blah'

this.myKey = false; // убирает класс 'blah'
@example <caption>Использование восклицательного знака перед именем класса</caption>
this.bindNode('myKey', '.my-element', MK.binders.className('!blah'));

this.myKey = false; // добавляет класс 'blah'

this.myKey = true; // убирает класс 'blah'
*/

/**
@function Matreshka.binders.prop
@importance 2
@since 0.3
@summary Возвращает привязчик, меняющий свойство DOM элемента на значение свойства экземпляра класса
@param {string} property
@returns {binder}
@example
this.bindNode('disabled', '.my-button', MK.binders.prop('disabled'));

// устанавливает свойство disabled = true для элемента
this.disabled = true;

// устанавливает свойство disabled = false для элемента
this.disabled = false;
*/

/**
@function Matreshka.binders.attr
@importance 2
@since 0.3
@summary Возвращает привязчик, меняющий атрибут DOM элемента на значение свойства экземпляра класса
@param {string} attribute
@returns {binder}
@example
this.bindNode('image', 'img.my-image', MK.binders.attr('src'));

this.image = 'http://example.com/cats.jpg';
*/

/**
@function Matreshka.binders.input
@importance 3
@since 0.3
@summary Возвращает привязчик, связывающий свойство экземпляра класса с элементом ``input``. Напрямую привязчик использовать не обязательно, так как он входит в список {@link Matreshka.defaultBinders}.
@param {string} [type] - Тип инпута
@returns {binder}
@example
this.bindNode('myKey', '.my-input', MK.binders.input('range'));
*/


/**
@function Matreshka.binders.output
@importance 3
@since 1.4
@summary Возвращает привязчик, связывающий свойство экземпляра класса с элементом ``output``. Напрямую привязчик использовать не обязательно, так как он входит в список {@link Matreshka.defaultBinders}.
@returns {binder}
@example
this.bindNode('myKey', '.my-output', MK.binders.output()));
*/


/**
@function Matreshka.binders.textarea
@importance 3
@since 0.3
@summary Возвращает привязчик, связывающий свойство экземпляра с элементом ``textarea``. Напрямую привязчик использовать не обязательно, так как он входит в список {@link Matreshka.defaultBinders}.
@returns {binder}
@example
this.bindNode('myKey', '.my-textarea', MK.binders.textarea());
*/

/**
@function Matreshka.binders.select
@importance 3
@since 0.3
@summary Возвращает привязчик, связывающий свойство экземпляра с элементом ``select``. Напрямую привязчик использовать не обязательно, так как он входит в список {@link Matreshka.defaultBinders}.
@param {boolean} [multiple=false] - Является ли селект ``multiple``
@returns {binder}
@example
this.bindNode('myKey', '.my-select', MK.binders.select(true));
*/


/**
@function Matreshka.binders.progress
@importance 3
@since 1.1
@summary Возвращает привязчик, связывающий свойство с экземпляра с элементом ``progress``. Напрямую привязчик использовать не обязательно, так как он входит в список {@link Matreshka.defaultBinders}.
@returns {binder}
@example
this.bindNode('myKey', '.my-progress', MK.binders.progress());
*/


/**
@function Matreshka.binders.text
@importance 2
@since 1.1
@summary Возвращает привязчик, меняющий ``textContent`` (текстовое содержимое) DOM элемента в зависимости от значения свойства экземпляра класса.
@desc {@link Matreshka.binders.text} позволяет вывести содержимое свойства как есть и немного улучшает производительность из-за отсутствия необходимости браузеру парсить HTML.
@returns {binder}
@example
this.bindNode('myKey', '.my-node', MK.binders.text());
*/


/**
@function Matreshka.binders.style
@importance 2
@since 1.1
@summary Возвращает привязчик, меняющий заданное свойство стиля DOM элемента в зависимости от значения свойства экземпляра класса.
@param {string} property - Свойство ``style`` (camel-cased)
@returns {binder}
@example
this.bindNode('myKey', '.my-node', MK.binders.style('backgroundColor'));
this.myKey = 'red'; // цвет фона ``.my-node`` стал красным
*/


/**
@function Matreshka.binders.dataset
@importance 2
@since 1.1
@summary Возвращает привязчик, меняющий заданное свойство объекта [dataset](https://developer.mozilla.org/ru/docs/Web/API/HTMLElement/dataset) DOM элемента в зависимости от значения свойства экземпляра класса.
@param {string} property - Свойство dataset
@returns {binder}
@example
this.bindNode('myKey', '.my-node', MK.binders.dataset('myProp'));
this.myKey = 'cool value';
*/


/**
@function Matreshka.binders.file
@importance 2
@since 1.1
@summary Возвращает привязчик для ``input[type="file"]``.

@desc Байндер позволяет не только получить основные данные о файле, но и считать его, не вызывая ``FileReader`` вручную.

Если аргумент ``readAs`` не задан, то в привязанное свойство попадает значение инпута после его изменения (по событию ``change``). Если ``readAs`` задан, то байндер считает файл и преобразует в необходимый формат (data URI, Blob...) и только после прочтения файла свойство изменится.

Результирующим значением свойства становится файл (нативный ``File``) или массив файлов при наличии атрибута ``multiple``. При этом, результат чтения попадет в объект каждого файла в виде свойства ``readerResult``.
@see {@link https://developer.mozilla.org/en/docs/Web/API/FileReader FileReader}
@see {@link Matreshka.binders.dropFiles}
@param {string} [readAs] - Значением аргумента ``readAs`` могут быть ``"arrayBufer"``, ``"binaryString"``, ``"dataURL"``, ``"text"``. Значение зависит от наличия соответствующих методов в интерфейсе ``FileReader``
@returns {binder}
@example
this.bindNode('myKey', '.my-file', MK.binders.file('dataURL'));
// ... пользователь меняет содержимое инпута,
// выбирая my-image.png из файловой системы ...
this.on('change:myKey', function() {
	console.log(this.myKey);
	// -->
	// File
	//	lastModified: 1383404384000
	//	lastModifiedDate: ...
	//	name: "my-image.png"
	//	readerResult: "data:image/png;base64,iVBO..."
	//	- результат считывания файла
	//	size: 9378
	//	type: "image/png"
});
*/


/**
@function Matreshka.binders.dropFiles
@importance 2
@since 1.8
@summary Возвращает байндер, позволяющий перетаскивать файлы в заданный блок из файлового менеджера (drag'n'drop).

@desc При связывании свойства и HTML блока при помощи ``dropFiles``, на блок навешиваются необходимые обработчики DOM событий (``dragover`` и ``drop``). При перетаскивании файлов из файлового менеджера в блок, свойство получает массив с этими файлами в качестве значения. Как и в случае с {@link Matreshka.binders.file}, привязчику можно передать аргумент ``readAs``, указывающий на то, каким образом следует читать дропнутые файлы с помощью ``FileReader``: data URI, Blob... (результат чтения находится в свойстве  ``readerResult`` каждого файла). Если ``readAs`` не задан, свойство получает список файлов без их предварительного прочтения.

@see {@link https://developer.mozilla.org/en/docs/Web/API/FileReader FileReader}
@see {@link Matreshka.binders.file}

@param {string} [readAs] - Значением аргумента ``readAs`` могут быть ``"arrayBufer"``, ``"binaryString"``, ``"dataURL"``, ``"text"``. Значение зависит от наличия соответствующих методов в интерфейсе ``FileReader``
@returns {binder}
@example
this.bindNode('myKey', '.drop-area', MK.binders.dropFiles('dataURL'));
// ... пользователь дропает файл my-image.png в блок .drop-area
this.on('change:myKey', function() {
	console.log(this.myKey[0]);
	// -->
	// File
	//	lastModified: 1383404384000
	//	lastModifiedDate: ...
	//	name: "my-image.png"
	//	readerResult: "data:image/png;base64,iVBO..."
	//	- результат считывания файла
	//	size: 9378
	//	type: "image/png"
});
*/

/**
@function Matreshka.binders.dragOver
@importance 3
@since 1.9
@summary Возвращает байндер, меняющий заданное свойство в зависимости от того, перетаскивается ли что-нибудь пользователем (например, файл) над заданным элементом.
@desc Байндер может пригодиться в том случае, если нужно что-нибудь сделать (например, изменить класс) с элементом над которым перетаскивают draggable объект.

@returns {binder}
@example
this.bindNode('myKey', '.my-node', MK.binders.dragOver());
this.on('change:myKey', function() {
	if(this.myKey) {
		console.log('something is dragging over .my-node');
	} else {
		console.log('nothing is dragged over the node');
	}
});
@example <caption>Добавление класса ``dragovered`` при перетаскивании файла (или другого draggable объекта) над элементом</caption>
this.bindNode('myKey', '.my-node', MK.binders.dragOver());
this.bindNode('myKey', '.my-node', MK.binders.className('dragovered'));

*/
