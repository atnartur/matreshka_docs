## [FAQ](#!faq)
### Имеется ли в Матрешке обертка над ``XMLHttpRequest`` (AJAX)?
Нет. Во-первых есть много прекрасных библиотек, реализующих коммуникации с сервером: некогда популярный [jQuery.ajax](http://api.jquery.com/jquery.ajax/), потрясающая библиотека [qwest](https://github.com/pyrsmk/qwest), основанная на ["промисах"](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise) и многие другие.

Во-вторых, в качестве альтернативы ``XMLHttpRequest``, все браузеры, возможно, очень скоро получат нативную поддержку [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API). ``fetch`` имеет более простое и чистое API, основанное на "промисах", позволяющее избежать катастрофического количества callback'ов и необходимости помнить API ``XMLHttpRequest``. Пока ``fetch`` поддерживается не всем браузерами, можно воспользоваться [популярным полифилом](https://github.com/github/fetch).

> "Промисы" и асинхронные функции из спецификации ECMAScript 7 дают возможность писать великолепной красоты JavaScript код:

```js
async function getData() {
	let resp = await fetch(someUrl);
	let data = await resp.text();

	console.log(data);
}

getData();
```


### Есть ли в Матрешке роутинг?
И да и нет. Как и в случае с AJAX, в интернете есть полно замечательных библитек, реализующих роутинг, например [director](https://github.com/flatiron/director). Но для простых задач и задач средней сложности (99% всех проектов) можно воспользоваться плагином, реализующим двусторонее связывание части URL со свойствами объекта. Плагин прекрасно вписывается в концепцию Матрешки, добавляя в приложение самый простой способ управления адресом во всей Вселенной. Плагин находится по [этой ссылке](https://github.com/matreshkajs/matreshka-router). Подробное описание на русском можно прочесть [в статье на Хабре](https://habrahabr.ru/company/matreshka/blog/277171/).



### Как работает Матрешка?
Матрешка использует акцессоры (accessors), в частности, сеттеры (setters) для реализации двустороннего связывания данных и отлова событий изменения свойств. Эта технология существует достаточно давно. Одной из главных особенностей сеттеров, является молниеносная скорость, сравнимая со скоростью работы с обычными свойствами. В производительности акцессоры выигрывают у других решений: ``Object.observe`` и, особенно, dirty-checking.

В качестве примера того, как работает двустороннее связывание (в частности, функция [bindNode](#!Matreshka-bindNode)), взгляните на этот код:
```js
window.bindNode = function bindNode(object, key, node, binder) {
    var value = object[key];
    Object.defineProperty(object, key, {
        get: function() {
            return value;
        },
        set: function(v) {
            binder.setValue.call(node, v);
        }
    });

    node.addEventListener(binder.on, function() {
        value = binder.getValue.call(node);
    });
};
```
Как видите, ничего сложного (для упрощения, функция не поддерживает связь многие-ко-многим).

Пример работы функции можно посмотреть на [jsbin](//jsbin.com/mabetap/7/edit?html,js,output).

### Поддерживает ли Матрешка серверный рендеринг?
К сожалению, (возможно, пока) нет. Матрешка использует DOM шаблонизацию, которая требует наличия на сервере библиотеки, реализующей DOM API. Хорошим примером такой библиотеки является [jsdom](https://github.com/tmpvar/jsdom). Проблема в том, что к серверу присоединяется много клиентов, каждый из которых может запросить соверщенно разные страницы, генерирующиеся динамически. DOM шаблонизация работает заметно медленнее, чем HTML шаблонизация, где шаблоном выступает обычный текст, а не многочисленные DOM объеты.

В качестве примера, можно привести серверный рендеринг React компонентов, которые тоже требуют DOM шаблонизатор. Как правило, эта задача решается хитрыми трюками и рекомендациями использовать кеширование шаблонов (что не всегда возможно, а если возможно, может вызвать утечки памяти). Даже используя лучшие практики и хитроумные решения, обычный текстовый HTML шаблонизатор (скажем, [mustache.js](https://github.com/janl/mustache.js)) решит проблему многократно быстрее, а скорость на сервере, как известно, намного важне, чем на клиенте.

Поэтому, на сегодняшний день, единственной рекомендацией к серверному рендерингу является перекладывание задачи генерации HTML строки на любой текстовый шаблонизатор. Оставим узкоспециализированные задачи выполнять инструментам, делающим это лучше всего.
