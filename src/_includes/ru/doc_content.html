<section>
<article id="!introduction"><h2><a href="#!introduction">Введение</a></h2><p>Матрешка - фреймворк для больших и бесконечно расширяемых приложений (в рамках Вселенной, конечно же), написанных на языке JavaScript. Он позволяет построить архитектуру программы так, чтоб ни вы, ни ваша команда не запутались в многочисленных сущностях, в дебаггинге логики, описанной в HTML файле, многочисленных ограничениях других фреймворков и непонятных абстракциях.</p>
<p>Двухсторонняя привязка данных и представления осуществляется с помощью метода <a href="#!Matreshka-bindNode">bindNode</a> исключительно в .js (или .es6) файлах и не требует менять HTML, добавляя чуждые {% raw %}{{синтаксические.конструкции}}{% endraw %}. Программист, задав несколько правил, может продолжать работать с данными, забыв о состоянии видимой части приложения.</p>
<blockquote>
<p>Порядок не важен, вы можете объявить привязки после полной реализации логики, отвечающей за данные.</p>
</blockquote>
<p>Коллекции в Матрешке представлены классом <a href="#!Matreshka.Array">Matreshka.Array</a>, экземпляры которого сами рендерят HTML при добавлении, удалении или изменении элементов. Вы можете сказать, что фреймворк X тоже отрисовывает элементы массива при изменении данных, но в Матрешке эта задача решается невероятно просто и элегантно.</p>
<p>Кроме всего прочего, Матрешка - очень лёгкий для понимания фреймворк. Любой разработчик, от новичка, умеющего писать простые штуки на JavaScript, до опытного ниндзи, разберется без проблем.</p>
<p>Сегодня <script>document.write(new Date().getFullYear());</script> год, это значит, что, наконец, пришло время фреймворка без ограничений, жестких правил и сомнительного синтаксиса. Пришло время фреймворка для программистов, которым управляете вы, а не он управляет вами!</p></article><article id="!getting-started"><h2><a href="#!getting-started">С чего начать</a></h2><p>Все популярные фреймворки включают в себя множество удобных и интересных функций. Проблема в том, что новичку порой сложно понять, с чего начинать своё обучение. Изобилие функциональных возможностей того или иного фреймворка наводит на резонный вопрос: "Эй, я должен всё это выучить?".</p>
<p>В этой документации этот недочет решен. Для того, чтоб начать уверенно работать с фреймворком, нужно изучить классы, свойства и методы, помеченные, как важные, флажком <i class="important"></i> (их чуть больше десяти). Дальше, при желании, можно постепенно приступать к освоению остальных методов (например, помеченых, как "крутые" иконкой <i class="cool"></i>), добавляющих в ваш JavaScript код ту магию, о которой вы и не мечтали.</p>
<blockquote>
<p>Потрясающие возможности HTML5 не обошли стороной и эту страницу. Она доступна оффлайн для любого устройства, от вашего компьютера до мобильного телефона.</p>
<p><strong>Chrome для Android</strong>: зайдите в меню и нажмите "Добавить на главный экран" или "Add to home screen"</p>
<p><strong>Safari для iOS</strong>: нажмите на иконку "Action" и выберите "Add to Home Screen"</p>
<p><strong>Любые другие устройства</strong>: просто добавьте страницу в закладки</p>
<p>Теперь документацию к Матрешке можно читать без подключения к интернету. Если страница тормозит (замечено на Android 4.2), переключитесь в режим "По одному".</p>
</blockquote></article><article id="!hello-world"><h2><a href="#!hello-world">Hello World!</a></h2><p>Написать первое приложение с помощью фреймворка Матрешка очень просто. Для этого:</p>
<p><strong>1.</strong> Создайте HTML файл со следующим содержимым</p>
<pre class="prettyprint source lang-html"><code>&lt;!DOCTYPE html>
&lt;html>
    &lt;head>
        &lt;title>Моё первое приложение на базе Матрешки&lt;/title>
    &lt;/head>
    &lt;body>
        &lt;input type="text" class="my-input">
        &lt;div class="my-output">&lt;/div>
        &lt;script src="http://cdn.jsdelivr.net/matreshka/latest/matreshka.min.js">&lt;/script>
        &lt;script src="js/app.js">&lt;/script>
    &lt;/body>
&lt;/html></code></pre><p><strong>2.</strong> Напишите свой первый класс, наследующий Матрешку, создав файл <strong>js/app.js</strong></p>
<pre class="prettyprint source lang-js"><code>var Application = Class({
    'extends': Matreshka,
    constructor: function() {

        // связываем свойство x и текстовое поле
        this.bindNode('x', '.my-input');

        // связываем свойство x и блок с классом my-output
        this.bindNode('x', '.my-output', {
            setValue: function(v) {
                this.innerHTML = v;
            }
        });

        // если свойство "х" изменилось, сообщаем об этом в консоли
        this.on('change:x', function() {
            console.log('x изменен на ' + this.x);
        });
    }
});

var app = new Application();</code></pre><p><strong>3.</strong> Это всё!</p>
<p>Теперь можете открыть консоль разработчика (клавиша F12) и написать:</p>
<pre class="prettyprint source lang-js"><code>app.x = 'Привет Мир!';</code></pre><p>Круто, не правда ли? Теперь можно работать напрямую со свойствами без болезненных инкапсуляций.</p>
<blockquote>
<p>Матрешка использует объектно-ориентированный подход основанный на классах, которые зарекомендовали себя с самой лучшей стороны в большинстве языков программирования: Python, C#, Java и многих других. Такое решение позволяет легко перейти на новые возможности синтаксиса JavaScript, описанные в стандарте ECMAScript 2015 и поддерживаемые Матрешкой. Проекты типа <a href="http://babeljs.io/">Babel</a> уже сегодня позволяют использовать крутой синтаксис JS нового поколения.</p>
<pre class="prettyprint source lang-js"><code>class Application extends Matreshka {
    constructor() {
        this.bindNode('x', '.my-input');
        this.bindNode('x', '.my-output', {
            setValue(v) {
                this.innerHTML = v;
            }
        });
        this.on('change:x', () =>
            console.log('x изменен на ' + this.x));
    }
}</code></pre></blockquote>
<p><a href="http://jsbin.com/lalerebepo/2/edit?js,output">Живой пример</a> (нажмите кнопку "Run with JS", чтобы пример запустился)</p>
<h4>Ссылки</h4><ul>
<li><a href="#!Matreshka">Класс Matreshka</a></li>
<li><a href="#!Matreshka-bindNode">Метод Matreshka#bindNode</a></li>
<li><a href="#!Matreshka-on">Метод Matreshka#on</a></li>
<li><a href="#!Class">Функция Class</a></li>
</ul></article><article id="!todomvc"><h2><a href="#!todomvc">TodoMVC</a></h2><p>Как известно, самым эффективным способом понять, стоит ли изучать библиотеку или фреймворк является код. Проект <a href="http://todomvc.com/">TodoMVC</a> объединяет десятки фреймворков позволяя их сравнить на примере одного и того же приложения.
<img src="img/todomvc.png" alt="TodoMVC"></p>
<p>Посмотрите на <a href="todo/">живую реализацию TodoMVC</a> на базе Матрешки, а, затем, <a href="todo/js_ru/docs/app.html">взгляните на исходный код с аннотациями</a>. Выглядит очень просто, не так ли?</p></article><article id="!how-to-include"><h2><a href="#!how-to-include">Как подключить?</a></h2><p>Матрешка - самостоятельный фреймворк, не требующий никаких зависимостей. Но возможность использования уже не современных возможностей из стандарта ECMAScript5 в Internet Explorer 8 отсутствует. Поэтому, если вы поддерживаете IE8 в разрабатываемых вами приложениях, вам нужно подключить еще один JavaScript файл: <a href="https://github.com/es-shims/es5-shim">es5-shim</a> или любой другой полифил, реализующий возможности ECMAScript5.</p>
<blockquote>
<p>Внимание! Начиная с версии 1.1, работа Матрешки в Internet Explorer 8 не рекомендуется по причине того, что было добавлено слишком много методов, которые невозможно реализовать поддерживая этот браузер. Это значит, что автоматические тесты тоже не будут работать. Причина: восьмой "Осел" не поддерживает навешивание акцессоров на нативные объекты. Старые приложения (на основе Матрешки 1.0 и ниже) должны по-прежнему корректно работать. Если вам всё еще нужна поддержка IE8, просто не используйте методы старше версии 1.1, включительно. Теперь Матрешка сфокусирована на поддержке Internet Explorer 9+ и остальных браузеров.</p>
</blockquote>
<p>Подключение jQuery для всех браузеров - опционально (хотя, для IE8 рекомендуемо). Вместо этой библиотеки можете воспользоваться другой jQuery-подобной библиотекой, например, <a href="http://zeptojs.com/">Zepto</a>. Если вы вовсе не хотите использовать библиотек, отдавая предпочтение <a href="http://vanilla-js.com/">Vanilla.js</a>, Матрешка будет использовать встроенную микро-библиотеку, которая называется <a href="#$b">Балалайка</a>.</p>
<pre class="prettyprint source lang-html"><code>&lt;!-- Обязательно для IE8 -->
&lt;script src="js/es5-shim.min.js">&lt;/script>
&lt;script src="js/matreshka.min.js">&lt;/script></code></pre><p>Кроме этого, Матрешка поддерживает AMD, например, require.js или almond</p>
<pre class="prettyprint source lang-js"><code>require(['path/to/matreshka'], function(Matreshka) {
    //...
});</code></pre><p>Импорт в стиле EcmaScript6 (используя Babel)</p>
<pre class="prettyprint source lang-js"><code>import Matreshka from 'path/to/matreshka';</code></pre></article>
</section>

	<section>
	<article class="item class" id="!Matreshka">
		<h2>
			<a href="#!Matreshka">
				<span class="signature-class">Класс</span> Matreshka
			</a>
			<i class="important" title="Важно"></i>
		</h2>
		<div class="description">
			<p>Класс Matreshka - ядро фреймворка Matreshka.js, от которого наследуются <a href="#!Matreshka.Array">Matreshka.Array</a>, <a href="#!Matreshka.Object">Matreshka.Object</a> и каждый класс создаваемого приложения. Он содержит основной функционал фреймворка, среди которого есть несколько полезнейших функций: <a href="#!Matreshka-mediate">медиаторы</a>, <a href="#!Matreshka-linkProps">зависимости</a>, <a href="#!Matreshka-bindNode">привязки к DOM</a>, <a href="#!Matreshka-on">движок событий</a> и пр. Наследование этого класса, как и наследование любого другого класса, осуществляется при помощи функции <a href="#!Class">Class</a>.</p>
<p>Как правило, этот класс, (как и <a href="#!Matreshka.Array">Matreshka.Array</a> и <a href="#!Matreshka.Object">Matreshka.Object</a>), не используются напрямую. Вместо этого, от него наследуются классы, создаваемые вами. Поэтому, примеры к свойствам и методам в этой документации, как правило, будут приведены с использованием ключевого слова <code>this</code>.</p>
		</div>
		
		
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Class">Class</a>
	
</ul>


		 
	<h4>Примеры</h4>
  
<h5><p>Создание экземпляра</p></h5>
<pre class="prettyprint source lang-js"><code>var mk = new Matreshka;</code></pre><h5><p>Краткая запись: MK вместо Matreshka</p></h5>
<pre class="prettyprint source lang-js"><code>var mk = new MK;</code></pre><h5><p>Наследование</p></h5>
<pre class="prettyprint source lang-js"><code>var MyClass = Class({
	'extends': Matreshka,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});</code></pre><h5><p>Матрешка использует прототипы для реализации наследования. Функция <a href="#!Class">Class</a> лишь вносит синтаксический сахар и добавляет хаки для Internet Explorer 8. Поэтому вы можете воспользоваться любым другим полюбившимся способом наследования, например, используя классы из ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>class MyClass extends Matreshka {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}</code></pre>
		<a class="comments" data-id="Matreshka" data-title="Класс Matreshka">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka"
  title="Класс Matreshka"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
	</article>
	
<article class="item property" id="!Matreshka-isMK" data-since="">
	<h2>
		<a href="#!Matreshka-isMK">

			<span class="memberof">Matreshka#</span>isMK</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>

			<!-- <span data-type="boolean">boolean</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p><code>isMK</code> всегда равен <code>true</code>. Это свойство используется для того, чтоб определить, является ли объект экземпляром класса <a href="#!Matreshka">Matreshka</a></p></div>
	<div class="description"></div>
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>alert(object.isMK);</code></pre>
	<a class="comments" data-id="Matreshka-isMK" data-title="Свойство Matreshka-isMK">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-isMK"
  title="Свойство Matreshka-isMK"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item property" id="!Matreshka-$sandbox" data-since="0.4">
	<h2>
		<a href="#!Matreshka-$sandbox">

			<span class="memberof">Matreshka#</span>$sandbox</a><span class="type">:
				<span data-type="$nodes">$nodes</span>
			</span>

			<!-- <span data-type="$nodes">$nodes</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Свойство содержит HTML песочницу в виде коллекции (jQuery, Zepto, Balalaika)</p></div>
	<div class="description"></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode">Matreshka#bindNode</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('sandbox', '.app');
this.$sandbox; // то же самое, что и $('.app')</code></pre>
	<a class="comments" data-id="Matreshka-$sandbox" data-title="Свойство Matreshka-$sandbox">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-$sandbox"
  title="Свойство Matreshka-$sandbox"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item property" id="!Matreshka-sandbox" data-since="0.4">
	<h2>
		<a href="#!Matreshka-sandbox">

			<span class="memberof">Matreshka#</span>sandbox</a><span class="type">:
				<span data-type="node">node</span>
			</span>

			<!-- <span data-type="node">node</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Свойство содержит HTML песочницу</p></div>
	<div class="description"></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode">Matreshka#bindNode</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('sandbox', '.app');
this.sandbox; // то же самое, что и $('.app')[0]</code></pre>
	<a class="comments" data-id="Matreshka-sandbox" data-title="Свойство Matreshka-sandbox">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-sandbox"
  title="Свойство Matreshka-sandbox"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item property" id="!Matreshka-$nodes" data-since="1.1">
	<h2>
		<a href="#!Matreshka-$nodes">

			<span class="memberof">Matreshka#</span>$nodes</a><span class="type">:
				<span data-type="$nodes">$nodes</span>
			</span>

			<!-- <span data-type="$nodes">$nodes</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Объект содержит коллекции (jQuery, Zepto, Balalaika) привязанных элементов для быстрого доступа.</p></div>
	<div class="description"></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode">Matreshka#bindNode</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-node');
this.$nodes.myKey; // то же самое, что и $('.my-node')</code></pre>
	<a class="comments" data-id="Matreshka-$nodes" data-title="Свойство Matreshka-$nodes">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-$nodes"
  title="Свойство Matreshka-$nodes"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item property" id="!Matreshka-nodes" data-since="1.1">
	<h2>
		<a href="#!Matreshka-nodes">

			<span class="memberof">Matreshka#</span>nodes</a><span class="type">:
				<span data-type="node">node</span>
			</span>

			<!-- <span data-type="node">node</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Объект содержит привязанные элементы для быстрого доступа, в виде отдельных DOM узлов.</p></div>
	<div class="description"><p>Обратите внимание, каждое свойство объекта содержит первый узел из связанных с соотвутствующим свойством.  Для получения всех узлов, связанных с определенным свойством, используйте <a href="#!Matreshka-$nodes">Matreshka#$nodes</a>.</p></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode">Matreshka#bindNode</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-node');
this.nodes.myKey; // то же самое, что и $('.my-node')[0]</code></pre>
	<a class="comments" data-id="Matreshka-nodes" data-title="Свойство Matreshka-nodes">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-nodes"
  title="Свойство Matreshka-nodes"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

	
<article class="item method" id="!Matreshka-on" data-since="">
	<h2>
		<a href="#!Matreshka-on">
			<span class="memberof">Matreshka#</span>on<wbr>(<span class="args">names, callback, triggerOnInit, context</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		<i class="important" title="Важно"></i>
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Добавляет обработчик события</p></div>
	<div class="description"><p>Метод <a href="#!Matreshka-on">Matreshka#on</a> добавляет обработчик события для экземпляра класса <code>Matreshka</code>. Полный список возможных событий с описанием см. здесь: <span data-type="eventNames">eventNames</span>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">addevent</span> <span class="event">addevent:NAME</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						names
						
					</td>
					 
					<td>
	<span data-type="eventNames">eventNames</span>
</td>
					<td> Имя события или несколько имен, разделенных пробелом  (например, ``"change:x ajaxcomplete change:y"``)</td>
				</tr>
			 
				<tr>
					<td>
						callback
						
					</td>
					 
					<td>
	<span data-type="eventHandler">eventHandler</span>
</td>
					<td> Функция, которая вызывается по событию</td>
				</tr>
			 
				<tr>
					<td>
						triggerOnInit
						
							<span class="signature">optional</span>
						
					</td>
					 false
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> Если аргумент ``triggerOnInit`` равен ``true``, то обработчик будет вызван немедленно после инициализации.</td>
				</tr>
			 
				<tr>
					<td>
						context
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Контекст обработчика. Другими словами, ``this`` при вызове ``callback``</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-onDebounce">Matreshka#onDebounce</a>
	
		<li><a href="#!Matreshka-once">Matreshka#once</a>
	
		<li><a href="#!Matreshka-off">Matreshka#off</a>
	
		<li><a href="#!Matreshka-trigger">Matreshka#trigger</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on('foo', function() {
	alert('Custom Event is fired');
});

this.trigger('foo');</code></pre><h5><p>Передача контекста</p></h5>
<pre class="prettyprint source lang-js"><code>this.on('foo', function() {
	alert(this.a); // 5
}, {a: 5});

this.trigger('foo', 'Hello world');</code></pre><h5><p>Вызов обработчика сразу после инициализации</p></h5>
<pre class="prettyprint source lang-js"><code>//Выводит на экран "bar" сиюсекундно и ждет генерации события "foo"
this.on('foo', function() {
	alert('bar');
}, true);</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-on" data-title="Метод Matreshka-on">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-on"
  title="Метод Matreshka-on"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-on(2)" data-since="1.1">
	<h2>
		<a href="#!Matreshka-on(2)">
			<span class="memberof">Matreshka#</span>on<wbr>(<span class="args">evtnameHandlerObject, triggerOnInit, context</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		<i class="important" title="Важно"></i>
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис: пары &quot;событие-обработчик&quot;</p></div>
	<div class="description"><p>В метод <a href="#!Matreshka-on">Matreshka#on</a> можно передать объект с парами событие-обработчик, чтобы избежать многократного вызова метода и сократить код.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						evtnameHandlerObject
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект с событиями</td>
				</tr>
			 
				<tr>
					<td>
						triggerOnInit
						
							<span class="signature">optional</span>
						
					</td>
					 false
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> Если аргумент ``triggerOnInit`` равен ``true``, то обработчики будут вызван немедленно после инициализации</td>
				</tr>
			 
				<tr>
					<td>
						context
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Контекст обработчика</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>Особенно круто этот способ вызова метода ``on`` выглядит с использованием синтаксиса ECMAScript 2015
this.on({
	'custom': evt => ...,
	'click::x': evt => ...,
	'change:y': evt => ...,
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-on(2)" data-title="Метод Matreshka-on(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-on(2)"
  title="Метод Matreshka-on(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-onDebounce" data-since="">
	<h2>
		<a href="#!Matreshka-onDebounce">
			<span class="memberof">Matreshka#</span>onDebounce<wbr>(<span class="args">names, callback, debounceDelay, triggerOnInit, context</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Добавляет обработчик события, вызываемый лишь однажды за определенный промежуток времени</p></div>
	<div class="description"><p>Метод позволяет добавить обработчик события на экземпляр класса <a href="#!Matreshka">Matreshka</a>, устраняя &quot;дребезжание&quot; обработчика. Функция может быть вызвана лишь один раз за определенный промежуток времени. В остальном, метод работает так же, как и <a href="#!Matreshka-on">Matreshka#on</a>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">addevent</span> <span class="event">addevent:NAME</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						names
						
					</td>
					 
					<td>
	<span data-type="eventNames">eventNames</span>
</td>
					<td> Имя события или несколько имен, разделенных пробелом  (например, ``"change:x ajaxcomplete change:y"``).</td>
				</tr>
			 
				<tr>
					<td>
						callback
						
					</td>
					 
					<td>
	<span data-type="eventHandler">eventHandler</span>
</td>
					<td> Функция, которая вызывается по событию</td>
				</tr>
			 
				<tr>
					<td>
						debounceDelay
						
							<span class="signature">optional</span>
						
					</td>
					 0
					<td>
	<span data-type="number">number</span>
</td>
					<td> Задержка</td>
				</tr>
			 
				<tr>
					<td>
						triggerOnInit
						
							<span class="signature">optional</span>
						
					</td>
					 false
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> Если аргумент ``triggerOnInit`` равен ``true``, то обработчик будет вызван немедленно после инициализации</td>
				</tr>
			 
				<tr>
					<td>
						context
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Контекст обработчика. Другими словами, ``this`` при вызове ``callback``</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-on">Matreshka#on</a>
	
		<li><a href="#!Matreshka-once">Matreshka#once</a>
	
		<li><a href="#!Matreshka-off">Matreshka#off</a>
	
		<li><a href="#!Matreshka-trigger">Matreshka#trigger</a>
	
		<li><a href="#!Matreshka.debounce">Matreshka.debounce</a>
	
		<li><a href="http://habrahabr.ru/post/60957/" target="_blank">Статья на Хабре о микропаттерне debounce</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.onDebounce('change:x', function() {
	alert('x = ' + this.x); // x = 100
}, 300);

this.x = 1;

for(var i = 0; i &lt; 100; i++) {
	this.x++;
}</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-onDebounce" data-title="Метод Matreshka-onDebounce">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-onDebounce"
  title="Метод Matreshka-onDebounce"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-onDebounce(2)" data-since="1.1">
	<h2>
		<a href="#!Matreshka-onDebounce(2)">
			<span class="memberof">Matreshka#</span>onDebounce<wbr>(<span class="args">evtnameHandlerObject, debounceDelay, triggerOnInit, context</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис: пары &quot;событие-обработчик&quot;</p></div>
	<div class="description"><p>В метод <a href="#!Matreshka-onDebounce">Matreshka#onDebounce</a> можно передать объект с парами событие-обработчик, чтобы избежать многократного вызова метода и сократить код.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						evtnameHandlerObject
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект с событиями</td>
				</tr>
			 
				<tr>
					<td>
						debounceDelay
						
							<span class="signature">optional</span>
						
					</td>
					 0
					<td>
	<span data-type="number">number</span>
</td>
					<td> Задержка</td>
				</tr>
			 
				<tr>
					<td>
						triggerOnInit
						
							<span class="signature">optional</span>
						
					</td>
					 false
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> Если аргумент ``triggerOnInit`` равен ``true``, то обработчики будут вызван немедленно после инициализации</td>
				</tr>
			 
				<tr>
					<td>
						context
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Контекст обработчиков</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-on(2)">Matreshka#on(2)</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.onDebounce({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-onDebounce(2)" data-title="Метод Matreshka-onDebounce(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-onDebounce(2)"
  title="Метод Matreshka-onDebounce(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-once" data-since="">
	<h2>
		<a href="#!Matreshka-once">
			<span class="memberof">Matreshka#</span>once<wbr>(<span class="args">names, callback, context</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Добавляет обработчик событий, который может быть вызван однажды</p></div>
	<div class="description"><p>Метод работает так же, как и <a href="#!Matreshka-on">Matreshka#on</a> но передаваемый обработчик может быть вызван только один раз.
Обратите внимание, что у метода отсутствует аргумент <code>triggerOnInit</code>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">addevent</span> <span class="event">addevent:NAME</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						names
						
					</td>
					 
					<td>
	<span data-type="eventNames">eventNames</span>
</td>
					<td> Имя события или несколько имен, разделенных пробелом (например, <code>"change:x ajaxcomplete change:y"</code>)</td>
				</tr>
			 
				<tr>
					<td>
						callback
						
					</td>
					 
					<td>
	<span data-type="eventHandler">eventHandler</span>
</td>
					<td> Функция, которая вызывается по событию</td>
				</tr>
			 
				<tr>
					<td>
						context
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Контекст обработчика</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-on">Matreshka#on</a>
	
		<li><a href="#!Matreshka-off">Matreshka#off</a>
	
		<li><a href="#!Matreshka-onDebounce">Matreshka#onDebounce</a>
	
		<li><a href="#!Matreshka-trigger">Matreshka#trigger</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.x = 1;

this.once('change:x', function() {
	alert('x is changed');
});

this.x = 2; // выводит 'x is changed'

this.x = 3; // ничего не делает</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-once" data-title="Метод Matreshka-once">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-once"
  title="Метод Matreshka-once"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-once(2)" data-since="1.1">
	<h2>
		<a href="#!Matreshka-once(2)">
			<span class="memberof">Matreshka#</span>once<wbr>(<span class="args">evtnameHandlerObject, context</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис: пары &quot;событие-обработчик&quot;</p></div>
	<div class="description"><p>В метод <a href="#!Matreshka-once">Matreshka#once</a> можно передать объект с парами событие-обработчик, чтобы избежать многократного вызова метода и сократить код.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						evtnameHandlerObject
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект с событиями</td>
				</tr>
			 
				<tr>
					<td>
						context
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Контекст обработчиков</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-on(2)">Matreshka#on(2)</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.once({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-once(2)" data-title="Метод Matreshka-once(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-once(2)"
  title="Метод Matreshka-once(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-off" data-since="">
	<h2>
		<a href="#!Matreshka-off">
			<span class="memberof">Matreshka#</span>off<wbr>(<span class="args">names, callback, context</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет обработчик события</p></div>
	<div class="description"><p>Удаляет созданный ранее обработчик. Все три аргумента опциональны. Вы можете удалить как все события (не передавая ни одного аргумента), так и отдельные (передав только имя события, передав имя события и обработчик, передав и имя события, и обработчик, и контекст)</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">removeevent</span> <span class="event">removeevent:NAME</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						names
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventNames">eventNames</span>
</td>
					<td> Разделенный пробелами список имен событий (например, ``"change:x ajaxcomplete change:y"``)</td>
				</tr>
			 
				<tr>
					<td>
						callback
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventHandler">eventHandler</span>
</td>
					<td> Функция-обработчик</td>
				</tr>
			 
				<tr>
					<td>
						context
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Контекст</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-on">Matreshka#on</a>
	
		<li><a href="#!Matreshka-once">Matreshka#once</a>
	
		<li><a href="#!Matreshka-onDebounce">Matreshka#onDebounce</a>
	
		<li><a href="#!Matreshka-trigger">Matreshka#trigger</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.off('change:x bind');</code></pre><h5><p>Удаление всех событий</p></h5>
<pre class="prettyprint source lang-js"><code>this.off();</code></pre><h5><p>Удаление события с определенным обработчиком</p></h5>
<pre class="prettyprint source lang-js"><code>var handler = function() {
	//...
}
this.on('change:x', handler);
this.off('change:x', handler);</code></pre><h5><p>Удаление события с определенным контекстом</p></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
this.on('change:x', handler, object);
this.off('change:x', handler, object);</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-off" data-title="Метод Matreshka-off">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-off"
  title="Метод Matreshka-off"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-trigger" data-since="">
	<h2>
		<a href="#!Matreshka-trigger">
			<span class="memberof">Matreshka#</span>trigger<wbr>(<span class="args">names, arg</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		<i class="important" title="Важно"></i>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Генерирует событие</p></div>
	<div class="description"><p>После добавление обработчиков событий с помощью метода <a href="#!Matreshka-on">Matreshka#on</a>, <a href="#!Matreshka-onDebounce">Matreshka#onDebounce</a> или <a href="#!Matreshka-once">Matreshka#once</a>, событие можно генерировать вручную с помощью этого метода.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						names
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventNames">eventNames</span>
</td>
					<td> Имя события или несколько имен, разделенных пробелом</td>
				</tr>
			 
				<tr>
					<td>
						arg
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> Аргументы, которые будут переданы обработчикам</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-on">Matreshka#on</a>
	
		<li><a href="#!Matreshka-once">Matreshka#once</a>
	
		<li><a href="#!Matreshka-onDebounce">Matreshka#onDebounce</a>
	
		<li><a href="#!Matreshka-off">Matreshka#off</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on('foo bar', function(a, b, c) {
	alert(a + b + c);
});
this.trigger('bar', 1, 2, 3); // alerts 6</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-trigger" data-title="Метод Matreshka-trigger">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-trigger"
  title="Метод Matreshka-trigger"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-bindNode" data-since="">
	<h2>
		<a href="#!Matreshka-bindNode">
			<span class="memberof">Matreshka#</span>bindNode<wbr>(<span class="args">key, node, binder, eventOptions</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		<i class="important" title="Важно"></i>
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Связывает свойство объекта с HTML элементом</p></div>
	<div class="description"><p><a href="#!Matreshka-bindNode">Matreshka#bindNode</a> - это единственный метод класса <a href="#!Matreshka">Matreshka</a>, отвечающий за изменения DOM. Он создаёт мост между значением свойства и состоянием HTML элемента на странице: от простого инпута до сложного виджета (сложность элементов не ограничена). <code>bindNode</code>, по праву, можно назвать главным методом фреймворка. После связывания свойства экземпляра и HTML элемента не нужно больше следить за синхронизацией данных и представления.</p>
<p>Для двустороннего связывания элемента и значения свойства, в метод передаются три аргумента: <strong>имя свойства</strong> (ключ), <strong>HTML элемент</strong> (или селектор) и <strong>правило привязки</strong> (синонимы: байндер, биндер, binder, привязчик). Байндер, в свою очередь, является обычным объектом и может иметь следующие свойства: <code>on</code>, <code>getValue</code>, <code>setValue</code>, <code>initialize</code> (подробнее см. <span data-type="binder">binder</span>). Все четыре свойства - опциональны. Это позволяет также объявить и односторонние привязки.</p>
<blockquote>
<p>Метод <code>bindNode</code> поддерживает привязки &quot;многие ко многим&quot;. С одним свойством можно связать несколько элементов, а с одним элементом можно связать несколько свойств, в том числе и от разных экземпляров разных классов.</p>
</blockquote>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element', {
    on: 'click',
    getValue: function() { ... },
    setValue: function() { ... }
});</code></pre><p>Например, вы хотите связать свойство объекта с элементом <code>input[type=&quot;checkbox&quot;]</code>:</p>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-checkbox', {
    // когда менятся состояние элемента?
    // - по событию 'click'
    on: 'click',
    // как извлечь состояние элемента?
    // - вернуть значение 'checked'
    getValue: function() {
        return this.checked;
    },
    // как установить состояние элемента?
    // - установить значение 'checked'
    setValue: function(v) {
        this.checked = !!v;
    }
});</code></pre><p>После объявления привязки можно устанавливать значение свойства объекта самым привычным способом, а элемент (в данном случае, чекбокс) моментально изменит своё состояние. При клике на чекбокс, значение свойства тоже изменится на соответствующее.</p>
<pre class="prettyprint source lang-js"><code>// устанавливает checked = false
this.myKey = true;</code></pre><blockquote>
<p>Если значение свойства экземпляра класса не задано, Матрешка, после привязки, попробует извлечь это значение из HTML узла, используя <code>getValue</code>. Отменить это поведение можно передав свойство <code>assignDefaultValue: false</code> в объект события.</p>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element', binder, {
    assignDefaultValue: false
});</code></pre></blockquote>
<p>Более сложный пример: связывание свойства объекта с виджетом jQuery UI</p>
<pre class="prettyprint source lang-html"><code>&lt;div class=&quot;my-slider&quot;>&lt;/div></code></pre><pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-slider', {
    // когда менятся состояние элемента?
    // - по событию 'slide'
    on: 'slide',
    // как извлечь состояние элемента?
    // - вернуть значение виджета 'value'
    getValue: function() {
        return $(this).slider('option', 'value');
    },
    // как установить состояние элемента?
    // - установить значение 'value'
    setValue: function(v) {
        $(this).slider('option', 'value', v);
    },
    // как инициализировать виджет?
    // инициализировать слайдер можно любым способом,
    // но initialize предоставляет немного синтаксического сахара
    initialize: function() {
        $(this).slider({min: 0, max: 100});
    }
});</code></pre><pre class="prettyprint source lang-js"><code>// установит знaчeние слайдера 42
this.myKey = 42;</code></pre><p>Выглядит просто, но вы, скорее всего, задаётесь вопросом: &quot;Как сделать так, чтоб мне не пришлось каждый раз прописывать эти правила?&quot;. Вопрос очень правильный. Действительно, на странице может быть очень много однотипных элементов: текстовых полей, выпадающих меню, новых полей из спецификации HTML5, могут быть и сторонние виджеты (о чем говорит пример выше).</p>
<p>Как видно из документации к аргументам метода <a href="#!Matreshka-bindNode">Matreshka#bindNode</a> (см. ниже), третий аргумент не обязателен. Этот вопрос решает массив <a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a>, который содержит функции, проверяющие HTML элемент на соответствие заданным правилам. Вы получаете возможность многократно сократить код, вынося правила привязки в отдельную часть вашего кода, а для привязки использовать синтаксис без третьего аргумента:</p>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element');</code></pre><p>Как это сделать? Нужно добавить функцию, проверяющую ваш элемент на соответствие некоторым правилам в начало массива <a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a>. Пример ниже можно использовать в качестве шаблона для создания своего стандартного байндера.</p>
<pre class="prettyprint source lang-js"><code>// добавляем байндер в коллекцию байндеров
// это нужно для того, чтоб сохранить возможность переопределения
Matreshka.binders.checkbox = function() {
    return {
        on: 'click',
        getValue: function() {
            return this.checked;
        },
        setValue: function(v) {
            this.checked = !!v;
        }
    }
};

// метод unshift добавляет функцию в начало массива Matreshka.defaultBinders
Matreshka.defaultBinders.unshift(function(node) {
    // проверяем, является ли элемент чекбоксом
    if(node.tagName == 'INPUT' && node.type == 'checkbox') {
        // если проверка пройдена, возвращаем новый байндер
        return Matreshka.binders.checkbox();
    }
});</code></pre><pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-checkbox');
this.myKey = true;</code></pre><p>Что делать, если вам нужно передать аргументы для инициализации какого-нибудь плагина или виджета? Всё очень просто: можно ограничиться добавлением байндера в коллекцию <a href="#!Matreshka.binders">Matreshka.binders</a>, не создавая функцию для <a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a>.</p>
<pre class="prettyprint source lang-js"><code>Matreshka.binders.uiSlider = function(min, max) {
    return {
        on: 'slide',
        getValue: function() {
            return $(this).slider('option', 'value');
        },
        setValue: function(v) {
            $(this).slider('option', 'value', v);
        },
        initialize: function() {
            $(this).slider({min: min, max: max});
        }
    }
};</code></pre><pre class="prettyprint source lang-js"><code>this.bindNode('myKey1', '.my-slider1', Matreshka.binders.uiSlider(0, 100));
this.bindNode('myKey2', '.my-slider2', Matreshka.binders.uiSlider(1, 1000));
this.myKey1 = 42;
this.myKey2 = 999;</code></pre><p><a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a> из коробки, начиная с версии 0.3, содержит поддержку <strong>всех без исключения</strong> HTML элементов форм: <code>select</code> (включая <code>multiple</code>), <code>textarea</code>, <code>input</code> (в том числе и все типы из спецификации HTML5: <code>text</code>, <code>checkbox</code>, <code>radio</code>, <code>range</code>, <code>number</code>, <code>date</code>, <code>search</code>, <code>time</code>, <code>datetime</code>, <code>datetime-local</code>, <code>color</code> и остальных). Это значит, что для стандартных элементов указывать байндер вовсе не обязательно.</p>
<pre class="prettyprint source lang-html"><code>&lt;input type=&quot;color&quot; class=&quot;my-color-input&quot;></code></pre><pre class="prettyprint source lang-js"><code>this.bindNode('myColor', '.my-color-input');
this.myColor = '#66bb6a';</code></pre><p>Кроме всего, после привязки, вам доступен новый нестандартный CSS селектор <code>:bound(KEY)</code>.</p>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element');

// найдет элемент '.my-inner-element' внутри '.my-element'
this.bindNode('myAnotherKey', ':bound(myKey) .my-inner-element');</code></pre><p>И расширяется синтаксис возможных имен событий:</p>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element');

// отловит клик на элементе .my-element
this.on('click::myKey', function() { ... });

// отловит клик на элементе .my-inner-element
this.on('click::myKey(.my-inner-element)', function() { ... });</code></pre><h4>Создание песочницы</h4><p><a href="#!Matreshka-bindNode">Matreshka#bindNode</a> умеет ассоциировать экземпляр класса с &quot;главным&quot; HTML элементом на странице, создавая так называемую <strong>песочницу</strong>. Это нужно для того, чтоб ограничить влияние экземпляра на HTML элементы, содержащиеся в другой песочнице (т. е. в другом HTML элементе). Для привязки песочницы используется специальное свойство <code>'sandbox'</code>.</p>
<pre class="prettyprint source lang-html"><code>&lt;div class=&quot;my-sandbox&quot;>
    &lt;!-- your HTML code -->
&lt;/div></code></pre><pre class="prettyprint source lang-js"><code>this.bindNode('sandbox', '.my-sandbox');</code></pre><p>Определение песочницы добавляет множество удобств программисту. Например:</p>
<ul>
<li>Позволяет использовать методы <a href="#!Matreshka-select">Matreshka#select</a> и <a href="#!Matreshka-$">Matreshka#$</a></li>
<li>Позволяет использовать методы <a href="#!Matreshka-bound">Matreshka#bound</a> и <a href="#!Matreshka-$bound">Matreshka#$bound</a> без указания аргумента</li>
<li>Позволяет использовать свойства <a href="#!Matreshka-sandbox">Matreshka#sandbox</a> и <a href="#!Matreshka-$sandbox">Matreshka#$sandbox</a></li>
<li>Добавляет новый селектор <code>:sandbox</code> в методах <a href="#!Matreshka-bindNode">Matreshka#bindNode</a>, <a href="#!Matreshka-select">Matreshka#select</a>, <a href="#!Matreshka-$">Matreshka#$</a> и других</li>
<li>Добавляет синтаксический сахар для делегированных DOM событий в методе <a href="#!Matreshka-on">Matreshka#on</a></li>
</ul>
<pre class="prettyprint source lang-js"><code>// объявляем песочницу
this.bindNode('sandbox', '.my-sandbox');

// .my-element ищется в песочнице
this.bindNode('myKey', ':sandbox .my-element');

// для делегированных событий внутри песочницы не требуется указывать ключ
this.on('click::(.my-button)', function() { ... });

// выведет в консоль элемент песочницы
console.log(this.$bound());

// выведет в консоль элемент .inner-node, который находится внутри песочницы
console.log(this.$('.inner-node'));</code></pre><h4>Глубокое связывание</h4><p>Начиная с версии 1.1, метод <code>bindNode</code> поддерживает так называемое &quot;глубокое связывание&quot;. Метод научился связывать DOM узел со свойством внутри дерева вложенных объектов. Например, у вас есть вложенный объект:</p>
<pre class="prettyprint source lang-js"><code>this.a = {b: {c: {d: 42}}};</code></pre><p>И вы хотите связать некий узел со свойством <code>d</code> из этого объекта. Достаточно только указать путь к свойству, а Матрешка будет слушать изменения во всём дереве объектов, то разрывая связь, то создавая её вновь:</p>
<pre class="prettyprint source lang-js"><code>this.bindNode('a.b.c.d', '.my-node');</code></pre><p>Когда произойдут какие-нибудь изменения в дереве, <code>bindNode</code> отловит эти изменения и пересоздаст связь между свойством и нодой.</p>
<pre class="prettyprint source lang-js"><code>this.a.b = {c: {d: 41}};</code></pre></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">bind</span> <span class="event">bind:KEY</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="matreshka">matreshka</span>
</td>
					<td> Ключ (имя свойства)</td>
				</tr>
			 
				<tr>
					<td>
						node
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="node">node</span>

	<span data-type="$nodes">$nodes</span>
</td>
					<td> HTML элемент, который должен быть связан со свойством экземпляра</td>
				</tr>
			 
				<tr>
					<td>
						binder
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="binder">binder</span>
</td>
					<td> Байндер (привязчик), содержащий следующие свойства: ``on`` - какое событие должно произойти на HTML элементе, говорящее о том, что пользователь что-то изменил (например, ``keyup`` или ``click``), ``getValue`` - как извлечь значение из HTML элемента, ``setValue`` - как установить новое значение элементу и ``initialize`` - функция, выполняющаяся однажды, при инициализации привязки. Более подробно о привязчиках можно найти в документации к ним: см. <span data-type="binder">binder</span>.</td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> Объект события, в который можно передать ключ ``"silent"`` (не генерировать события ``"bind"`` и ``"bind:KEY"``), ``"assignDefaultValue"`` или другие данные</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-unbindNode">Matreshka#unbindNode</a>
	
		<li><a href="#!Matreshka-bindOptionalNode">Matreshka#bindOptionalNode</a>
	
		<li><a href="#!Matreshka-$">Matreshka#$</a>
	
		<li><a href="#!Matreshka-$bound">Matreshka#$bound</a>
	
		<li><a href="#!Matreshka.binders">Matreshka.binders</a>
	
		<li><a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5><p>Кастомный чекбокс. Этот пример демонстрирует создание кастомного элемента, по клику на который у него меняется класс <code>&quot;checked&quot;</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.custom-checkbox', {
	on: 'click',
	getValue: function() {
		return $(this).hasClass('checked');
	},
	setValue: function( v ) {
		$(this).toggleClass('checked', !!v);
	},
	// инициализируем поведение элемента
	// по клику на элемент меняется наличие класса 'checked'
	initialize: function() {
		$(this).on('click', function() {
			$(this).toggleClass('checked');
		});
	}
});</code></pre><h5><p>Кастомный чекбокс 2. Этот пример повторяет предыдущий, но использует <a href="#!Matreshka-defaultBinders">Matreshka#defaultBinders</a>, и проверяет элемент на наличие класса <code>custom-checkbox</code>. Если проверка пройдена, возвращает байндер</p></h5>
<pre class="prettyprint source lang-js"><code>// добавляем байндер в коллекцию байндеров
Matreshka.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $(this).hasClass('checked');
		},
		setValue: function( v ) {
			$(this).toggleClass('checked', !!v);
		},
		initialize: function() {
			$(this).on( 'click', function() {
				$(this).toggleClass('checked');
			});
		}
	}
};

MK.defaultBinders.unshift(function(element) {
	// проверяем, есть ли у элемента класс "custom-checkbox"
	if($(element).hasClass('custom-checkbox') ) {
		// если проверка пройдена, возвращаем новый байндер
		return Matreshka.binders.customCheckbox();
	}
});

this.bindNode('myKey', '.my-custom-checkbox');</code></pre><h5><p>Событие <code>&quot;bind&quot;</code>, которое генерируется после связывании любого свойства и HTML узла</p></h5>
<pre class="prettyprint source lang-js"><code>this.on('bind', function() { alert('ok!'); });
this.bindNode('myKey', '.my-element'); // alerts "ok!"</code></pre><h5><p>Событие <code>&quot;bind:KEY&quot;</code>, которое генерируется при связыввании конкретного свойства и HTML узла</p></h5>
<pre class="prettyprint source lang-js"><code>this.on('bind:myKey', function() { alert('ok!'); });
this.bindNode('myKey', '.my-element'); // alerts "ok!"</code></pre><h5><p>Подмена DOM события для стандартного байндера. Например, мы хотим связать <code>input[type=&quot;text&quot;]</code> со свойством. По умолчанию, стандартный байндер для этого элемента содержит свойство <code>&quot;on&quot;</code> со значением <code>&quot;keydown paste&quot;</code>. Это значит, что значение свойства экземпляра и состояние элемента будут синхронизированы, когда пользователь отпускает клавишу клавиатуры или вставляет содержимое из буфера обмена. В случае, если вы хотите, чтоб синхронизация происходила по DOM событию <code>&quot;blur&quot;</code>, вам потребуется передать третьим аргументом объект, содержащий единственное свойство <code>&quot;on&quot;</code>. Этот объект объединится со стандартным байндером, сохранив при этом значения <code>getValue</code> и <code>setValue</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-input', {on: "blur"});</code></pre><h5><p>Если элемент не найден, бросается исключение <code>&quot;Bound element is missing&quot;</code>. Для того, чтоб избежать ошибки используйте метод <a href="#!Matreshka-bindOptionalNode">Matreshka#bindOptionalNode</a></p></h5>
<pre class="prettyprint source lang-js"><code>var $el = $();
this.bindNode('x', $el); // Ошибка, так как $el пуст</code></pre><h5><p>Синхронизация значения свойства и HTML содержимого элемента</p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element', {
	setValue: function(v) {
		this.innerHTML = v;
	}
});

// можно сделать проще
this.bindNode('myKey', '.my-element', MK.binders.html());</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-bindNode" data-title="Метод Matreshka-bindNode">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-bindNode"
  title="Метод Matreshka-bindNode"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-bindNode(2)" data-since="">
	<h2>
		<a href="#!Matreshka-bindNode(2)">
			<span class="memberof">Matreshka#</span>bindNode<wbr>(<span class="args">keyElementPairs, binder, eventOptions</span>)
				
		</a> 
		<i class="important" title="Важно"></i>
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис: пары &quot;ключ-элемент&quot;</p></div>
	<div class="description"><p>В метод <a href="#!Matreshka-bindNode">Matreshka#bindNode</a> можно передать объект с парами ключ-элемент, чтобы избежать многократного вызова метода и сократить код</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyElementPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> (см. пример)</td>
				</tr>
			 
				<tr>
					<td>
						binder
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="binder">binder</span>
</td>
					<td> (см. выше)</td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> (см. выше)</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode({
	myKey1: '.custom-checkbox',
	myKey2: 'textarea'
});</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>&lt;caption>Начиная с версии 1.1 синтаксис метода немного расширился: вместо элемента, можно передать массив, состоящий из элемента и байндера&lt;/caption></code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode({
	myKey1: ['.custom-checkbox', MK.binders.customCheckbox()],
	myKey2: 'textarea',
	myKey3: ['.my-node', {
		setValue: function(v) {
			// do something
		}
	}]
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-bindNode(2)" data-title="Метод Matreshka-bindNode(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-bindNode(2)"
  title="Метод Matreshka-bindNode(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-bindNode(3)" data-since="">
	<h2>
		<a href="#!Matreshka-bindNode(3)">
			<span class="memberof">Matreshka#</span>bindNode<wbr>(<span class="args">setOfArguments, eventOptions</span>)
				
		</a> 
		<i class="important" title="Важно"></i>
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис &quot;куча аргументов&quot;</p></div>
	<div class="description"><p>Еще один синтаксис для метода <a href="#!Matreshka-bindNode">Matreshka#bindNode</a>. Этот способ может показаться непривлекательным, но, иногда, есть нужда привязать много элементов с различными байндерами за один присест. С таким синтаксисом вы можете присвоить определенные байндеры какой-нибудь переменной, затем легко удалить все и сразу, используя <a href="#!Matreshka-unbindNode">Matreshka#unbindNode</a>.</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						setOfArguments
						
					</td>
					 
					<td>
	<span data-type="array">array</span>
</td>
					<td> Массив массивов аргументов (см. пример)</td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> (см. выше)</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode([
	[{
		myKey1: '.my-element1',
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3',
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5',
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
]);</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-bindNode(3)" data-title="Метод Matreshka-bindNode(3)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-bindNode(3)"
  title="Метод Matreshka-bindNode(3)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-bindOptionalNode" data-since="0.3">
	<h2>
		<a href="#!Matreshka-bindOptionalNode">
			<span class="memberof">Matreshka#</span>bindOptionalNode()
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Работает в точности так же, как и <a href="#!Matreshka-bindNode">Matreshka#bindNode</a> но не бросает исключение, если аргумент <code>node</code> - пустой массив, <code>undefined</code> или не существует</p></div>
	<div class="description"></div>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode">Matreshka#bindNode</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindOptionalNode('myKey', '.my-element');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-bindOptionalNode" data-title="Метод Matreshka-bindOptionalNode">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-bindOptionalNode"
  title="Метод Matreshka-bindOptionalNode"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-unbindNode" data-since="">
	<h2>
		<a href="#!Matreshka-unbindNode">
			<span class="memberof">Matreshka#</span>unbindNode<wbr>(<span class="args">key, node, eventOptions</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Разрывает связь между свойством и HTML элементом</p></div>
	<div class="description"><p>Используя этот метод, можно удалить недавно добавленную, но уже не нужную связь между свойством и элементом.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">unbind</span> <span class="event">unbind:KEY</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="null">null</span>
</td>
					<td> Ключ или список ключей, разделенных пробелами. Если вместо ключа передать null, удалятся все привязки для данного экземпляра</td>
				</tr>
			 
				<tr>
					<td>
						node
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="node">node</span>

	<span data-type="$nodes">$nodes</span>
</td>
					<td> HTML элемент, с которым свойство больше не хочет иметь дела</td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> Объект события, в который можно передать какие-нибудь данные для обработчика или ключ ``"silent"``, который отключает генерацию событий ``"unbind"`` и ``"unbind:KEY"``</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element');

// меняет значение свойства и состояние HTML элемента
this.myKey = true;

this.unbindNode('myKey', '.my-element');

// теперь меняется только значение свойства
this.myKey = false;</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-unbindNode" data-title="Метод Matreshka-unbindNode">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-unbindNode"
  title="Метод Matreshka-unbindNode"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-unbindNode(2)" data-since="">
	<h2>
		<a href="#!Matreshka-unbindNode(2)">
			<span class="memberof">Matreshka#</span>unbindNode<wbr>(<span class="args">keyElementPairs, eventOptions</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис <a href="#!Matreshka-unbindNode">Matreshka#unbindNode</a> &quot;ключ-элемент&quot; для <a href="#!Matreshka-unbindNode">Matreshka#unbindNode</a></p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyElementPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> (см. пример)</td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> (см. выше)</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode(2)">Matreshka#bindNode(2)</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.unbindNode({
	myKey1: '.my-element1'
	myKey1: '.my-element2'
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-unbindNode(2)" data-title="Метод Matreshka-unbindNode(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-unbindNode(2)"
  title="Метод Matreshka-unbindNode(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-unbindNode(3)" data-since="">
	<h2>
		<a href="#!Matreshka-unbindNode(3)">
			<span class="memberof">Matreshka#</span>unbindNode<wbr>(<span class="args">setOfArguments, eventOptions</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис <a href="#!Matreshka-unbindNode">Matreshka#unbindNode</a> &quot;большая куча аргументов&quot;</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						setOfArguments
						
					</td>
					 
					<td>
	<span data-type="array">array</span>
</td>
					<td> Массив массивов аргументов (см. пример)</td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> (см. выше)</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode(3)">Matreshka#bindNode(3)</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var temporaryBindings = [
	[{
		myKey1: '.my-element1'
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3'
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5'
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
];

this.bindNode(temporaryBindings);

// больше не нужны эти привязки
this.unbindNode(temporaryBindings);</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-unbindNode(3)" data-title="Метод Matreshka-unbindNode(3)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-unbindNode(3)"
  title="Метод Matreshka-unbindNode(3)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-boundAll" data-since="">
	<h2>
		<a href="#!Matreshka-boundAll">
			<span class="memberof">Matreshka#</span>boundAll<wbr>(<span class="args">key</span>)
				
		</a> <span class="returns">→ 
	<span data-type="$nodes">$nodes</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает коллекцию привязанных элементов</p></div>
	<div class="description"><p>После привязки свойств и HTML элементов, можно получить коллекцию этих элементов с помощью метода <code>boundAll</code>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="$nodes">$nodes</span>

		 - Привязанные элементы

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Ключ свойства (или список ключей, разделенных пробелами), чьи привязанные элементы мы хотим получить. Если аргумент не передан, вернется элемент, являющийся песочницей для экземпляра</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element');
this.boundAll('myKey'); // вернет $('.my-element')</code></pre><h5><p>Возврат песочницы (вместо этого, можно использовать свойство <a href="#!Matreshka-$sandbox">Matreshka#$sandbox</a>)</p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('sandbox', '.app');
this.boundAll(); // вернет $('.app')</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-boundAll" data-title="Метод Matreshka-boundAll">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-boundAll"
  title="Метод Matreshka-boundAll"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-$bound" data-since="">
	<h2>
		<a href="#!Matreshka-$bound">
			<span class="memberof">Matreshka#</span>$bound()
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Делает то же самое, что и <a href="#!Matreshka-boundAll">Matreshka#boundAll</a></p></div>
	<div class="description"></div>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.$bound('myKey');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-$bound" data-title="Метод Matreshka-$bound">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-$bound"
  title="Метод Matreshka-$bound"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-bound" data-since="">
	<h2>
		<a href="#!Matreshka-bound">
			<span class="memberof">Matreshka#</span>bound<wbr>(<span class="args">key</span>)
				
		</a> <span class="returns">→ 
	<span data-type="node">node</span>

	<span data-type="null">null</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает первый привязанный элемент или null</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="node">node</span>

	<span data-type="null">null</span>

		 - Привязанный элемент

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Ключ свойства (или список ключей, разделенных пробелами), чей привязанный элемент мы хотим получить. Если аргумент не передан, вернется элемент, являющийся песочницей для экземпляра</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element');
this.bound('mykey'); // вернет $('.my-element')[0]</code></pre><h5><p>Возврат песочницы (вместо этого, можно использовать свойство <a href="#!Matreshka-sandbox">Matreshka#sandbox</a>)</p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('sandbox', '.app');
this.bound(); // вернет $('.app')[0]</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-bound" data-title="Метод Matreshka-bound">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-bound"
  title="Метод Matreshka-bound"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-selectAll" data-since="">
	<h2>
		<a href="#!Matreshka-selectAll">
			<span class="memberof">Matreshka#</span>selectAll<wbr>(<span class="args">selector</span>)
				
		</a> <span class="returns">→ 
	<span data-type="$nodes">$nodes</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает элементы из песочницы, соответствующие селектору</p></div>
	<div class="description"><p>После создания песочницы методом <a href="#!Matreshka-bindNode">Matreshka#bindNode</a>, можно получать и использовать элементы, находящиеся в ней. Кроме этого, метод поддерживает  селектор <code>:bound(KEY)</code></p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="$nodes">$nodes</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						selector
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Cелектор</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('sandbox', '.app');
this.selectAll('.my-element');
// то же самое, что и
this.$bound().find('.my-element');
// и то же самое, что и
$('.app').find('.my-element');</code></pre><h5><p>Селектор <code>:bound(KEY)</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element');
this.selectAll(':bound(myKey) .my-another-element');
// то же самое, что и
this.$bound('myKey').find('.my-another-element');
// и то же самое, что и
$('.my-element').find('.my-another-element');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-selectAll" data-title="Метод Matreshka-selectAll">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-selectAll"
  title="Метод Matreshka-selectAll"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-$(instance)" data-since="">
	<h2>
		<a href="#!Matreshka-$(instance)">
			<span class="memberof">Matreshka#</span>$()
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Делает то же самое, что и <a href="#!Matreshka-selectAll">Matreshka#selectAll</a></p></div>
	<div class="description"></div>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.$('.my-element');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-$(instance)" data-title="Метод Matreshka-$(instance)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-$(instance)"
  title="Метод Matreshka-$(instance)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-select" data-since="">
	<h2>
		<a href="#!Matreshka-select">
			<span class="memberof">Matreshka#</span>select<wbr>(<span class="args">selector</span>)
				
		</a> <span class="returns">→ 
	<span data-type="node">node</span>

	<span data-type="null">null</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает элемент из песочницы, соответствующий селектору</p></div>
	<div class="description"><p>Метод очень похож на <a href="#!Matreshka-selectAll">Matreshka#selectAll</a>, но возвращает лишь один элемент или <code>null</code></p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="node">node</span>

	<span data-type="null">null</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						selector
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Селектор</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('sandbox', '.app');
this.select('.my-element');
// то же самое, что и
this.bound().querySelector('.my-element');
// и то же самое, что и
$('.app').find('.my-element')[0];</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-select" data-title="Метод Matreshka-select">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-select"
  title="Метод Matreshka-select"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-eq" data-since="0.0.2">
	<h2>
		<a href="#!Matreshka-eq">
			<span class="memberof">Matreshka#</span>eq<wbr>(<span class="args">object</span>)
				
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Проверяет экземпляр на равенство другому объекту</p></div>
	<div class="description"><p>Internet Explorer 8 бросает исключение при попытке традиционного сравнения на равенство, используя <code>==</code> или <code>===</code>. Метод <code>.eq</code> решает эту проблему. Если поддержка IE8 не нужна, то метод использовать не обязательно.</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						object
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект, с которым нужно сравнить экземпляр</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.eq(object); // true или false</code></pre><h5><p>Ошибка в IE8</p></h5>
<pre class="prettyprint source lang-js"><code>this === object; //иногда IE8 выкидывает "Class doesn't support Automation"</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-eq" data-title="Метод Matreshka-eq">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-eq"
  title="Метод Matreshka-eq"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-defineGetter" data-since="">
	<h2>
		<a href="#!Matreshka-defineGetter">
			<span class="memberof">Matreshka#</span>defineGetter<wbr>(<span class="args">key, getter</span>)
				
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает кастомный геттер для свойства</p></div>
	<div class="description"><p>Этот метод позволяет установить геттер (getter), используя нативный метод <code>Object.defineProperty</code> и работает во всех браузерах, начиная с Internet Explorer 8. Возвращаемое значение свойства вычисляется при каждом обращении к свойству, поэтому более предпочтительным методом, с точки зрения производительности, является <a href="#!Matreshka-linkProps">Matreshka#linkProps</a>.</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Ключ свойства, для которого устанавливается геттер</td>
				</tr>
			 
				<tr>
					<td>
						getter
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Функция-геттер</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.defineGetter('myKey', function() {
	return 42; // функция может возвращать любое вычисляемое значение
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-defineGetter" data-title="Метод Matreshka-defineGetter">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-defineGetter"
  title="Метод Matreshka-defineGetter"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-defineGetter(2)" data-since="">
	<h2>
		<a href="#!Matreshka-defineGetter(2)">
			<span class="memberof">Matreshka#</span>defineGetter<wbr>(<span class="args">keyGetterPairs</span>)
				
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис метода <a href="#!Matreshka-defineGetter">Matreshka#defineGetter</a> для установки геттера &quot;ключ-геттер&quot;</p></div>
	<div class="description"></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyGetterPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект со свойствами ключ-геттер</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.defineGetter({
	myKey1: function() { return 1; }
	myKey2: function() { return 2; }
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-defineGetter(2)" data-title="Метод Matreshka-defineGetter(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-defineGetter(2)"
  title="Метод Matreshka-defineGetter(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-defineSetter" data-since="">
	<h2>
		<a href="#!Matreshka-defineSetter">
			<span class="memberof">Matreshka#</span>defineSetter<wbr>(<span class="args">key, setter</span>)
				
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает кастомный сеттер для свойства</p></div>
	<div class="description"><p>Этот метод позволяет установить сеттер (setter), используя нативный метод <code>Object.defineProperty</code> и работает во всех браузерах, начиная с Internet Explorer 8. При использовании этого метода следует иметь в виду, что он переписывает встроенный Матрешкой сеттер и, таким образом убирает возможность отлова событий, типа <code>change:КЛЮЧ</code>. Используйте этот метод только если точно знаете, что делаете. Медоды <a href="#!Matreshka-on">Matreshka#on</a> и <a href="#!Matreshka-mediate">Matreshka#mediate</a> безопасны с точки зрения стабильности создаваемого приложения, лучше используйте их.</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Ключ, для которого требуется установить сеттер</td>
				</tr>
			 
				<tr>
					<td>
						setter
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Функция-сеттер</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.defineSetter('mykey', function(v) {
	alert(v);
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-defineSetter" data-title="Метод Matreshka-defineSetter">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-defineSetter"
  title="Метод Matreshka-defineSetter"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-defineSetter(2)" data-since="">
	<h2>
		<a href="#!Matreshka-defineSetter(2)">
			<span class="memberof">Matreshka#</span>defineSetter<wbr>(<span class="args">keySetterPairs</span>)
				
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис метода <a href="#!Matreshka-defineSetter">Matreshka#defineSetter</a> для установки сеттера &quot;ключ-сеттер&quot;</p></div>
	<div class="description"></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keySetterPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект со свойствами ключ-сеттер</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.defineSetter({
	myKey1: function(v) { alert(v); }
	myKey2: function(v) { alert(v); }
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-defineSetter(2)" data-title="Метод Matreshka-defineSetter(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-defineSetter(2)"
  title="Метод Matreshka-defineSetter(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-mediate" data-since="0.1">
	<h2>
		<a href="#!Matreshka-mediate">
			<span class="memberof">Matreshka#</span>mediate<wbr>(<span class="args">key, mediator</span>)
				
		</a> 
		
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Трансформирует значение свойства при его изменении</p></div>
	<div class="description"><p>Этот метод используется для преобразования значения свойства при его изменении. Например, вам нужно, чтоб значение свойства всегда было либо определенного типа, либо целым числом, либо быть не менее нуля и не более ста и т. д.</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> Ключ или массив ключей или список ключей, разделенных пробелами</td>
				</tr>
			 
				<tr>
					<td>
						mediator
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Функция-посредник (медиатор, mediator), возвращающая новое значение</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.mediate('x', function(value) {
	return String(value);
});
this.x = 1;
alert( typeof this.x ); // "string"</code></pre><h5><p>Список ключей, разделенных пробелами</p></h5>
<pre class="prettyprint source lang-js"><code>this.mediate('x y', function(value) {
	return String(value);
});</code></pre><h5><p>Массив ключей</p></h5>
<pre class="prettyprint source lang-js"><code>this.mediate(['x', 'y'], function(value) {
	return String(value);
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-mediate" data-title="Метод Matreshka-mediate">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-mediate"
  title="Метод Matreshka-mediate"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-mediate(2)" data-since="0.1">
	<h2>
		<a href="#!Matreshka-mediate(2)">
			<span class="memberof">Matreshka#</span>mediate<wbr>(<span class="args">keyMediatorPairs</span>)
				
		</a> 
		
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис метода <a href="#!Matreshka-mediate">Matreshka#mediate</a>, принимающий в качестве аргумента объект &quot;ключ-медиатор&quot;</p></div>
	<div class="description"></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyMediatorPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект со свойствами ключ-медиатор</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.mediate({
	x: String,
	y: Number,
	z: Boolean
});
this.x = 1;
this.y = 2;
this.z = 3;
alert(typeof this.x); // "string"
alert(typeof this.y); // "number"
alert(typeof this.z); // "boolean"</code></pre><h5><p>Список ключей, разделенных пробелами</p></h5>
<pre class="prettyprint source lang-js"><code>this.mediate({
	'u v': String,
	'w x': Number,
	'y z': Boolean
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-mediate(2)" data-title="Метод Matreshka-mediate(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-mediate(2)"
  title="Метод Matreshka-mediate(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-setClassFor" data-since="1.1">
	<h2>
		<a href="#!Matreshka-setClassFor">
			<span class="memberof">Matreshka#</span>setClassFor<wbr>(<span class="args">key, class, updateCallback</span>)
				
		</a> 
		
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает класс для свойства</p></div>
	<div class="description"><p>Метод позволяет строго указать на то, экземпляром какого класса будет заданное свойство. Разработчику не нужно беспокоиться о том, что значение свойства случайно перезапишется &quot;голыми&quot; данными.</p>
<blockquote>
<p>Метод является надстройкой над <a href="#!Matreshka-mediate">Matreshka#mediate</a> и переопределяет медиатор, исключая конфликт двух медиаторов.</p>
</blockquote>
<p>Экземпляр класса создается во время запуска метода <a href="#!Matreshka-setClassFor">Matreshka#setClassFor</a>. Первым аргументом конструктора класса становится текущее значение свойства. В конструкторе класса необходимо предусмотреть то, что в него попадет либо <code>undefined</code> (если свойство не содержало до этого никаких данных), либо объект, с которым нужно что-то сделать (например, расширить экземпляр класса свойствами объекта).</p>
<blockquote>
<p>На деле это выглядит просто: вы создаете обычный класс, который почти всегда принимает какие-нибудь данные, которые нужно обработать (например, использовать их в методе <a href="#!Matreshka.Object-jset">Matreshka.Object#jset</a>).</p>
</blockquote>
<p>При попытке присвоить свойству другое значение (объект или массив), внутренний механизм метода <code>setClassFor</code>, вместо присваивания, делает следующее:</p>
<ul>
<li>Если указана функция <code>updateCallback</code>, метод запускает его с двумя аргументами: текущим значением свойства и данными, которые код пытается присвоить.</li>
<li>Если заданный класс унаследован от <a href="#!Matreshka.Object">Matreshka.Object</a>, экземпляр обновляется новыми данными, используя метод <a href="#!Matreshka.Object-jset">Matreshka.Object#jset</a>.</li>
<li>Если заданный класс унаследован от <a href="#!Matreshka.Array">Matreshka.Array</a>, экземпляр обновляется новыми данными, используя метод <a href="#!Matreshka.Object-recreate">Matreshka.Object#recreate</a>.</li>
<li>Если не указана функция <code>updateCallback</code> и если класс не унаследован от <a href="#!Matreshka.Object">Matreshka.Object</a> или <a href="#!Matreshka.Array">Matreshka.Array</a>, экземпляр расширяется свойствами объекта, который код пытается присвоить.</li>
</ul>
<blockquote>
<p>Крутой особенностью функции является отсутствие ограничений на источник класса. В качестве класса может выступать любая функция-конструктор. которая инициализируется с помощью оператора <code>new</code>, а не только наследники <a href="#!Matreshka">Matreshka</a>.</p>
</blockquote></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> Ключ или массив ключей, или список ключей, разделенных пробелами</td>
				</tr>
			 
				<tr>
					<td>
						class
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Класс, который вы хотите установить свойству</td>
				</tr>
			 
				<tr>
					<td>
						updateCallback
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Функция, вызывающаяся при каждой попытке присвоить новые данные свойству, позволяющая кастомизировать логику обновления экземпляра класса новыми данными. Функция принимает два аргумента: текущее значение свойства (экземпляр класса) и данные, которые пытаются присвоить.</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var SubClass = Class({
	// ...
});

// ...

this.setClassFor('x', SubClass);

// пытаемся присвоить свойству другое значение
this.x = {a: 42};

// this.x по-прежнему экземпляр класса SubClass
alert(this.x instanceof SubClass); // true
alert(this.x.a); // 42</code></pre><h5><p>Использование <code>updateCallback</code>.</p></h5>
<pre class="prettyprint source lang-js"><code>this.setClassFor('x', SubClass, function(instance, data) {
	updateSomeHow(instance, data);
});</code></pre><h5><p>Получение родителя. Кроме данных (первый аргумент), в конструктор создаваемого класса, передается ссылка на объект, вызвавший <code>setClassFor</code></p></h5>
<pre class="prettyprint source lang-js"><code>var MySubClass = Class({
	'extends': Matreshka,
	constructor: function(data, parent) {
		// parent - это экземпляр MyClass,
		// вызвавший setClassFor
	}
});

var MyClass = Class({
	'extends': Matreshka,
	constructor: function() {
		this.setClassFor('x', MySubClass);
	}
});</code></pre><h5><p>Нестандартный способ использования <code>updateCallback</code> для игнорирования любых изменений свойства.</p></h5>
<pre class="prettyprint source lang-js"><code>// MK.noop - пустая функция
this.setClassFor('x', SubClass, MK.noop);</code></pre><h5><p>В случае, если ваш класс не подерживает использование оператора <code>new</code>, вместо <code>setClassFor</code> воспользуйтесь методом <a href="#!Matreshka-mediate">Matreshka#mediate</a>.</p></h5>
<pre class="prettyprint source lang-js"><code>this.mediate('x', function(data, currentValue) {
	return currentValue instanceof SomeClass
		? Object.assign(currentValue, data)
		: SomeLib.initInstance(SomeClass, data);
});</code></pre><h5><p>Абстрактный пример с данными большой вложенности (для краткости используется синтаксис ECMAScript 7)</p></h5>
<pre class="prettyprint source lang-js"><code>// app.js
class App extends MK {
	constructor(appData) {
		this.appData = appData;
		this.setClassFor('appData', AppData);
	}
}

// app-data.js
class AppData extends MK.Object {
	constructor(data) {
		super(data)
			.setClassFor({
				friends: Friends,
				settins: Settings
			});
	}
}

// friend.js
class Friend extends MK.Object {
	constructor(data) {
		super(data);
	}
}

// friends.js
class Friends extends MK.Array {
	Model = Friend;
	trackBy = 'id';
	constructor(data) {
		super(...data);
	}
}

// settings.js
class Settings extends MK.Object {
	constructor(data) {
		super(data)
			.setClassFor('credentials', Credentials);
	}
}

// credentials.js
class Credentials extends MK.Object {
	constructor(data) {
		super(data);
	}
}

// app-init.js
var app = new App({
	settings: {
		name: 'Vasiliy Vasiliev',
		credentials: {
			email: 'vasia.vasia@gmail.com'
		}
	},
	friends: [{
		name: 'Yulia Zuyeva',
		id: 1
	}, {
		name: 'Konstantin Konstantinopolsky',
		id: 2
	}, {
		name: 'nagibator3000',
		id: 3
	}]
});

// данные можно сериализировать и передать на сервер
JSON.stringify(app.appData);


// потом просто присвоить новые данные свойству appData
// при этом, структура классов не изменится
app.appData = {
	settings: {
		name: 'Petr Petrov',
		credentials: {
			email: 'petr.petrov@gmail.com'
		}
	},
	friends: [{
		name: 'Yulechka Zuyeva',
		id: 1
	}, {
		name: 'Konstantin Konstantinopolsky',
		id: 2
	}]
};</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-setClassFor" data-title="Метод Matreshka-setClassFor">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-setClassFor"
  title="Метод Matreshka-setClassFor"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-setClassFor(2)" data-since="1.1">
	<h2>
		<a href="#!Matreshka-setClassFor(2)">
			<span class="memberof">Matreshka#</span>setClassFor<wbr>(<span class="args">keyClassPairs, updateCallback</span>)
				
		</a> 
		
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис метода <a href="#!Matreshka-setClassFor">Matreshka#setClassFor</a>, принимающий в качестве аргумента объект &quot;ключ-класс&quot;</p></div>
	<div class="description"></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyClassPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект со свойствами ключ-класс</td>
				</tr>
			 
				<tr>
					<td>
						updateCallback
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Функция, вызывающаяся при каждой попытке присвоить новые данные свойству.</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.setClassFor({
	x: Class1,
	y: Class2,
	z: Class3
}, function(data) {
	instance.jset(data);
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-setClassFor(2)" data-title="Метод Matreshka-setClassFor(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-setClassFor(2)"
  title="Метод Matreshka-setClassFor(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-linkProps" data-since="0.1">
	<h2>
		<a href="#!Matreshka-linkProps">
			<span class="memberof">Matreshka#</span>linkProps<wbr>(<span class="args">keys1, keys2, handler<span class="default-value">=function(v){return v}</span>, setOnInit<span class="default-value">=true</span></span>)
				
		</a> 
		
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Создает зависимость значения одного свойства от значений других</p></div>
	<div class="description"><p>Метод <code>linkProps</code> создает зависимость значения свойства (первый аргумент) от значений других свойств (второй аргумент). Метод защищен от цикличных ссылок (например a зависит от b, b зависит от c, а c зависит от a) и при ошибке вычислений не блокирует страницу и не бросает исключение о переполнении стека.</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				<th>По&nbsp;умолчанию
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keys1
						
					</td>
					<td> 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> Свойство (свойства) которое зависит от других свойств</td>
				</tr>
			 
				<tr>
					<td>
						keys2
						
					</td>
					<td> 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> От каких свойств зависит искомое свойство (свойства)</td>
				</tr>
			 
				<tr>
					<td>
						handler
						
							<span class="signature">optional</span>
						
					</td>
					<td> function(v){return v}
					<td>
	<span data-type="function">function</span>
</td>
					<td> Функция, возвращающая новое значение</td>
				</tr>
			 
				<tr>
					<td>
						setOnInit
						
							<span class="signature">optional</span>
						
					</td>
					<td> true
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> Установить ли значение свойства сразу после объявления зависимости</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.linkProps('greeting', 'name', function() {
	return 'Hello, ' + this.name + '!';
});

this.name = 'Joe';

alert(this.greeting); // 'Hello, Joe!'</code></pre><h5><p>Сложный пример: вычисление периметра прямоугольника по двум сторонам (и сторон по периметру). Как видите, <code>linkProps</code> можно использовать и для решения математических задач, где каждый член уравнения можно использовать, как неизвестное</p></h5>
<pre class="prettyprint source lang-js"><code>this.a = 3;

this.b = 4;

this.linkProps('p', 'a b', function(a, b) {
	return (a + b) * 2;
});

this.linkProps('a', 'p b', function(p, b) {
	return p/2 - b;
});

this.linkProps('b', 'p a', function(p, a) {
	return p/2 - a;
});

alert(this.p); // 14

this.on('change:p', function() {
	alert('периметр изменен и равен ' + this.p);
});

this.a = 5; // alerts "периметр изменен и равен 18"</code></pre><h5><p>Начиная с версии 1.1, можно использовать путь к ключу во втором аргументе, вместо ключа</p></h5>
<pre class="prettyprint source lang-js"><code>this.a = {b: {c: 21}};

this.linkProps('x', 'a.b.c', function(c) {
	return c * 2;
});

alert(this.x); //42</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-linkProps" data-title="Метод Matreshka-linkProps">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-linkProps"
  title="Метод Matreshka-linkProps"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-linkProps(2)" data-since="0.2">
	<h2>
		<a href="#!Matreshka-linkProps(2)">
			<span class="memberof">Matreshka#</span>linkProps<wbr>(<span class="args">keys, instancesAndKeys, handler<span class="default-value">=function(v){return v}</span>, setOnInit<span class="default-value">=true</span></span>)
				
		</a> 
		
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Дополнительная возможность метода <a href="#!Matreshka-linkProps">Matreshka#linkProps</a>: зависимость от значений свойств других экземпляров</p></div>
	<div class="description"></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				<th>По&nbsp;умолчанию
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keys
						
					</td>
					<td> 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> Свойство (свойства) которое зависит от других свойств</td>
				</tr>
			 
				<tr>
					<td>
						instancesAndKeys
						
					</td>
					<td> 
					<td>
	<span data-type="array">array</span>
</td>
					<td> Массив, который содержит экземпляры (четные элементы) их ключи (нечетные элементы), от которых зависит искомое свойство (свойства). Такой, возможно, странный синтаксис является следствием ограничений синтаксиса JavaScript.</td>
				</tr>
			 
				<tr>
					<td>
						handler
						
							<span class="signature">optional</span>
						
					</td>
					<td> function(v){return v}
					<td>
	<span data-type="function">function</span>
</td>
					<td> Функция, возвращающая новое значение</td>
				</tr>
			 
				<tr>
					<td>
						setOnInit
						
							<span class="signature">optional</span>
						
					</td>
					<td> true
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> Установить ли значение свойства сразу после объявления зависимости</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5><p>Свойство <code>sum</code> является суммой свойств <code>a</code> и <code>b</code> других экземпляров и вычисляется каждый раз при их изменении</p></h5>
<pre class="prettyprint source lang-js"><code>anotherInstance1.a = 2;

anotherInstance2.b = 3;

this.linkProps('sum', [
	anotherInstance1, 'a',
	anotherInstance2, 'b'
], function(a, b) {
	return a + b;
});

alert(this.sum); // 5

this.on('change:sum', function() {
	alert('this.sum равен ' + this.sum);
});

anotherInstance1.a = 5; // "this.sum равен 8"</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-linkProps(2)" data-title="Метод Matreshka-linkProps(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-linkProps(2)"
  title="Метод Matreshka-linkProps(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-get" data-since="">
	<h2>
		<a href="#!Matreshka-get">
			<span class="memberof">Matreshka#</span>get<wbr>(<span class="args">key</span>)
				
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает значение свойства</p></div>
	<div class="description"></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>// то же самое, что и this['myKey'] или this.myKey
this.get('myKey');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-get" data-title="Метод Matreshka-get">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-get"
  title="Метод Matreshka-get"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-set" data-since="">
	<h2>
		<a href="#!Matreshka-set">
			<span class="memberof">Matreshka#</span>set<wbr>(<span class="args">key, value, eventOptions</span>)
				
		</a> 
		<i class="important" title="Важно"></i>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает значение свойства, позволяя передать объект события в качестве третьего аргумента</p></div>
	<div class="description"><p>Список поддерживаемых флагов:</p>
<ul>
<li><code>silent</code> - не вызывать события <code>change</code> и <code>change:KEY</code></li>
<li><code>silentHTML</code> - не менять состояние привязанных элементов</li>
<li><code>force</code> - вызвать события <code>change</code> и <code>change:KEY</code> даже если значение свойства не изменилось</li>
<li><code>forceHTML</code> - изменить состояние привязанного элемента, даже если значение свойства не изменилось. Эта опция нужна, если привязанный элемент был отрисован после привязки (например, в <code>select</code> были добавлены теги <code>option</code>)</li>
<li><code>skipMediator</code> - предотвращает трансформацию свойства медиатором (см. <a href="#!Matreshka-mediate">Matreshka#mediate</a>)</li>
<li><code>skipLinks</code> - предотвращает работу зависимостей, созданных с помощью <a href="#!Matreshka-linkProps">Matreshka#linkProps</a></li>
</ul></div>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">change</span> <span class="event">change:KEY</span> <span class="event">beforechange</span> <span class="event">beforechange:KEY</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Ключ</td>
				</tr>
			 
				<tr>
					<td>
						value
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> Значение</td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> Объект события</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// то же самое, что и this['myKey'] = 3
// или this.myKey = 3
// выводит на экран 3
this.set('myKey', 3);</code></pre><h5><p>Используя <code>eventOptions</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// alert не срабатывает
this.set('myKey', 4, {
	silent: true
});</code></pre><h5><p>Передача произвольных данных в обработчик</p></h5>
<pre class="prettyprint source lang-js"><code>this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.myCustomFlag);
});

// выводит на экран 42
this.set('myKey', 4, {
	myCustomFlag: 42
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-set" data-title="Метод Matreshka-set">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-set"
  title="Метод Matreshka-set"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-set(2)" data-since="">
	<h2>
		<a href="#!Matreshka-set(2)">
			<span class="memberof">Matreshka#</span>set<wbr>(<span class="args">keyValuePairs, eventOptions</span>)
				
		</a> 
		<i class="important" title="Важно"></i>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис метода <a href="#!Matreshka-set">Matreshka#set</a> &quot;ключ-значение&quot;</p></div>
	<div class="description"></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyValuePairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект, содержащий пары ключ-значение</td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> Объект события</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.set({
	myKey1: 1,
	myKey2: 2
});</code></pre><h5><p>Передача <code>eventOptions</code> в качестве второго аргумента</p></h5>
<pre class="prettyprint source lang-js"><code>this.set({
	myKey: 3
}, {
	myFlag: 'Jigurda'
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-set(2)" data-title="Метод Matreshka-set(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-set(2)"
  title="Метод Matreshka-set(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-remove" data-since="">
	<h2>
		<a href="#!Matreshka-remove">
			<span class="memberof">Matreshka#</span>remove<wbr>(<span class="args">key, eventOptions</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет свойство</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">delete</span> <span class="event">delete:KEY</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Ключ или ключи, разделенные пробелом</td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> Объект события</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.remove('myKey');
this.remove('myKey1 myKey2');</code></pre><h5><p>Использование <code>eventOptions</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.remove('myKey', {
	silent: true
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-remove" data-title="Метод Matreshka-remove">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-remove"
  title="Метод Matreshka-remove"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-define" data-since="">
	<h2>
		<a href="#!Matreshka-define">
			<span class="memberof">Matreshka#</span>define<wbr>(<span class="args">key, descriptor</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Полностью переписывает дескриптор свойства, используя <code>Object.defineProperty</code></p></div>
	<div class="description"><p>Обратите внимание, <code>Object.defineProperty</code> работает некорректно в Internet Explorer 8. Используйте метод только тогда, когда знаете, что делаете.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Ключ</td>
				</tr>
			 
				<tr>
					<td>
						descriptor
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Дескриптор</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5><p>Простой пример</p></h5>
<pre class="prettyprint source lang-js"><code>this.define( 'myKey', {
	get: function() { ... }
	set: function() { ... }
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-define" data-title="Метод Matreshka-define">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-define"
  title="Метод Matreshka-define"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-define(2)" data-since="">
	<h2>
		<a href="#!Matreshka-define(2)">
			<span class="memberof">Matreshka#</span>define<wbr>(<span class="args">keyObjectPairs</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис для метода <a href="#!Matreshka-define">Matreshka#define</a> &quot;ключ-дескриптор&quot;</p></div>
	<div class="description"><p>Работа метода очень похожа на <code>Object.defineProperties</code></p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyObjectPairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект, содержащий пары ключ-дескриптор</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.define({
	myKey1: {
		get: function() { ... }
		set: function() { ... }
	},
	myKey2: {
		get: function() { ... }
		set: function() { ... }
	}
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-define(2)" data-title="Метод Matreshka-define(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-define(2)"
  title="Метод Matreshka-define(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-delay" data-since="0.3">
	<h2>
		<a href="#!Matreshka-delay">
			<span class="memberof">Matreshka#</span>delay<wbr>(<span class="args">f, delay, thisArg</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Выполняет функцию после заданной задержки</p></div>
	<div class="description"><p>Работа метода очень похожа на <code>setTimеout</code>. В качестве контекста принимается текущий экземпляр или переданный объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						f
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Функция, которая должна быть выполнена после истечения таймера</td>
				</tr>
			 
				<tr>
					<td>
						delay
						
							<span class="signature">optional</span>
						
					</td>
					 0
					<td>
	<span data-type="number">number</span>
</td>
					<td> Задержка в миллисекундах</td>
				</tr>
			 
				<tr>
					<td>
						thisArg
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Контекст</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers.setTimeout" target="_blank">setTimeout на MDN</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on('change:x', function() {
	alert(this.x); // 1 ... 2
});

this.delay(function() {
	this.x = 2;
}, 100);

this.x = 1;</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-delay" data-title="Метод Matreshka-delay">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-delay"
  title="Метод Matreshka-delay"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-getAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything" data-since="0.4">
	<h2>
		<a href="#!Matreshka-getAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything">
			<span class="memberof">Matreshka#</span>getAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything()
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Выдаёт ответ на главный вопрос жизни, Вселенной и всего такого через 7.5 миллионов лет</p></div>
	<div class="description"></div>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.getAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-getAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything" data-title="Метод Matreshka-getAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-getAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything"
  title="Метод Matreshka-getAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka-parseBindings" data-since="1.1">
	<h2>
		<a href="#!Matreshka-parseBindings">
			<span class="memberof">Matreshka#</span>parseBindings<wbr>(<span class="args">node</span>)
				
		</a> <span class="returns">→ 
	<span data-type="$nodes">$nodes</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Парсит DOM дерево, объявляя привязки свойств, заключенных в двойные фигурные скобки.</p></div>
	<div class="description"><p>Начиная с версии 1.1, Матрешка включает в себя простой DOM парсер, обрабатывающий синтаксические конструкции, заключенные в двойные фигурные скобки. Метод <code>parseBindings</code> принимает один опциональный аргумент: HTML строку, DOM узел или селектор, соответствующий DOM узлу. Если аргумент не задан, парсер обрабатывает песочницу (см. <a href="#!Matreshka-bindNode">Matreshka#bindNode</a>).</p>
<p>Так как метод является DOM шаблонизатором (а не строковым HTML шаблонизатором), все дочерние DOM узлы переданного элемента остаются в своём прежнем состоянии (например, DOM события не затираются).</p>
<h4>Поддерживаемый синтаксис.</h4><ol>
<li><p>HTML привязка</p>
<pre class="prettyprint source lang-html"><code>&lt;!--
Создаст DOM узел на месте {{user.name}}
и свяжет свойство name из объекта user с этим узлом
JS: this.user = {name: 'Joe'}
-->
&lt;span>Hello, &#123;{user.name}}&lt;/span></code></pre></li>
<li><p>Привязка элементов форм.</p>
<pre class="prettyprint source lang-html"><code>&lt;!--
Свяжет свойство &quot;x&quot; экземпляра с текстовым
полем (двусторонняя привязка)
JS: this.x = 'some value';
-->
&lt;input type=&quot;text&quot; value=&quot;&#123;{x}}&quot;></code></pre></li>
</ol>
<pre class="prettyprint source lang-html"><code>&lt;!--
Для привязки textarea и select нужно использовать атрибут value
-->
&lt;textarea value=&quot;&#123;{x}}&quot;>&lt;/textarea>
&lt;select value=&quot;&#123;{x}}&quot;>...&lt;/select></code></pre><pre class="prettyprint source lang-html"><code>&lt;!--
Свяжет свойство &quot;x&quot; экземпляра с чекбоксом
(двусторонняя привязка)
JS: this.x = true;
-->
&lt;input type=&quot;checkbox&quot; checked=&quot;&#123;{x}}&quot;></code></pre><ol>
<li>Привязка атрибутов.<pre class="prettyprint source lang-html"><code>&lt;!--
Значение атрибута href будет зависеть
от значений свойств &quot;category&quot; и &quot;someObject.page&quot;
(односторонняя привязка)
JS:
 this.category = 'matreshka';
 this.someObject = {page: 42}
-->
&lt;a href=&quot;http://example.com/&#123;{category}}/&#123;{someObject.page}}&quot;>A link&lt;/a>
&lt;!--
Результат:
&lt;a href=&quot;http://example.com/matreshka/42&quot;>A link&lt;/a>
--></code></pre></li>
</ol>
<h4>Зачем нужен такой метод?</h4><p>В случае, если вы разрабатываете большую форму со стандартными HTML5 полями, метод поможет сохранить время на объявление многочисленных привязок. Кроме этого, <code>parseBindings</code> полезен в случае создания очень простой коллекции, не требующей реализации сложной <a href="#!Matreshka.Array-Model">модели</a>.</p>
<h4>Не противоречит ли это идеологии Матрешки (&quot;вся логика должна быть заключена в JavaScript файле&quot;)?</h4><p>Нет, в парсере не предусмотрено циклов, условных операторов и любой другой логики. Объявление простых привязок это всё, что доступно разработчику, использующему <code>parseBindings</code>.</p>
<h4>Производительность</h4><p>Метод работает несколько медленнее, чем объявление привязок вручную методом <a href="#!Matreshka-bindNode">Matreshka#bindNode</a>. Это нужно иметь в виду при создании приложения с очень серьезными требованиями к производительности. Скорость немного падает только во время процесса связывания. В остальном, привязки работают так же быстро, как и с <a href="#!Matreshka-bindNode">Matreshka#bindNode</a>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="$nodes">$nodes</span>

		 - Коллекция DOM узлов (как правило, состоящая из одного элемента), переданная в функцию в качестве аргумента или, если аргументов нет, песочница

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						node
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="node">node</span>

	<span data-type="$nodes">$nodes</span>
</td>
					<td> HTML строка, селектор, DOM узел или коллекция DOM узлов</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5><p>Парсинг заданного узла</p></h5>
<pre class="prettyprint source lang-js"><code>this.parseBindings(node);</code></pre><h5><p>Парсинг узла по селектору</p></h5>
<pre class="prettyprint source lang-js"><code>this.parseBindings('.my-node');</code></pre><h5><p>Парсинг HTML строки</p></h5>
<pre class="prettyprint source lang-js"><code>var $node = this.parseBindings('&lt;h3>Hello, &#123;{name}}&lt;/h3>');
this.name = 'Arthur Philip Dent';</code></pre><h5><p>Парсинг песочницы</p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('sandbox', '.my-node');
this.parseBindings();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka-parseBindings" data-title="Метод Matreshka-parseBindings">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka-parseBindings"
  title="Метод Matreshka-parseBindings"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

	
<article class="item property" id="!Matreshka.version" data-since="">
	<h2>
		<a href="#!Matreshka.version">

			<span class="memberof">Matreshka.</span>version</a><span class="type">:
				<span data-type="string">string</span>
			</span>

			<!-- <span data-type="string">string</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Версия Матрешки</p></div>
	<div class="description"></div>
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>alert(Matreshka.version);</code></pre>
	<a class="comments" data-id="Matreshka.version" data-title="Свойство Matreshka.version">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.version"
  title="Свойство Matreshka.version"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item property" id="!Matreshka.isXDR" data-since="">
	<h2>
		<a href="#!Matreshka.isXDR">

			<span class="memberof">Matreshka.</span>isXDR</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>

			<!-- <span data-type="boolean">boolean</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Использует ли Матрешка хак с XDomainRequest. Другими словами, является ли текущий браузер Internet Explorer 8</p></div>
	<div class="description"></div>
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>alert(Matreshka.isXDR);</code></pre>
	<a class="comments" data-id="Matreshka.isXDR" data-title="Свойство Matreshka.isXDR">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.isXDR"
  title="Свойство Matreshka.isXDR"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item property" id="!Matreshka.defaultBinders" data-since="">
	<h2>
		<a href="#!Matreshka.defaultBinders">

			<span class="memberof">Matreshka.</span>defaultBinders</a><span class="type">:
				<span data-type="array">array</span>
			</span>

			<!-- <span data-type="array">array</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Массив функций, возвращающих соответствующий байндер</p></div>
	<div class="description"><p><a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a> - массив функций, которые по очереди проверяют элемент на соответствие заданным в этих функциях правилам и возвращающих байндер (см. <span data-type="binder">binder</span>). Этот массив используется тогда, когда в метод <a href="#!Matreshka-bindNode">Matreshka#bindNode</a> не был передан третий аргумент. Подробную информацию о привязках смотрите в документации к <a href="#!Matreshka-bindNode">Matreshka#bindNode</a>.</p></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode">Matreshka#bindNode</a>
	
		<li><a href="#!Matreshka.lookForBinder">Matreshka.lookForBinder</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5><p>Кастомный чекбокс</p></h5>
<pre class="prettyprint source lang-js"><code>// добавляем байндер в коллекцию байндеров
MK.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $(this).hasClass('checked');
		},
		setValue: function( v ) {
			$(this).toggleClass('checked', !!v);
		},
		initialize: function() {
			$(this).toggleClass('checked');
		}
	}
};

// метод unshift добавляет функцию в начало массива Matreshka.defaultBinders
MK.defaultBinders.unshift( function( element ) {
	// проверяем, есть ли у элемента класс "custom-checkbox"
	if($(element).hasClass('custom-checkbox')) {
		// если проверка пройдена, возвращаем новый байндер
		return MK.binders.customCheckbox();
	}
});

// ...

this.bindNode('myKey', '.custom-checkbox');</code></pre>
	<a class="comments" data-id="Matreshka.defaultBinders" data-title="Свойство Matreshka.defaultBinders">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.defaultBinders"
  title="Свойство Matreshka.defaultBinders"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

	
<article class="item method" id="!Matreshka.extend" data-since="">
	<h2>
		<a href="#!Matreshka.extend">
			<span class="memberof">Matreshka.</span>extend<wbr>(<span class="args">o1, o2</span>)
				
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Небольшая вспомогательная функция, которая расширяет один объект свойствами другого объекта</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - o1

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						o1
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					 </td>
				</tr>
			 
				<tr>
					<td>
						o2
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var o1 = {a: 3},
	o2 = {b: 4};

MK.extend(o1, o2);</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.extend" data-title="Метод Matreshka.extend">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.extend"
  title="Метод Matreshka.extend"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Class" data-since="0.2">
	<h2>
		<a href="#!Matreshka.Class">
			<span class="memberof">Matreshka.</span>Class()
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Содержит ссылку на глобальную функцию <a href="#!Class">Class</a></p></div>
	<div class="description"><p>Такой способ применения функции Class употребляется тогда, когда разрабатываемое приложение использует <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank">AMD</a></p></div>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>MK.Class({
	method: function() {}
});

// то же самое, что и
Class({
	method: function() {}
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Class" data-title="Метод Matreshka.Class">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Class"
  title="Метод Matreshka.Class"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.$(static)" data-since="">
	<h2>
		<a href="#!Matreshka.$(static)">
			<span class="memberof">Matreshka.</span>$()
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Библиотека, используемая Матрешкой (jQuery, Zepto, <a href="#!Matreshka.$b">Balalaika</a> или др.)</p></div>
	<div class="description"></div>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>MK.$('.my-element');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.$(static)" data-title="Метод Matreshka.$(static)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.$(static)"
  title="Метод Matreshka.$(static)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.$b" data-since="">
	<h2>
		<a href="#!Matreshka.$b">
			<span class="memberof">Matreshka.</span>$b()
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Встроенная микро-библиотека <a href="#!$b">Балалайка</a></p></div>
	<div class="description"></div>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>MK.$b('.my-element');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.$b" data-title="Метод Matreshka.$b">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.$b"
  title="Метод Matreshka.$b"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.useAs$" data-since="0.2">
	<h2>
		<a href="#!Matreshka.useAs$">
			<span class="memberof">Matreshka.</span>useAs$<wbr>(<span class="args">$</span>)
				
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Заставляет использовать определенную библиотеку для работы с DOM</p></div>
	<div class="description"><p>По умолчанию, Матрешка использует в качестве библиотеки ту, которая находится по ссылке <code>window.$</code>. Если такой переменной нет в глобальном пространстве имен, либо же она не включает в себя необходимый набор методов, то используется встроенная микро библиотека <a href="#!$b">Балалайка</a>.</p>
<p>Метод <a href="#!Matreshka.useAs$">Matreshka.useAs$</a> заставляет Матрешку использовать ту библиотеку, которую вы захотите использовать, не смотря на отсутствие таковой в глобальном пространстве имен или по другой причине (например, если используется две разных версии jQuery на странице). Желательно, чтобы метод был запущен перед объявлением какого-либо класса, так как никакой конвертации в объект новой библиотеки не происходит.</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						$
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Любая библиотека (jQuery, Zepto, Balalaika или др.)</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>Matreshka.useAs$(jQuery.noConflict());</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.useAs$" data-title="Метод Matreshka.useAs$">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.useAs$"
  title="Метод Matreshka.useAs$"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.noop" data-since="">
	<h2>
		<a href="#!Matreshka.noop">
			<span class="memberof">Matreshka.</span>noop()
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Пустая функция, которая ничего не делает</p></div>
	<div class="description"></div>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.on('x', MK.noop);</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.noop" data-title="Метод Matreshka.noop">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.noop"
  title="Метод Matreshka.noop"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.each" data-since="">
	<h2>
		<a href="#!Matreshka.each">
			<span class="memberof">Matreshka.</span>each<wbr>(<span class="args">o, callback, thisArg</span>)
				
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Итерирует любой объект, прогоняя каждое его свойство через функцию <code>callback</code></p></div>
	<div class="description"><p>Этот статичный метод схож с работой <code>Array.prototype.forEach</code>.</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						o
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект</td>
				</tr>
			 
				<tr>
					<td>
						callback
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Функция, запускаемая на каждой итерации</td>
				</tr>
			 
				<tr>
					<td>
						thisArg
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> Объект, который используется в качестве ``this`` при вызове ``callback``</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var myObject = {
	a: 1,
	b: 2
};
MK.each(myObject, function(value, key) {
	// ...
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.each" data-title="Метод Matreshka.each">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.each"
  title="Метод Matreshka.each"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.debounce" data-since="0.3">
	<h2>
		<a href="#!Matreshka.debounce">
			<span class="memberof">Matreshka.</span>debounce<wbr>(<span class="args">f, duration, thisArg</span>)
				
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Запускает функцию лишь однажды после истечения таймера. С каждой попыткой запуска таймер обновляется</p></div>
	<div class="description"><p>Этот метод - реализация микропаттерна <strong>debounce</strong>, который решает проблему многократного вызова обработчика событий за определенный промежуток времени. См. пример и <a href="http://habrahabr.ru/post/60957/" target="_blank">статью на Хабре</a>.</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						f
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Оригинальная функция,</td>
				</tr>
			 
				<tr>
					<td>
						duration
						
							<span class="signature">optional</span>
						
					</td>
					 0
					<td>
	<span data-type="number">number</span>
</td>
					<td> Задержка</td>
				</tr>
			 
				<tr>
					<td>
						thisArg
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> Контекст, в котором функция должна быть запущена</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var debounced = MK.debounce(function(x) {
	console.log(x);
}, 10);

for(var i = 0; i &lt; 100; i++) {
	debounced(i);
}

// >>> 99</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.debounce" data-title="Метод Matreshka.debounce">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.debounce"
  title="Метод Matreshka.debounce"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.lookForBinder" data-since="">
	<h2>
		<a href="#!Matreshka.lookForBinder">
			<span class="memberof">Matreshka.</span>lookForBinder<wbr>(<span class="args">node</span>)
				
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"></div>
	<div class="description"><p>Возвращает байндер, соответствующий элементу. Если таковой не найден, возвращает <code>undefined</code>. Функция использует <a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - properties

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						node
						
					</td>
					 
					<td>
	<span data-type="node">node</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode">Matreshka#bindNode</a>
	
		<li><a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>console.log(Matreshka.lookForBinder($('input[type="text"]')[0]));

// вернет объект
{
	on: 'keyup paste',
	getValue: function() { return this.value; },
	setValue: function(v) {
		if( this.value != v ) {
			this.value = v;
		}
	}
}</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.lookForBinder" data-title="Метод Matreshka.lookForBinder">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.lookForBinder"
  title="Метод Matreshka.lookForBinder"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.randomString" data-since="">
	<h2>
		<a href="#!Matreshka.randomString">
			<span class="memberof">Matreshka.</span>randomString()
		</a> <span class="returns">→ 
	<span data-type="string">string</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Функция, которая возвращает уникальную псевдо-случайную строку</p></div>
	<div class="description"><p>Для генерации строки используются функции <code>new Date().getTime</code> и <code>Math.random()</code>, так что возвращаемая строка уникальна.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="string">string</span>

		 - случайная строка

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var id = MK.randomString();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.randomString" data-title="Метод Matreshka.randomString">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.randomString"
  title="Метод Matreshka.randomString"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.to" data-since="1.1">
	<h2>
		<a href="#!Matreshka.to">
			<span class="memberof">Matreshka.</span>to()
		</a> <span class="returns">→ 
	<span data-type="matreshka">matreshka</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Функция, конвертирующая произвольную структуру объектов и массивов в экземпляры <a href="#!Matreshka.Object">Matreshka.Object</a> и <a href="#!Matreshka.Array">Matreshka.Array</a></p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshka">matreshka</span>

		 - новосозданный экземпляр Матрешки

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mk = MK.to({
	a: 1,
	b: {
		c: 2
	},
	d: [{e: 1}, {e: 2}, {e: 3}]
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.to" data-title="Метод Matreshka.to">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.to"
  title="Метод Matreshka.to"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.on" data-since="1.1">
	<h2>
		<a href="#!Matreshka.on">
			<span class="memberof">Matreshka.</span>on()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Добавляет обработчик события</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-on">Matreshka#on</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-on">Matreshka#on</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.on(object, 'foo', function(evt) {
	alert(evt.hello);
});

MK.trigger(object, 'foo', {hello: 'World'});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.on" data-title="Метод Matreshka.on">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.on"
  title="Метод Matreshka.on"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.once" data-since="1.1">
	<h2>
		<a href="#!Matreshka.once">
			<span class="memberof">Matreshka.</span>once()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Добавляет обработчик событий, который может быть вызван однажды</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-once">Matreshka#once</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-once">Matreshka#once</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.once(object, 'foo', function(evt) {
	//...
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.once" data-title="Метод Matreshka.once">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.once"
  title="Метод Matreshka.once"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.onDebounce" data-since="1.1">
	<h2>
		<a href="#!Matreshka.onDebounce">
			<span class="memberof">Matreshka.</span>onDebounce()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Добавляет обработчик события, вызываемый лишь однажды за определенный промежуток времени</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-onDebounce">Matreshka#onDebounce</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-onDebounce">Matreshka#onDebounce</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.onDebounce(object, 'foo', function(evt) {
	//...
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.onDebounce" data-title="Метод Matreshka.onDebounce">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.onDebounce"
  title="Метод Matreshka.onDebounce"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.trigger" data-since="1.1">
	<h2>
		<a href="#!Matreshka.trigger">
			<span class="memberof">Matreshka.</span>trigger()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Генерирует событие</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-trigger">Matreshka#trigger</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-trigger">Matreshka#trigger</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.on(object, 'foo', function(evt) {
	alert(evt.hello);
});

MK.trigger(object, 'foo', {hello: 'World'});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.trigger" data-title="Метод Matreshka.trigger">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.trigger"
  title="Метод Matreshka.trigger"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.off" data-since="1.1">
	<h2>
		<a href="#!Matreshka.off">
			<span class="memberof">Matreshka.</span>off()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет обработчик события</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-off">Matreshka#off</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-off">Matreshka#off</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.on(object, 'foo', function(evt) {
	//...
});

MK.off(object, 'foo');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.off" data-title="Метод Matreshka.off">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.off"
  title="Метод Matreshka.off"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.mediate" data-since="1.1">
	<h2>
		<a href="#!Matreshka.mediate">
			<span class="memberof">Matreshka.</span>mediate()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Трансформирует значение свойства при его изменении</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-mediate">Matreshka#mediate</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-mediate">Matreshka#mediate</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.mediate(object, 'x', String);
object.x = 42;
alert(typeof object.x); // string</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.mediate" data-title="Метод Matreshka.mediate">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.mediate"
  title="Метод Matreshka.mediate"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.setClassFor" data-since="1.1">
	<h2>
		<a href="#!Matreshka.setClassFor">
			<span class="memberof">Matreshka.</span>setClassFor()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает класс для свойства</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-setClassFor">Matreshka#setClassFor</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-setClassFor">Matreshka#setClassFor</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.setClassFor(object, 'x', SomeClass);
object.x = {a: 42};
alert(this.x instanceof SubClass); // true
alert(this.x.a); // 42</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.setClassFor" data-title="Метод Matreshka.setClassFor">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.setClassFor"
  title="Метод Matreshka.setClassFor"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.linkProps" data-since="1.1">
	<h2>
		<a href="#!Matreshka.linkProps">
			<span class="memberof">Matreshka.</span>linkProps()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Создает зависимость значения одного свойства от значений других</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-linkProps">Matreshka#linkProps</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-linkProps">Matreshka#linkProps</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.linkProps(object, 'sum', 'a b' function(a, b) {
	return a + b;
});
object.a = 40;
object.b = 2;
alert(object.sum); // 42</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.linkProps" data-title="Метод Matreshka.linkProps">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.linkProps"
  title="Метод Matreshka.linkProps"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.bindNode" data-since="1.1">
	<h2>
		<a href="#!Matreshka.bindNode">
			<span class="memberof">Matreshka.</span>bindNode()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Связывает свойство объекта с HTML элементом</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-bindNode">Matreshka#bindNode</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode">Matreshka#bindNode</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.bindNode(object, 'x', '.my-node');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.bindNode" data-title="Метод Matreshka.bindNode">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.bindNode"
  title="Метод Matreshka.bindNode"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.bindOptionalNode" data-since="1.1">
	<h2>
		<a href="#!Matreshka.bindOptionalNode">
			<span class="memberof">Matreshka.</span>bindOptionalNode()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Работает в точности так же, как и <a href="#!Matreshka-bindNode">Matreshka#bindNode</a> но не бросает исключение, если аргумент node - пустой массив, undefined или не существует</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-bindOptionalNode">Matreshka#bindOptionalNode</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindOptionalNode">Matreshka#bindOptionalNode</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.bindOptionalNode(object, 'x', '.my-node');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.bindOptionalNode" data-title="Метод Matreshka.bindOptionalNode">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.bindOptionalNode"
  title="Метод Matreshka.bindOptionalNode"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.unbindNode" data-since="1.1">
	<h2>
		<a href="#!Matreshka.unbindNode">
			<span class="memberof">Matreshka.</span>unbindNode()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Разрывает связь между свойством и HTML элементом</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-unbindNode">Matreshka#unbindNode</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-unbindNode">Matreshka#unbindNode</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.unbindNode(object, 'x', '.my-node');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.unbindNode" data-title="Метод Matreshka.unbindNode">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.unbindNode"
  title="Метод Matreshka.unbindNode"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.select" data-since="1.1">
	<h2>
		<a href="#!Matreshka.select">
			<span class="memberof">Matreshka.</span>select()
		</a> <span class="returns">→ 
	<span data-type="node">node</span>

	<span data-type="null">null</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает элемент из песочницы, соответствующий селектору</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-select">Matreshka#select</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="node">node</span>

	<span data-type="null">null</span>

		

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-select">Matreshka#select</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.bindNode(object, 'sandbox', '.app');
MK.select(object, '.my-element');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.select" data-title="Метод Matreshka.select">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.select"
  title="Метод Matreshka.select"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.selectAll" data-since="1.1">
	<h2>
		<a href="#!Matreshka.selectAll">
			<span class="memberof">Matreshka.</span>selectAll()
		</a> <span class="returns">→ 
	<span data-type="$nodes">$nodes</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает элементы из песочницы, соответствующие селектору</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-selectAll">Matreshka#selectAll</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="$nodes">$nodes</span>

		

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-selectAll">Matreshka#selectAll</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.bindNode(object, 'sandbox', '.app');
MK.selectAll(object, '.my-element');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.selectAll" data-title="Метод Matreshka.selectAll">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.selectAll"
  title="Метод Matreshka.selectAll"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.bound" data-since="1.1">
	<h2>
		<a href="#!Matreshka.bound">
			<span class="memberof">Matreshka.</span>bound()
		</a> <span class="returns">→ 
	<span data-type="node">node</span>

	<span data-type="null">null</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает первый привязанный элемент или null</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-bound">Matreshka#bound</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="node">node</span>

	<span data-type="null">null</span>

		 - Привязаннй элемент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bound">Matreshka#bound</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {},
	bound;
MK.bindNode(object, 'x', '.my-node');
bound = MK.bound(object, 'x');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.bound" data-title="Метод Matreshka.bound">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.bound"
  title="Метод Matreshka.bound"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.boundAll" data-since="1.1">
	<h2>
		<a href="#!Matreshka.boundAll">
			<span class="memberof">Matreshka.</span>boundAll()
		</a> <span class="returns">→ 
	<span data-type="$nodes">$nodes</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает коллекцию привязанных элементов</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-boundAll">Matreshka#boundAll</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="$nodes">$nodes</span>

		 - Привязанные элементы

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-boundAll">Matreshka#boundAll</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {},
	bound;
MK.bindNode(object, 'x', '.my-node');
bound = MK.boundAll(object, 'x');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.boundAll" data-title="Метод Matreshka.boundAll">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.boundAll"
  title="Метод Matreshka.boundAll"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.$bound" data-since="1.1">
	<h2>
		<a href="#!Matreshka.$bound">
			<span class="memberof">Matreshka.</span>$bound()
		</a> <span class="returns">→ 
	<span data-type="$nodes">$nodes</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает коллекцию привязанных элементов</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-$bound">Matreshka#$bound</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="$nodes">$nodes</span>

		 - Привязанные элементы

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-$bound">Matreshka#$bound</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {},
	bound;
MK.bindNode(object, 'x', '.my-node');
bound = MK.$bound(object, 'x');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.$bound" data-title="Метод Matreshka.$bound">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.$bound"
  title="Метод Matreshka.$bound"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.get" data-since="1.1">
	<h2>
		<a href="#!Matreshka.get">
			<span class="memberof">Matreshka.</span>get()
		</a> <span class="returns">→ 
	<span data-type="*">*</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает значение свойства</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-get">Matreshka#get</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="*">*</span>

		 - Значение свойства

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-get">Matreshka#get</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {},
	val = MK.get(object, 'x');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.get" data-title="Метод Matreshka.get">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.get"
  title="Метод Matreshka.get"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.set" data-since="1.1">
	<h2>
		<a href="#!Matreshka.set">
			<span class="memberof">Matreshka.</span>set()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает значение свойства, позволяя передать объект события в качестве третьего аргумента</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-set">Matreshka#set</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-set">Matreshka#set</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.set(object, 'x', 42, {
	someOption: true
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.set" data-title="Метод Matreshka.set">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.set"
  title="Метод Matreshka.set"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.remove" data-since="1.1">
	<h2>
		<a href="#!Matreshka.remove">
			<span class="memberof">Matreshka.</span>remove()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет свойство</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-remove">Matreshka#remove</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-remove">Matreshka#remove</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>MK.remove(object, 'x');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.remove" data-title="Метод Matreshka.remove">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.remove"
  title="Метод Matreshka.remove"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.define" data-since="1.1">
	<h2>
		<a href="#!Matreshka.define">
			<span class="memberof">Matreshka.</span>define()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Полностью переписывает дескриптор свойства, используя <code>Object.defineProperty</code></p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-define">Matreshka#define</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-define">Matreshka#define</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.define(object, 'myKey', {
	get: function() { ... }
	set: function() { ... }
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.define" data-title="Метод Matreshka.define">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.define"
  title="Метод Matreshka.define"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.defineGetter" data-since="1.1">
	<h2>
		<a href="#!Matreshka.defineGetter">
			<span class="memberof">Matreshka.</span>defineGetter()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает кастомный геттер для свойства</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-defineGetter">Matreshka#defineGetter</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-defineGetter">Matreshka#defineGetter</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.defineGetter(object, 'myKey', function() {
	return 42;
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.defineGetter" data-title="Метод Matreshka.defineGetter">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.defineGetter"
  title="Метод Matreshka.defineGetter"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.defineSetter" data-since="1.1">
	<h2>
		<a href="#!Matreshka.defineSetter">
			<span class="memberof">Matreshka.</span>defineSetter()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает кастомный сеттер для свойства</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-defineSetter">Matreshka#defineSetter</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		 - Первый аргумент

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-defineSetter">Matreshka#defineSetter</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
MK.defineSetter(object, 'myKey', function() {
	alert('setter is running');
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.defineSetter" data-title="Метод Matreshka.defineSetter">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.defineSetter"
  title="Метод Matreshka.defineSetter"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.parseBindings" data-since="1.1">
	<h2>
		<a href="#!Matreshka.parseBindings">
			<span class="memberof">Matreshka.</span>parseBindings()
		</a> <span class="returns">→ 
	<span data-type="$nodes">$nodes</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Парсит DOM дерево, объявляя привязки свойств, заключенных в двойные фигурные скобки.</p></div>
	<div class="description"><p>Этот статичный метод работает так же, как и <a href="#!Matreshka-parseBindings">Matreshka#parseBindings</a> и все его вариации, но принимает в качестве первого аргумента любой JavaScript объект.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="$nodes">$nodes</span>

		 - Коллекция DOM узлов (как правило, состоящая из одного элемента), переданная в функцию в качестве аргумента или, если аргументов нет, песочница

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-parseBindings">Matreshka#parseBindings</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {};
var $node = MK.parseBindings(object, '&lt;h3>Hello, &#123;{name}}&lt;/h3>');
object.name = 'Arthur Philip Dent';</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.parseBindings" data-title="Метод Matreshka.parseBindings">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.parseBindings"
  title="Метод Matreshka.parseBindings"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.trim" data-since="1.1">
	<h2>
		<a href="#!Matreshka.trim">
			<span class="memberof">Matreshka.</span>trim<wbr>(<span class="args">string</span>)
				
		</a> <span class="returns">→ 
	<span data-type="string">string</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет пробелы из начала и конца строки</p></div>
	<div class="description"><p>Метод может быть полезен в том случае, если браузер не поддерживает <code>String.prototype.trim</code>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="string">string</span>

		 - Результат

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						string
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Строка</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>console.log(MK.trim('   hello world  ')); // "hello world"</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.trim" data-title="Метод Matreshka.trim">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.trim"
  title="Метод Matreshka.trim"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.toArray" data-since="1.1">
	<h2>
		<a href="#!Matreshka.toArray">
			<span class="memberof">Matreshka.</span>toArray<wbr>(<span class="args">arr</span>)
				
		</a> <span class="returns">→ 
	<span data-type="array">array</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Конвертирует любой array-like объект в обычный массив.</p></div>
	<div class="description"><p>Функция работает в два раза быстрее, чем <code>Array.prototype.slice</code>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="array">array</span>

		 - Новый массив

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						arr
						
					</td>
					 
					<td>
	<span data-type="object">object</span>

	<span data-type="array">array</span>
</td>
					<td> Любой array-like объект</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var object = {
	0: 'a',
	1: 'b',
	2: 'c',
	length: 3
};

console.log(MK.toArray(object)); // ['a', 'b', 'c']</code></pre><h5><p>Клонирование масива</p></h5>
<pre class="prettyprint source lang-js"><code>var arr = ['a', 'b', 'c'],
	cloneArr = MK.toArray(arr);</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.toArray" data-title="Метод Matreshka.toArray">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.toArray"
  title="Метод Matreshka.toArray"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

	<article class="item ns" id="!Matreshka.binders">
	<h2>
		<a href="#!Matreshka.binders">
			<span class="memberof">Matreshka.</span>binders <span data-type="object">object</span>
		</a>
	</h2>
	<div class="summary"></div>
	<div class="description"><p>Пространство имен для байндеров. Этот объект можно расширять собственными свойствами, чтоб не засорять глобальное пространство имен.</p>
<p>Примите во внимание небольшое соглашение: каждое свойство из коллекции <code>Matreshka.binders</code> должно быть оформлено в виде функции, возвращающей байндер.</p></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode">Matreshka#bindNode</a>
	
		<li><a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>MK.binders.myCoolBinder = function(var1, var2) {
	return {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... },
		initialize: function() { ... }
	};
};

this.bindNode('myKey', '.my-element',
	MK.binders.myCoolBinder('Hello', 'World'));</code></pre>


	<a class="comments" data-id="Matreshka.binders" data-title="Пространство имен Matreshka.binders">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders"
  title="Пространство имен Matreshka.binders"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.html" data-since="0.1">
	<h2>
		<a href="#!Matreshka.binders.html">
			<span class="memberof">Matreshka.binders.</span>html()
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик, меняющий <code>innerHTML</code> DOM элемента в зависимости от значения свойства экземпляра класса</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element', MK.binders.html());</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.html" data-title="Метод Matreshka.binders.html">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.html"
  title="Метод Matreshka.binders.html"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.visibility" data-since="0.1">
	<h2>
		<a href="#!Matreshka.binders.visibility">
			<span class="memberof">Matreshka.binders.</span>visibility<wbr>(<span class="args">value<span class="default-value">=true</span></span>)
				
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает односторонний привязчик, меняющий видимость DOM элемент (используя <code>style.display</code>), в зависимости от значения свойства экземпляра класса</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				<th>По&nbsp;умолчанию
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						value
						
							<span class="signature">optional</span>
						
					</td>
					<td> true
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> Если аргумент равен ``true``, то элемент прячется при ложном значении свойства, если равен ``false``, прячется при правдивом значении</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element', MK.binders.visibility(true));</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element', MK.binders.visibility(false));</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.visibility" data-title="Метод Matreshka.binders.visibility">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.visibility"
  title="Метод Matreshka.binders.visibility"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.className" data-since="0.1">
	<h2>
		<a href="#!Matreshka.binders.className">
			<span class="memberof">Matreshka.binders.</span>className<wbr>(<span class="args">className</span>)
				
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик, который переключает имя класса DOM элемента в зависимости от значения свойства экземпляра класса. Если значение свойства нестрого равно <code>true</code>, имя класса добавляется, в противном случае - убирается. Логику можно изменить, добавив восклицательный знак перед именем класса, и, таким образом, имя класса будет добавляться, когда значение свойства нестрого равно <code>false</code> и наоборот.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						className
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element', MK.binders.className('blah'));

this.myKey = true; // добавляет класс 'blah'

this.myKey = false; // убирает класс 'blah'</code></pre><h5><p>Использование восклицательного знака перед именем класса</p></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-element', MK.binders.className('!blah'));

this.myKey = false; // добавляет класс 'blah'

this.myKey = true; // убирает класс 'blah'</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.className" data-title="Метод Matreshka.binders.className">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.className"
  title="Метод Matreshka.binders.className"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.prop" data-since="0.3">
	<h2>
		<a href="#!Matreshka.binders.prop">
			<span class="memberof">Matreshka.binders.</span>prop<wbr>(<span class="args">property</span>)
				
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик, меняющий свойство DOM элемента на значение свойства экземпляра класса</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						property
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('disabled', '.my-button', MK.binders.prop('disabled'));

// устанавливает свойство disabled = true для элемента
this.disabled = true;

// устанавливает свойство disabled = false для элемента
this.disabled = false;</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.prop" data-title="Метод Matreshka.binders.prop">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.prop"
  title="Метод Matreshka.binders.prop"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.attr" data-since="0.3">
	<h2>
		<a href="#!Matreshka.binders.attr">
			<span class="memberof">Matreshka.binders.</span>attr<wbr>(<span class="args">attribute</span>)
				
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик, меняющий атрибут DOM элемента на значение свойства экземпляра класса</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						attribute
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('image', 'img.my-image', MK.binders.attr('src'));

this.image = 'http://example.com/cats.jpg';</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.attr" data-title="Метод Matreshka.binders.attr">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.attr"
  title="Метод Matreshka.binders.attr"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.input" data-since="0.3">
	<h2>
		<a href="#!Matreshka.binders.input">
			<span class="memberof">Matreshka.binders.</span>input<wbr>(<span class="args">type</span>)
				
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик, связывающий свойство экземпляра класса с элементом <code>input</code>. Напрямую привязчик использовать не обязательно, так как он входит в список <a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a>.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						type
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Тип инпута</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-input', MK.binders.input('range'));</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.input" data-title="Метод Matreshka.binders.input">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.input"
  title="Метод Matreshka.binders.input"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.textarea" data-since="0.3">
	<h2>
		<a href="#!Matreshka.binders.textarea">
			<span class="memberof">Matreshka.binders.</span>textarea()
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик, связывающий свойство экземпляра с элементом <code>textarea</code>. Напрямую привязчик использовать не обязательно, так как он входит в список <a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a>.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-textarea', MK.binders.textarea());</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.textarea" data-title="Метод Matreshka.binders.textarea">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.textarea"
  title="Метод Matreshka.binders.textarea"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.select" data-since="0.3">
	<h2>
		<a href="#!Matreshka.binders.select">
			<span class="memberof">Matreshka.binders.</span>select<wbr>(<span class="args">multiple</span>)
				
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик, связывающий свойство экземпляра с элементом <code>select</code>. Напрямую привязчик использовать не обязательно, так как он входит в список <a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a>.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						multiple
						
							<span class="signature">optional</span>
						
					</td>
					 false
					<td>
	<span data-type="boolean">boolean</span>
</td>
					<td> Является ли селект ``multiple``</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-select', MK.binders.select(true));</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.select" data-title="Метод Matreshka.binders.select">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.select"
  title="Метод Matreshka.binders.select"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.progress" data-since="1.1">
	<h2>
		<a href="#!Matreshka.binders.progress">
			<span class="memberof">Matreshka.binders.</span>progress()
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик, связывающий свойство с экземпляра с элементом <code>progress</code>. Напрямую привязчик использовать не обязательно, так как он входит в список <a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a>.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-progress', MK.binders.progress());</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.progress" data-title="Метод Matreshka.binders.progress">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.progress"
  title="Метод Matreshka.binders.progress"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.text" data-since="1.1">
	<h2>
		<a href="#!Matreshka.binders.text">
			<span class="memberof">Matreshka.binders.</span>text()
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик, меняющий <code>textContent</code> (текстовое содержимое) DOM элемента в зависимости от значения свойства экземпляра класса.</p></div>
	<div class="description"><p><a href="#!Matreshka.binders.text">Matreshka.binders.text</a> позволяет вывести содержимое свойства как есть и немного улучшает производительность из-за отсутствия необходимости браузеру парсить HTML.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-node', MK.binders.text());</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.text" data-title="Метод Matreshka.binders.text">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.text"
  title="Метод Matreshka.binders.text"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.style" data-since="1.1">
	<h2>
		<a href="#!Matreshka.binders.style">
			<span class="memberof">Matreshka.binders.</span>style<wbr>(<span class="args">property</span>)
				
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик, меняющий заданное свойство стиля DOM элемента в зависимости от значения свойства экземпляра класса.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						property
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Свойство ``style`` (camel-cased)</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-node', MK.binders.style('backgroundColor'));
this.myKey = 'red'; // цвет фона ``.my-node`` стал красным</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.style" data-title="Метод Matreshka.binders.style">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.style"
  title="Метод Matreshka.binders.style"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.dataset" data-since="1.1">
	<h2>
		<a href="#!Matreshka.binders.dataset">
			<span class="memberof">Matreshka.binders.</span>dataset<wbr>(<span class="args">property</span>)
				
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик, меняющий заданное свойство объекта <a href="https://developer.mozilla.org/ru/docs/Web/API/HTMLElement/dataset">dataset</a> DOM элемента в зависимости от значения свойства экземпляра класса.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						property
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Свойство dataset</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-node', MK.binders.dataset('myProp'));
this.myKey = 'cool value';</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.dataset" data-title="Метод Matreshka.binders.dataset">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.dataset"
  title="Метод Matreshka.binders.dataset"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.binders.file" data-since="1.1">
	<h2>
		<a href="#!Matreshka.binders.file">
			<span class="memberof">Matreshka.binders.</span>file<wbr>(<span class="args">readAs</span>)
				
		</a> <span class="returns">→ 
	<span data-type="binder">binder</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает привязчик для <code>input[type=&quot;file&quot;]</code>.</p></div>
	<div class="description"><p>Байндер позволяет не только получить основные данные о файле, но и считать его, не вызывая <code>FileReader</code> вручную.</p>
<p>Если аргумент <code>readAs</code> не задан, то в привязанное свойство попадает значение инпута после его изменения (по событию <code>change</code>). Если <code>readAs</code> задан, то байндер считает файл и преобразует в необходимый формат (data URI, Blob...) и только после прочтения файла свойство изменится.</p>
<p>Результирующим значением свойства становится файл (нативный <code>File</code>) или массив файлов при наличии атрибута <code>multiple</code>. При этом, результат чтения попадет в объект каждого файла в виде свойства <code>readerResult</code>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="binder">binder</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						readAs
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Значением аргумента ``readAs`` могут быть ``"arrayBufer"``, ``"binaryString"``, ``"dataURL"``, ``"text"``. Значение зависит от наличия соответствующих методов в интерфейсе ``FileReader``</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="https://developer.mozilla.org/en/docs/Web/API/FileReader" target="_blank">FileReader</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.bindNode('myKey', '.my-file', MK.binders.file('dataURL'));
// ... пользователь меняет содержимое инпута,
// выбирая my-image.png из файловой системы ...
this.on('change:myKey', function() {
	console.log(this.myKey);
	// -->
	// File
	//	lastModified: 1383404384000
	//	lastModifiedDate: ...
	//	name: "my-image.png"
	//	readerResult: "data:image/png;base64,iVBO..."
	//	- результат считывания файла
	//	size: 9378
	//	type: "image/png"
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.binders.file" data-title="Метод Matreshka.binders.file">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.binders.file"
  title="Метод Matreshka.binders.file"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>


</section>


	<section>
	<article class="item class" id="!Matreshka.Object">
		<h2>
			<a href="#!Matreshka.Object">
				<span class="signature-class">Класс</span> Matreshka.Object
			</a>
			<i class="important" title="Важно"></i>
		</h2>
		<div class="description">
			<p><code>Matreshka.Object</code> - класс, который отвечает за данные вида пар ключ-значение. Его задачей является отделение служебных свойств от данных, которые можно передать на сервер или сохранить в локальном хранилище. Класс наследуется от класса <a href="#!Matreshka">Matreshka</a> и включает все его свойства и методы.</p>
<p>Представьте себе, что вы создаёте класс, включающий свойства <code>&quot;a&quot;</code>, <code>&quot;b&quot;</code> и <code>&quot;c&quot;</code>. Допустим <code>&quot;a&quot;</code> и <code>&quot;b&quot;</code> - свойства которые должны быть отправлены на сервер, а свойство <code>&quot;c&quot;</code> лишь отвечает за некоторое состояние приложения (например, содержит сумму <code>&quot;a&quot;</code> и <code>&quot;b&quot;</code>). Свойство <code>&quot;c&quot;</code> не нужно серверу. Поэтому нам нужно отделить <strong>свойства отвечающие за данные</strong> от свойств, которые таковыми не являются.</p>
<p>Для того, чтоб объявить такие свойства от остальных, можно воспользоваться методом <a href="#!Matreshka.Object-addDataKeys">Matreshka.Object#addDataKeys</a>.</p>
<pre class="prettyprint source lang-js"><code>this.addDataKeys('a b');

this.a = 1;
this.b = 2;
this.c = 3;</code></pre><p>Если вы заранее не знаете, какие свойства являются данными, можно всегда использовать метод <a href="#!Matreshka.Object-jset">Matreshka.Object#jset</a>, который не только объявляет свойства, отвечающие за данные, но и сразу устанавливает значения.</p>
<pre class="prettyprint source lang-js"><code>this.jset({
    a: 1,
    b: 2
});

this.c = 3;</code></pre><p>После того, как приложение &quot;узнало&quot; о том, что является данными, экземпляр <a href="#!Matreshka.Object">Matreshka.Object</a> можно сконвертировать в обычный объект методом <a href="#!Matreshka.Object-toJSON">Matreshka.Object#toJSON</a> и передать на сервер или сохранить в локальной БД (например, в <code>localStorage</code>).</p>
<pre class="prettyprint source lang-js"><code>// вернет объект {a: 1, b: 2}
this.toJSON();</code></pre><p>При изменении свойств, отвечающих за данные генерируется событие <code>modify</code></p>
<pre class="prettyprint source lang-js"><code>this.on('modify', function() {
    alert('Object is modified');
});</code></pre>
		</div>
		
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						data
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Данные, входящие в новый экземпляр</td>
				</tr>
			 
				<tr>
					<td>
						collection
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="matreshkaArray">matreshkaArray</span>
</td>
					<td> Массив, в который был добавлен объект в качестве <a href="#!Matreshka.Array-Model">модели</a></td>
				</tr>
			
		</tbody>
	</table>

		

		 
	<h4>Примеры</h4>
  
<h5><p>Создание экземпляра</p></h5>
<pre class="prettyprint source lang-js"><code>new MK.Object;</code></pre><h5><p>Создание экземпляра с двумя заданными свойствами</p></h5>
<pre class="prettyprint source lang-js"><code>// то же самое, что и new MK.Object().jset({a: 1, b: 2});
new MK.Object({a: 1, b: 2});</code></pre><h5><p>Наследование</p></h5>
<pre class="prettyprint source lang-js"><code>var MyClass = Class({
	'extends': MK.Object,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});</code></pre><h5><p>Наследование, используя синтаксис ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>class MyClass extends MK.Object {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}</code></pre><h5><p>Перебор данных, используя цикл for..of из ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({a: 1, b: 2});
for(let item of mkObject) {
	console.log(item); // 1 .. 2
}</code></pre>
		<a class="comments" data-id="Matreshka.Object" data-title="Класс Matreshka.Object">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object"
  title="Класс Matreshka.Object"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
	</article>
	
<article class="item property" id="!Matreshka.Object-isMKObject" data-since="">
	<h2>
		<a href="#!Matreshka.Object-isMKObject">

			<span class="memberof">Matreshka.Object#</span>isMKObject</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>

			<!-- <span data-type="boolean">boolean</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Свойство <code>isMKObject</code> всегда равно <code>true</code>. Оно используется для проверки, является ли объект экземпляром <a href="#!Matreshka.Object">Matreshka.Object</a>.</p></div>
	<div class="description"></div>
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>alert(object.isMKObject);</code></pre>
	<a class="comments" data-id="Matreshka.Object-isMKObject" data-title="Свойство Matreshka.Object-isMKObject">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-isMKObject"
  title="Свойство Matreshka.Object-isMKObject"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

	
<article class="item method" id="!Matreshka.Object-keys" data-since="">
	<h2>
		<a href="#!Matreshka.Object-keys">
			<span class="memberof">Matreshka.Object#</span>keys()
		</a> <span class="returns">→ 
	<span data-type="array">array</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Возвращает массив ключей, отвечающих за данные</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="array">array</span>

		 - keys

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var keys = this.keys();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-keys" data-title="Метод Matreshka.Object-keys">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-keys"
  title="Метод Matreshka.Object-keys"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Object-hasOwnProperty" data-since="">
	<h2>
		<a href="#!Matreshka.Object-hasOwnProperty">
			<span class="memberof">Matreshka.Object#</span>hasOwnProperty<wbr>(<span class="args">key</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Проверяет есть ли в экземпляре свойство, отвечающее за данные, с заданным ключом</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					 </td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.hasOwnProperty('a'); // true

mkObject.hasOwnProperty('b'); // true

mkObject.hasOwnProperty('c'); // false</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-hasOwnProperty" data-title="Метод Matreshka.Object-hasOwnProperty">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-hasOwnProperty"
  title="Метод Matreshka.Object-hasOwnProperty"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Object-toObject" data-since="">
	<h2>
		<a href="#!Matreshka.Object-toObject">
			<span class="memberof">Matreshka.Object#</span>toObject()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Конвертирует экземпляр <a href="#!Matreshka.Object">Matreshka.Object</a> в обычный объект, но не конвертирует входящие в него свойства</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5><p>Basic usage</p></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.toObject(); // возвращает {a: 1, b: 2}</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-toObject" data-title="Метод Matreshka.Object-toObject">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-toObject"
  title="Метод Matreshka.Object-toObject"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Object-toNative" data-since="">
	<h2>
		<a href="#!Matreshka.Object-toNative">
			<span class="memberof">Matreshka.Object#</span>toNative()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Делает то же самое, что и <a href="#!Matreshka.Object-toObject">Matreshka.Object#toObject</a></p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5><p>Usage</p></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.toNative(); // возвращает {a: 1, b: 2}</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-toNative" data-title="Метод Matreshka.Object-toNative">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-toNative"
  title="Метод Matreshka.Object-toNative"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Object-toJSON" data-since="">
	<h2>
		<a href="#!Matreshka.Object-toJSON">
			<span class="memberof">Matreshka.Object#</span>toJSON()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		<i class="important" title="Важно"></i>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Конвертирует экземпляр и внутренние свойства <a href="#!Matreshka.Object">Matreshka.Object</a> в обычный объект</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({
	a: 1,
	b: 2,
	c: new MK.Object({
		d: 3,
		e: 4
	})
});

// возвращает {a: 1, b: 2, c: {d: 3, e: 4}}
mkObject.toJSON();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-toJSON" data-title="Метод Matreshka.Object-toJSON">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-toJSON"
  title="Метод Matreshka.Object-toJSON"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Object-keyOf" data-since="">
	<h2>
		<a href="#!Matreshka.Object-keyOf">
			<span class="memberof">Matreshka.Object#</span>keyOf<wbr>(<span class="args">value</span>)
				
		</a> <span class="returns">→ 
	<span data-type="string">string</span>

	<span data-type="null">null</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Ищет заданное значение свойства среди свойств, отвечающих за данные, и возвращает ключ, если такое значение найдено  (аналог <code>Array.prototype.indexOf</code>)</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="string">string</span>

	<span data-type="null">null</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						value
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> значение любого типа, которое следует найти среди данных</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.keyOf(1); // 'a'

mkObject.keyOf(2); // 'b'

mkObject.keyOf(3); // null</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-keyOf" data-title="Метод Matreshka.Object-keyOf">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-keyOf"
  title="Метод Matreshka.Object-keyOf"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Object-jset" data-since="">
	<h2>
		<a href="#!Matreshka.Object-jset">
			<span class="memberof">Matreshka.Object#</span>jset<wbr>(<span class="args">key, value, evtOpts</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		<i class="important" title="Важно"></i>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Устанавливает свойство и добавляет ключ в список ключей, отвечающих за данные</p></div>
	<div class="description"><p>Этот метод делает две вещи:</p>
<p>1. Устанавливает заданное значение заданному свойству.</p>
<p>2. Добавляет ключ свойства в список данных, что делает свойство доступным для использования в методах <a href="#!Matreshka.Object-each">Matreshka.Object#each</a>, <a href="#!Matreshka.Object-keys">Matreshka.Object#keys</a>, <a href="#!Matreshka.Object-toObject">Matreshka.Object#toObject</a> и <a href="#!Matreshka.Object-toJSON">Matreshka.Object#toJSON</a>).</p>
<p>В остальном, метод работает так же, как и <a href="#!Matreshka-set">Matreshka#set</a>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">change</span> <span class="event">change:KEY</span> <span class="event">modify</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Ключ</td>
				</tr>
			 
				<tr>
					<td>
						value
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> Значение</td>
				</tr>
			 
				<tr>
					<td>
						evtOpts
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> Объект события</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-set">Matreshka#set</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.jset('a', 1).jset('b', 2);</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.jset('a', 1).jset('b', 2);

// присваиваем свойству 'c' тройку,
// но не добавляем ключ в список ключей, отвечающих за данные
this.set('c', 3);

this.each(function(value, key) {
	console.log(key, value); 
});

// выводит 'a' 1 и 'b' 2

console.log(this.keys()); // выводит ['a', 'b']

console.log(this.toJSON()); // выводит {a: 1, b: 2}</code></pre><h5><p>После использования  метода <a href="#!Matreshka.Object-jset">Matreshka.Object#jset</a> со свойством можно работать, как с обычным свойством</p></h5>
<pre class="prettyprint source lang-js"><code>this.jset('a', 1).jset('b', 2);
this.set('a', 3); 
this.b = 4;</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-jset" data-title="Метод Matreshka.Object-jset">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-jset"
  title="Метод Matreshka.Object-jset"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Object-jset(2)" data-since="">
	<h2>
		<a href="#!Matreshka.Object-jset(2)">
			<span class="memberof">Matreshka.Object#</span>jset<wbr>(<span class="args">keyValuePairs, evtOpts</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		<i class="important" title="Важно"></i>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Альтернативный синтаксис метода <a href="#!Matreshka.Object-jset">Matreshka.Object#jset</a>, который использует объект ключ-значение для установки нескольких свойств сразу</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keyValuePairs
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект ключ-значение</td>
				</tr>
			 
				<tr>
					<td>
						evtOpts
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> Объект события</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.jset({
	a: 1,
	b: 2
});</code></pre><h5><p>Использование объекта события</p></h5>
<pre class="prettyprint source lang-js"><code>this.jset({
	a: 1,
	b: 2
}, {silent: true});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-jset(2)" data-title="Метод Matreshka.Object-jset(2)">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-jset(2)"
  title="Метод Matreshka.Object-jset(2)"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Object-remove" data-since="">
	<h2>
		<a href="#!Matreshka.Object-remove">
			<span class="memberof">Matreshka.Object#</span>remove<wbr>(<span class="args">key, evtOptions</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет свойство из экземпляра класса <a href="#!Matreshka.Object">Matreshka.Object</a> и из списка ключей, отвечающих за данные</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">delete</span> <span class="event">delete:KEY</span> <span class="event">modify</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						key
						
					</td>
					 
					<td>
	<span data-type="string">string</span>
</td>
					<td> Ключ (или список ключей, разделенных пробелами)</td>
				</tr>
			 
				<tr>
					<td>
						evtOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> Объект события</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-remove">Matreshka#remove</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.remove('myKey');
this.remove('myKey1 myKey2');</code></pre><h5><p>Использование объекта события</p></h5>
<pre class="prettyprint source lang-js"><code>this.remove('myKey', {silent: true});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-remove" data-title="Метод Matreshka.Object-remove">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-remove"
  title="Метод Matreshka.Object-remove"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Object-addDataKeys" data-since="">
	<h2>
		<a href="#!Matreshka.Object-addDataKeys">
			<span class="memberof">Matreshka.Object#</span>addDataKeys<wbr>(<span class="args">keys</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Добавляет ключи в список ключей, отвечающих за данные</p></div>
	<div class="description"><p>Этот метод применяется тогда, когда нужно объявить ключи, отвечающие за данные, но значения соответствующих свойств еще не известны.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keys
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> Ключ, или ключи разделенные пробелами, или массив ключей</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.addDataKeys('a b');</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.addDataKeys(['a', 'b']);</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.addDataKeys('a', 'b');</code></pre><h5><p>Пример с <a href="#!Matreshka.Object-each">Matreshka.Object#each</a></p></h5>
<pre class="prettyprint source lang-js"><code>this.addDataKeys('a b');

this.each(function(value, key) {
	console.log(key, value);
});
// выводит 'a' undefined and 'b' undefined</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-addDataKeys" data-title="Метод Matreshka.Object-addDataKeys">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-addDataKeys"
  title="Метод Matreshka.Object-addDataKeys"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Object-removeDataKeys" data-since="">
	<h2>
		<a href="#!Matreshka.Object-removeDataKeys">
			<span class="memberof">Matreshka.Object#</span>removeDataKeys<wbr>(<span class="args">keys</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет ключи из списка ключей, отвечающих за данные (но не удаляет свойство)</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						keys
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="array">array</span>
</td>
					<td> Ключ или ключи разделенные пробелами или массив ключей</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.removeDataKeys('a b');</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.removeDataKeys(['a', 'b']);</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.removeDataKeys('a', 'b');</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-removeDataKeys" data-title="Метод Matreshka.Object-removeDataKeys">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-removeDataKeys"
  title="Метод Matreshka.Object-removeDataKeys"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Object-each" data-since="">
	<h2>
		<a href="#!Matreshka.Object-each">
			<span class="memberof">Matreshka.Object#</span>each<wbr>(<span class="args">callback, thisArg</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaObject">matreshkaObject</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Перебирает свойства, отвечающие за данные</p></div>
	<div class="description"><p>Метод очень похож на <code>Array.prototype.forEach</code></p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaObject">matreshkaObject</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						callback
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Функция, которая вызывается на каждой итерации</td>
				</tr>
			 
				<tr>
					<td>
						thisArg
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> Контекст функции</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.each( function(value, key) {
	... 
}, this);</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this
	.jset({a: 1, b: 2})
	.addDataKeys('c')
	.each(function(value, key) {
		console.log(key, value);
	}, this);
; 
// >>> a 1, b 2, c undefined</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Object-each" data-title="Метод Matreshka.Object-each">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Object-each"
  title="Метод Matreshka.Object-each"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

	
	
	
</section>


	<section>
	<article class="item class" id="!Matreshka.Array">
		<h2>
			<a href="#!Matreshka.Array">
				<span class="signature-class">Класс</span> Matreshka.Array
			</a>
			<i class="important" title="Важно"></i>
		</h2>
		<div class="description">
			<p>Класс <code>Matreshka.Array</code> служит коллекцией во фреймворке Матрешка. Он наследуется от класса <a href="#!Matreshka">Matreshka</a>, получая все без исключения возможности родителя. Кроме этого, <code>Matreshka.Array</code> имеет все методы, которые есть у обычного массива.</p>
<h4>Все методы, позаимствованные у встроенного Array работают аналогично их оригиналам</h4><p>Программист, знакомый с методами нативного <code>Array</code> сразу может понять, каким методом можно добавить элемент (<code>push</code>, <code>unshift</code>, <code>splice</code>), каким удалить (<code>pop</code>, <code>shift</code>, <code>splice</code>), каким отсортировать (<code>sort</code>, <code>reverse</code>) и т. д. Исключением из этого правила является метод <code>forEach</code>, который в оригинальном виде всегда возвращает <code>undefined</code>, а, в случае с <a href="#!Matreshka.Array">Matreshka.Array</a> возвращает &quot;себя&quot; для возможности цепочечного вызова. По причине того, что методы работают точно так же, как и оригинальные, они не приведены в этой документации по отдельности, а выведены в раздел <a href="#!Matreshka.Array-METHOD">Matreshka.Array#METHOD</a>.</p>
<pre class="prettyprint source lang-js"><code>this.push(1, 2, 3);
this.pop();</code></pre><h4>Все методы, позаимствованные у встроенного Array, которые модифицируют массив могут быть вызваны с передачей объекта события</h4><p>Для этого используется синтаксис <code>метод_</code>, где нижнее подчеркивание в конце имени метода означает, что последним аргументом является объект события. Такие методы не приведены в этой документации, так как требуется запомнить только их синтаксис. См.  <a href="#!Matreshka.Array-METHOD_">Matreshka.Array#METHOD_</a>.</p>
<pre class="prettyprint source lang-js"><code>this.push_(1, 2, 3, {
    silent: true
});
this.pop_({
    silent: true
});</code></pre><h4>Разработчик имеет возможность отлавливать любые модификации данных</h4><p><strong>При использовании методов, позаимствованных у встроенного <code>Array</code> генерируются события с соответствующим именем.</strong> Вызывая метод <code>push</code>, генерируется событие <code>push</code>, вызывая метод <code>pull</code> генерируется событие <code>pull</code>, вызывая метод <code>sort</code>, генерируется событие <code>sort</code> и так далее... Список аргументов можно получить, обратясь к свойству <code>args</code>.</p>
<pre class="prettyprint source lang-js"><code>this.on('push', function(evt) {
    console.log(evt.args); // [1,2,3]
});

this.push(1, 2, 3);</code></pre><p><strong>При добавлении элементов генерируются события <code>add</code> и <code>addone</code>.</strong> Первое генерируется один раз на добавление (например, вы добавили несколько элементов с помощью <code>push</code>, событие вызвалось только один раз), второе генерируется один раз на каждый добавленный элемент. При срабатывании события <code>add</code>, в объект события (свойство <code>added</code>) передается массив добавленных элементов, а при срабатывании <code>addone</code>, в него же передаётся каждый отдельный добавленный элемент.</p>
<pre class="prettyprint source lang-js"><code>this.on('add', function(evt) {
    console.log(evt.added); // [1,2,3]
});

this.push(1, 2, 3);</code></pre><pre class="prettyprint source lang-js"><code>// обработчик запустится трижды,
// так как в массив добавили три новых элемента
this.on('addone', function(evt) {
    console.log(evt.added); // 1 ... 2 ... 3
});

this.push(1, 2, 3);</code></pre><p><strong>При удалении элементов действует та же логика</strong>: <code>remove</code> срабатывает один раз, даже если удалено несколько элементов, а событие <code>removeone</code> срабатывает для каждого удаленного элемента индивидуально. Удаленные элементы содержатся в свойстве <code>removed</code> объекта события.</p>
<pre class="prettyprint source lang-js"><code>this.push(1, 2, 3, 4, 5);

this.on('remove', function(evt) {
    console.log(evt.removed); // [2,3,4]
});

this.splice(1, 3);</code></pre><pre class="prettyprint source lang-js"><code>this.push(1, 2, 3, 4, 5);

// обработчик запустится трижды,
// так как в массив добавили три новых элемента
this.on('removeone', function( evt ) {
    console.log(evt.removed); // 2 ... 3 ... 4
});

this.splice(1, 3);</code></pre><p><strong>При каждой модификации массива генерируется событие <code>modify</code></strong>, позволяя отловить все без исключения изменения в массиве (добавление, удаление, пересортировку).</p>
<pre class="prettyprint source lang-js"><code>this.on('modify', function(evt) {
    ...
});</code></pre><p><strong><code>length</code> - это обычное свойство</strong> которое можно связывать с HTML элементом или отлавливать изменения с помощью события <code>change:length</code>.</p>
<blockquote>
<p>Например, при добавлении трех элементов с помощью метода <code>push</code> с тремя аргументами, генерируются следующие события: <code>push</code>, <code>add</code>, <code>addone</code> (трижды), <code>modify</code>, <code>change:length</code>.</p>
</blockquote>
<h4>Model</h4><p>Свойство <a href="#!Matreshka.Array-Model">Matreshka.Array#Model</a> определяет класс элементов, которые будет содержать коллекция. Его поведение очень напоминает поведение свойства <code>model</code> из <code>Backbone.Collection</code>. Рекомендуется наследовать <code>Model</code> от класса <a href="#!Matreshka.Object">Matreshka.Object</a> или <a href="#!Matreshka.Array">Matreshka.Array</a> (на случай, если требуется получить коллекцию коллекций), чтоб получить возможность конвертации массива в обычный массив методом <a href="#!Matreshka.Array-toJSON">Matreshka.Array#toJSON</a>.</p>
<pre class="prettyprint source lang-js"><code>// определяем Модель
var MyModel = Class({
    // она наследуется от MK.Object
    'extends': MK.Object,
    constructor: function(data) {
        // устанавливаем переданные свойства методом jset
        this.jset(data);
    }
});

// определяем класс для коллекции
var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel
});

// создаем экземпляр класса
var myArray = new MyArray;

// добавляем два элемента
myArray.push({
    a: 1,
    b: 2
}, {
    a: 3,
    b: 4
})

// вернет [{a: 1, b: 2}, {a: 3, b: 4}]
myArray.toJSON();</code></pre><h4>Автоматический рендеринг</h4><p><code>Matreshka.Array</code> умеет автоматически отрисовывать элементы на странице <strong>при любых модификациях</strong> массива. Для этого применяется свойство <a href="#!Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>. Программисту больше не нужно заботиться о перестройке HTML дерева, <code>Matreshka.Array</code> делает это за него. Ниже пример использования автоматического рендеринга списка.</p>
<pre class="prettyprint source lang-html"><code>&lt;ul class=&quot;my-list&quot;>&lt;/ul></code></pre><pre class="prettyprint source lang-js"><code>var MyModel = MK.Class({
    'extends': MK.Object,
    constructor: function(data) {
        this.jset(data);

        // ждем события 'render'
        this.on('render', function() {
            // и привязываем свойство 'value'
            // к новосозданному HTML элементу &lt;li>
            this.bindNode('value', ':sandbox', MK.binders.html());
        });
    }
});

var MyArray = MK.Class({
    'extends': MK.Array,
    Model: MyModel,
    // определяем рендерер для каждого элемента коллекции
    itemRenderer: '&lt;li>',
    constructor: function() {
        // создаём песочницу
        this.bindNode('sandbox', '.my-list');
    }
});

var myArray = new MyArray();
myArray.push({
    value: 'Hello'
}, {
    value: 'World'
});</code></pre><p>За подробностями обратитесь к документации <a href="#!Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>.</p>
		</div>
		
		
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>
	
		<li><a href="#!Matreshka.Array-Model">Matreshka.Array#Model</a>
	
		<li><a href="#!Matreshka-bindNode">Matreshka#bindNode</a>
	
</ul>


		 
	<h4>Примеры</h4>
  
<h5><p>Создание экземпляра</p></h5>
<pre class="prettyprint source lang-js"><code>new MK.Array();</code></pre><h5><p>Создание экземпляра с указанием длины</p></h5>
<pre class="prettyprint source lang-js"><code>new MK.Array(42);</code></pre><h5><p>Передача элементов при создании</p></h5>
<pre class="prettyprint source lang-js"><code>new MK.Array('Hi', {a: 'b'});</code></pre><h5><p>Наследование</p></h5>
<pre class="prettyprint source lang-js"><code>var MyClass = Class({
	'extends': MK.Array,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});</code></pre><h5><p>Наследование, используя синтаксис ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>class MyClass extends MK.Array {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}</code></pre><h5><p>Перебор данных, используя цикл for..of из ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>var mkArray = new MK.Array(1, 2, 3);
for(let item of mkArray) {
	console.log(item); // 1 .. 2 .. 3
}</code></pre><h5><p>Прослушивание событий</p></h5>
<pre class="prettyprint source lang-js"><code>this.on('modify', function(evt) {
	alert('1) Вызван метод ' + evt.method);
});

this.on('shift', function(evt) {
	alert('2) Вызван метод ' + evt.method);
});

this.push(1); // 1) Вызван метод push

this.shift(); // 1) Вызван метод shift, 2) Вызван метод shift</code></pre><h5><p>Передача объекта события во встроенный метод <code>Array</code></p></h5>
<pre class="prettyprint source lang-js"><code>this.on('modify', function(evt) {
	alert(evt.customData);
});

this.push_(1, {
	silent: true // событие не генерируется
});

this.shift_({
	customData: 42 // 42
});</code></pre>
		<a class="comments" data-id="Matreshka.Array" data-title="Класс Matreshka.Array">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array"
  title="Класс Matreshka.Array"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
	</article>
	
<article class="item property" id="!Matreshka.Array-isMKArray" data-since="">
	<h2>
		<a href="#!Matreshka.Array-isMKArray">

			<span class="memberof">Matreshka.Array#</span>isMKArray</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>

			<!-- <span data-type="boolean">boolean</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p><code>isMKArray</code> всегда равен <code>true</code>. Это свойство используется для того, чтоб определить, является ли объект экземпляром класса <a href="#!Matreshka.Array">Matreshka.Array</a></p></div>
	<div class="description"></div>
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>alert(object.isMKArray);</code></pre>
	<a class="comments" data-id="Matreshka.Array-isMKArray" data-title="Свойство Matreshka.Array-isMKArray">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-isMKArray"
  title="Свойство Matreshka.Array-isMKArray"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item property" id="!Matreshka.Array-useBindingsParser" data-since="">
	<h2>
		<a href="#!Matreshka.Array-useBindingsParser">

			<span class="memberof">Matreshka.Array#</span>useBindingsParser</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>

			<!-- <span data-type="boolean">boolean</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Свойство отключает парсер, если присвоить ему <code>false</code></p></div>
	<div class="description"></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
	'extends': MK.Array,
	useBindingsParser: false,
	itemRenderer: '&lt;li>{{property}}'
});</code></pre>
	<a class="comments" data-id="Matreshka.Array-useBindingsParser" data-title="Свойство Matreshka.Array-useBindingsParser">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-useBindingsParser"
  title="Свойство Matreshka.Array-useBindingsParser"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item property" id="!Matreshka.Array-renderIfPossible" data-since="">
	<h2>
		<a href="#!Matreshka.Array-renderIfPossible">

			<span class="memberof">Matreshka.Array#</span>renderIfPossible</a><span class="type">:
				<span data-type="boolean">boolean</span>
			</span>

			<!-- <span data-type="boolean">boolean</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Свойство <code>renderIfPossible</code> отменяет рендеринг массива</p></div>
	<div class="description"></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
	itemRenderer: '&lt;li>'
    renderIfPossible: false,
    // ...
});</code></pre>
	<a class="comments" data-id="Matreshka.Array-renderIfPossible" data-title="Свойство Matreshka.Array-renderIfPossible">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-renderIfPossible"
  title="Свойство Matreshka.Array-renderIfPossible"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item property" id="!Matreshka.Array-itemRenderer" data-since="0.1">
	<h2>
		<a href="#!Matreshka.Array-itemRenderer">

			<span class="signature">&lt;virtual&gt;</span><span class="memberof">Matreshka.Array#</span>itemRenderer</a><span class="type">:
				<span data-type="string">string</span> <span data-type="function">function</span>
			</span>

			<!-- <span data-type="string">string</span></span>-->
		<i class="important" title="Важно"></i>
		<i class="cool" title="Крутой метод или свойство"></i>
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>HTML строка, селектор или функция, отвечающая за отрисовку элементов массива на странице</p></div>
	<div class="description"><p>Свойство <code>itemRenderer</code> - это переопределяемое (виртуальное) свойство, которое позволяет рендерить элементы массива без участия программиста. При вставке нового элемента в массив, автоматически создается HTML узел. Этот узел становится песочницей (см. <a href="#!Matreshka-bindNode">Matreshka#bindNode</a>) для вставленного элемента и встраивается в HTML контейнер, определенный в массиве.</p>
<h4>Куда вставляется созданный элемент?</h4><p>Для того, чтобы определить HTML контейнер, в который будут вставляться отрисованные HTML узлы, нужно определить <strong>контейнер</strong>. Для этого следует объявить HTML песочницу для массива либо связать специальный ключ <code>container</code> с HTML контейнером. Подробнее о привязках и песочнице см. <a href="#!Matreshka-bindNode">Matreshka#bindNode</a>.
Пример использования песочницы в качестве контейнера:</p>
<pre class="prettyprint source lang-html"><code>&lt;ul class=&quot;my-list&quot;>&lt;/ul></code></pre><pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    itemRenderer: '&lt;li>',
    Model: MyModel,
    constructor: function() {
        // определяем песочницу
        this.bindNode('sandbox', '.my-list');
    }
});</code></pre><p>Теперь все новосозданные узлы <code>&lt;li&gt;</code> попадут в узел <code>.my-list</code></p>
<p>Если вы не хотите вставлять HTML узлы непосредственно в песочницу, можете связать ключ <code>container</code> с необходимым элементом. Такая логика нужна в том случае, если песочница не ограничена одними лишь элементами коллекции и включает в себя другие HTML узлы.</p>
<pre class="prettyprint source lang-html"><code>&lt;div class=&quot;my-widget&quot;>
    &lt;h1>This is my awesome list&lt;/h1>
    &lt;ul class=&quot;my-list&quot;>&lt;/ul>
&lt;/div></code></pre><pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    itemRenderer: '&lt;li>',
    Model: MyModel,
    constructor: function() {
        // определяем песочницу
        this.bindNode('sandbox', '.my-widget');
        // определяем контейнер для HTML элементов
        this.bindNode('container', '.my-list');
    }
});</code></pre><p>В примере выше HTML узлы будут вставляться в <code>.my-list</code> вместо <code>.my-widget</code>.</p>
<p>Свойство <code>itemRenderer</code> поддерживает несколько вариантов определения, но все они должны содержать или возвращать единственный HTML узел.</p>
<h4>HTML строка в качестве значения свойства</h4><p>Как видно из примера выше, <code>itemRenderer</code> может быть определен, как HTML строка.</p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel,
    itemRenderer: '&lt;div class=&quot;my-div&quot;>Be cool&lt;/div>',
    constructor: function() { ... }
});</code></pre><h4>Селектор в качестве значения свойства</h4><p>На случай, если вы выносите шаблоны для элементов на HTML страницу, <code>itemRenderer</code> поддерживает селектор в качестве значения. В этом случае, <a href="#!Matreshka.Array">Matreshka.Array</a> будет искать HTML элемент в DOM дереве и извлечет <code>innerHTML</code> найденого элемента. В случае, если элемент не найден, бросается исключение. HTML текст от селектора отличается наличием  символа <code>&lt;</code> в строке.</p>
<pre class="prettyprint source lang-html"><code>&lt;script type=&quot;text/html&quot; id=&quot;be-cool-template&quot;>
    &lt;div class=&quot;my-div&quot;>Be cool&lt;/div>
&lt;/script></code></pre><pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel
    itemRenderer: '#be-cool-template',
    constructor: function() { ... }
});</code></pre><h4>Функция в качестве значения свойства</h4><p>Использование функции в качестве значения свойства <code>itemRenderer</code> даёт дополнительную гибкость кода, если есть нужда динамически генерировать элемент для рендеринга. Функция может возвращать:</p>
<p><strong>HTML строку</strong></p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel,
    itemRenderer: function() {
        return '&lt;div class=&quot;my-div&quot;>Be cool&lt;/div>';
    },
    constructor: function() { ... }
});</code></pre><p><strong>Селектор</strong></p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel,
    itemRenderer: function() {
        return '#be-cool-template';
    },
    constructor: function() { ... }
});</code></pre><p><strong>DOM узел</strong></p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    itemRenderer: function() {
        return document.createElement('div');
    }
});</code></pre><p><strong>Handlebars.js в качестве шаблонизатора</strong></p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    // model - модель (экземпляр Matreshka.Object), который будет рендериться
    itemRenderer: function(model) {
        // получение и компилирование шаблона
        var template = Handlebars
            .compile($('#handlebarsTemplateSelector').html());
        // подстановка значений модели в шаблон и его возвращение
        return template(model);
    }
});</code></pre><h4>Переопределение родительского рендерера свойством <code>render</code></h4><p>Иногда удобно объявлять рендерер внутри класса <a href="#!Matreshka.Array-Model">Matreshka.Array#Model</a>, как это делает <code>Backbone</code>. Свойство <code>renderer</code> переопределяет значение <code>itemRenderer</code>, если оно задано для дочернего элемента коллекции.</p>
<pre class="prettyprint source lang-js"><code>var MyModel = Class({
    'extends': MK.Object,
    renderer: '&lt;div class=&quot;my-div&quot;>Be cool&lt;/div>',
    constructor: function(data) { ... }
});

var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel,
    itemRenderer: '&lt;frameset>Not cool&lt;/frameset>',
    constructor: function() { ... }
});</code></pre><p>В этом случае, можно вовсе не указывать <code>itemRenderer</code>, так как <code>render</code> дочернего элемента перенимает все его возможности. Синтаксис остаётся такими же: можно использовать HTML, селектор или функцию.</p>
<h4>Событие <code>render</code></h4><p>После того, как элемент вставлен в массив, а его HTML узел уже создан, но еще не вставлен в контейнер, генерируется событие <code>render</code> на вставленном элементе. После его генерации можно объявить привязки свойств к HTML узлам, содержащимся внутри вставленного.</p>
<pre class="prettyprint source lang-html"><code>&lt;form class=&quot;my-form&quot;>&lt;/form></code></pre><pre class="prettyprint source lang-js"><code>var MyModel = Class({
    'extends': MK.Object,
    constructor: function(data) {
        this.jset(data);

        // ждем генерации события
        this.on('render', function() {
            this.bindNode('isChecked', ':sandbox .my-checkbox');
            this.bindNode('text', ':sandbox .text',
                MK.binders.html());
        });
    }
});

var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel,
    itemRenderer: '&lt;label>\
        &lt;input type=&quot;checkbox&quot; class=&quot;my-checkbox&quot;>\
        &lt;span class=&quot;text&quot;>&lt;/span>\
    &lt;/label>',
    constructor: function() {
        this.bindNode('sandbox', '.my-form');
        this.push({
            isChecked: true,
            text: 'Be cool'
        }, {
            isChecked: false,
            text: 'Produce shitcode'
        });
    }
});

var app = new MyArray();</code></pre><p>Код выше создаст такое HTML дерево:</p>
<pre class="prettyprint source lang-html"><code>&lt;form class=&quot;my-form&quot;>
    &lt;label>
        &lt;input type=&quot;checkbox&quot; class=&quot;my-checkbox&quot;>
        &lt;span class=&quot;text&quot;>Be cool&lt;/span>
    &lt;/label>
    &lt;label>
        &lt;input type=&quot;checkbox&quot; class=&quot;my-checkbox&quot;>
        &lt;span class=&quot;text&quot;>Produce shitcode&lt;/span>
    &lt;/label>
&lt;/form></code></pre><p>И свяжет чекбоксы с соответствующими свойствaми <code>isChecked</code> и <code>text</code>. <a href="http://jsbin.com/zetuya/1/" target="_blank">Живой пример</a></p>
<p>Не забывайте, что в Матрешке реализована возможность отлова всплывающих событий. Т. е. сам массив может отловить событие рендеринга элемента, используя имя события <code>*@render</code> (см. документацию к <span data-type="eventNames">eventNames</span>).</p>
<pre class="prettyprint source lang-js"><code>this.on('*@render', function(evt) {
    alert('Child element is rendered');
});</code></pre><blockquote>
<p>Отрисованный HTML узел становится песочницей для вставленного элемента, позволяя использовать селектор <code>:sandbox</code> и другие возможности после рендеринга. Если элемент входит сразу в несколько коллекций, установите ему свойство <code>bindRenderedAsSandbox: false</code>, чтобы отменить это поведение.</p>
<pre class="prettyprint source lang-js"><code>var MyModel = Class({
    'extends': MK.Object,
    bindRenderedAsSandbox: false
    // ...
});</code></pre></blockquote>
<h4><code>onItemRender</code> и <code>onRender</code></h4><p>Для улучшения читаемости кода и небольшого выигрыша в скорости, в версии 1.1 появился виртуальный метод <a href="#!Matreshka.Array-onItemRender">Matreshka.Array#onItemRender</a>, который можно использовать вместо события <code>render</code>. В качестве альтернативы, у &quot;моделей&quot; вызывается метод <code>onRender</code>, так же позволяющий сделать код более &quot;плоским&quot; и избавиться от вложенных функций.</p>
<pre class="prettyprint source lang-js"><code>var MyModel = Class({
    'extends': MK.Object,
    constructor: function(data) {
        this.jset(data);
    },
    onRender: function(evt) {
        this.bindNode('isChecked', ':sandbox .my-checkbox');
        this.bindNode('text', ':sandbox .text',
                MK.binders.html());
    }
});

var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel,
    itemRenderer: '...`,
    constructor: function() {
        //...
    },
    onItemRender: function(item, evt) {
        //...
    }
});

var app = new MyArray();</code></pre><h4>Шаблонизатор</h4><p>Взглянув на примеры использования <a href="#!Matreshka.Array">Matreshka.Array</a> и <a href="#!Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a> можно обратить внимание на то, что вся логика, отвечающая за двустороннюю и одностороннюю привязку данных заключена в JavaScript коде. Это одно из главных преимуществ Матрешки. Но когда разрабатываешь очень простую коллекцию, не включающую в себя сложную логику, массу привязок и пр. хотелось бы иметь более краткий вариант объявления привязок. Для этого, в <code>itemRenderer</code> может быть передан шаблон, включающий привязки. Начиная с версии 1.1, шаблонизатор включен по умолчанию.</p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    Model: MK.Object,
    itemRenderer: '&lt;label>\
        &lt;input type=&quot;checkbox&quot; checked=&quot;&#123;{isChecked}}&quot;>&#123;{text}}\
    &lt;/label>',
    constructor: function() {
        this.bindNode('sandbox', '.my-form');
        this.push({
            isChecked: true,
            text: 'Be cool'
        }, {
            isChecked: false,
            text: 'Produce shitcode'
        });
    }
});

var app = new MyArray();</code></pre><p>Пример выше полностью повторяет предыдущий, но не требует создания отдельного класса для Модели, так как нам не требуется отлавливать событие <code>render</code> и объявлять привязки вручную. <a href="http://jsbin.com/wabiyi/1/" target="_blank">Живой пример</a></p>
<p>Обратите внимание:
Скорость кода с шаблонизатором несколько ниже, чем без него. Это происходит из-за того, что анализ строки, перебор ключей в цикле (при использовании нескольких ключей в одном атрибуте), замена подстрок регулярным выражением и пр. требуют больше ресурсов. Шаблонизатор можно отключить двумя способами: установить свойство <a href="#!Matreshka.Array-useBindingsParser">Matreshka.Array#useBindingsParser</a>, как <code>false</code>, или не использовать синтаксис &#123;{KEY}} вовсе (шаблонизатор срабатывает только тогда, когда у узла или HTML строки есть двойные фигурные скобки).</p>
<p>Шаблонизация реализована с помощью метода <a href="#!Matreshka-parseBindings">Matreshka#parseBindings</a>.</p>
<h4>Отмена рендеринга</h4><p>Как видно выше, если у дочернего элемента задано свойство <code>render</code>, <code>Matreshka.Array</code> попробует его отрисовать. Для того, чтоб полностью отменить рендеринг для массива, присвойте свойству <code>renderIfPossible: false</code>.</p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    renderIfPossible: false,
    // ...
});</code></pre><h4>Перемещение объекта из одного массива в другой</h4><p>По умолчанию, при вставке объекта в массив Матрешка попытается его отрисовать, используя <code>itemRenderer</code> (если он еще не был отрисован).  Это даёт огромное преимущество в случаях, когда у вас на странице есть два или более списка, включающих в себя один и тот же объект. При изменении этого объекта, все списки моментально реагируют на изменение, обновляя DOM.</p>
<p>Но иногда стоит задача перемещения объекта между коллекциями, не перерисовывая его заново. Для перемещения объекта из одного массива в другой, включая его песочницу, используйте флаг <code>moveSandbox</code>.</p>
<pre class="prettyprint source lang-js"><code>this.push_( item, {
    moveSandbox: true
});</code></pre><h4>Переопределение <code>itemRenderer</code></h4><p>Начиная с версии 1.1, при переустановке свойства <code>itemRenderer</code>, коллекция автоматически перерисовывается.</p>
<pre class="prettyprint source lang-js"><code>this.itemRenderer = '&lt;div>';</code></pre><p>Эта возможность полезна в том случае, когда разработчик желает загрузить шаблон с сервера.</p>
<pre class="prettyprint source lang-js"><code>// пример jQuery.get
jQuery.get('templates/template.html', function(data) {
    this.itemRenderer = data;
}.bind(this));

// пример Fetch API
fetch('templates/template.html')
    .then(function(resp) {
        return resp.text();
    })
    .then(function(data) {
        this.itemRenderer = data;
    }.bind(this));

// пример Fetch API + ECMAScript 2015
fetch('templates/template.html')
    .then(resp => resp.text())
    .then(data => this.itemRenderer = data);</code></pre><h4>Рендеринг коллекции, состоящей из обычных объектов</h4><p>В версии 1.1 самым большим нововведением фреймворка стала поддержка нативных объектов в методах <a href="#!Matreshka.bindNode">Matreshka.bindNode</a>, <a href="#!Matreshka.linkProps">Matreshka.linkProps</a>, <a href="#!Matreshka.mediate">Matreshka.mediate</a> и пр. Эта замечательная возможность не обошла стороной и рендеринг. Теперь не обязательно заботиться о том, чтобы элементы, входящие в коллекцию наследовались от класса <a href="#!Matreshka">Matreshka</a>.</p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    // Model не определена
    itemRenderer: ...
    onItemRender: function(item) {
        MK.bindNode(item, 'x', ':sandbox .some-node');
    }
})</code></pre><p>Для того, чтоб удостовериться, что элементы, попадающие в массив - объекты (а не null, number и пр), можно присвоить свойству <a href="#!Matreshka.Array-Model">Matreshka.Array#Model</a> значение <code>Object</code>, который является встроенным в JavaScript конструктором объектов.</p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    Model: Object,
    itemRenderer: ...
    constructor: function() {...}
})</code></pre><p>Еще небольшой пример: рендеринг простого списка:</p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    itemRenderer: '&lt;li>{{value}}&lt;/li>',
    constructor: function() {
        this.bindNode('sandbox', '.my-list');
    }
});

var arr = new MyArray();
arr.push({value: 'Item 1'}, {value: 'Item 2'});</code></pre></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka-bindNode">Matreshka#bindNode</a>
	
		<li><a href="#!Matreshka.Array-Model">Matreshka.Array#Model</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5><p>ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>class MyArray extends MK.Array {
	get itemRenderer() {
		return '&lt;div>';
	},
	constructor() { ... }
}</code></pre><h5><p>ECMAScript 7</p></h5>
<pre class="prettyprint source lang-js"><code>class MyArray extends MK.Array {
	itemRenderer = '&lt;div>';
	constructor() { ... }
}</code></pre>
	<a class="comments" data-id="Matreshka.Array-itemRenderer" data-title="Свойство Matreshka.Array-itemRenderer">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-itemRenderer"
  title="Свойство Matreshka.Array-itemRenderer"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item property" id="!Matreshka.Array-trackBy" data-since="1.2">
	<h2>
		<a href="#!Matreshka.Array-trackBy">

			<span class="signature">&lt;virtual&gt;</span><span class="memberof">Matreshka.Array#</span>trackBy</a><span class="type">:
				<span data-type="string">string</span>
			</span>

			<!-- <span data-type="string">string</span></span>-->
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Свойство <code>trackBy</code> указывает на ключ идентификатора объектов, входящих в массив</p></div>
	<div class="description"><p>В случае, если клиент и сервер активно обмениваются данными (например, списком пользователей), а объекты, входящие в массив имеют уникальный ID (например, идентификатор пользователя), то перерисовка всей коллекции с нуля не имеет смысла. После того, как сервер вернул новую коллекцию, намного рациональнее проверить, есть ли в коллекции объект с таким же ID и, если объект найден, обновить его. Таким образом, не создаётся новый объект (экземпляр <a href="#!Matreshka.Array-Model">Matreshka.Array#Model</a>) и не рисуется новый DOM узел.</p>
<p><code>trackBy</code> говорит о том, какой именно ключ модели является идентификатором. Используя это свойство работа приложения, в некоторых слуаях, получает серьезный прирост скорости при рендеринге огромных коллекций.</p>
<p><code>trackBy</code> работает только при использовании метода <a href="#!Matreshka.Array-recreate">Matreshka.Array#recreate</a>, так как это единственный метод &quot;пересоздающий&quot; коллекцию заново.</p>
<p>В примере ниже используется <code>_id</code> в качестве значения (значение может быть любым).</p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    trackBy: '_id'
    constructor: function() {
        //,,,
    }
});

var arr = new MyArray();

// добавит три объекта в массив
arr.recreate([
    {_id: 0, name: 'Foo'},
    {_id: 1, name: 'Bar'},
    {_id: 2, name: 'Baz'}
]);

// удалит объект с идентификатором 0
// добавит объект с идентификатором 3
// обновит объект с идентификатором 1, обновив name: Bar -> BarNew
// обновит объект с идентификатором 2, обновив name: Baz -> BazNew
// пересортирует коллекцию в соответствие с переданным данным
arr.recreate([
    {_id: 1, name: 'BarNew'},
    {_id: 3, name: 'Qux'},
    {_id: 2, name: 'BazNew'}
]);</code></pre><p>Свойство может содержать специальное значение <code>&quot;$index&quot;</code>, которое позволяет обновлять объект по индексу в коллекции.</p>
<pre class="prettyprint source lang-js"><code>var MyArray = Class({
    'extends': MK.Array,
    trackBy: '$index'
    constructor: function() {
        //,,,
    }
});

var arr = new MyArray();

// добавит три объекта в массив
arr.recreate([
    {name: 'Foo'},
    {name: 'Bar'},
    {name: 'Baz'}
]);

// обновит все три объекта новыми данными
// и добавит новый объект с именем Qux
arr.recreate([
    {name: 'NewFoo'},
    {name: 'NewBar'},
    {name: 'NewBaz'},
    {name: 'Qux'}
]);</code></pre></div>
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka.Array-recreate">Matreshka.Array#recreate</a>
	
</ul>


	  

	<a class="comments" data-id="Matreshka.Array-trackBy" data-title="Свойство Matreshka.Array-trackBy">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-trackBy"
  title="Свойство Matreshka.Array-trackBy"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

	
<article class="item method" id="!Matreshka.Array-onItemRender" data-since="1.1">
	<h2>
		<a href="#!Matreshka.Array-onItemRender">
			<span class="signature">&lt;virtual&gt;</span><span class="memberof">Matreshka.Array#</span>onItemRender<wbr>(<span class="args">item, renderEvt</span>)
				
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Функция, которая запускается перед событием <code>render</code>.</p></div>
	<div class="description"><p>Для улучшения читаемости кода и небольшого выигрыша в скорости, в версии 1.1 появился виртуальный метод <code>onItemRender</code>, который можно использовать в качестве замены события <code>render</code>.</p>
<p>При этом, у отрисованного элемента вызывается метод <code>onRender</code> с единственным аргументом - объектом события.</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						item
						
					</td>
					 
					<td>
	<span data-type="matreshka">matreshka</span>
</td>
					<td> отрисованный элемент коллекции</td>
				</tr>
			 
				<tr>
					<td>
						renderEvt
						
					</td>
					 
					<td>
	<span data-type="matreshka">matreshka</span>
</td>
					<td> объект события ``render``</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var MyModel = Class({
	'extends': MK.Object,
	constructor: function(data) {
		this.jset(data);
	},
	onRender: function(renderEvt) {
		this.bindNode('isChecked', ':sandbox .my-checkbox');
		this.bindNode('text', ':sandbox .text', MK.binders.html());
	}
});

var MyArray = Class({
	'extends': MK.Array,
	Model: MyModel,
	itemRenderer: '&lt;li>',
	constructor: function() {
		this.bindNode('sandbox', '.my-form');
	},
	onItemRender: function(item, renderEvt) {
		// тоже что-то сделать
	}
});

var app = new MyArray();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-onItemRender" data-title="Метод Matreshka.Array-onItemRender">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-onItemRender"
  title="Метод Matreshka.Array-onItemRender"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-Model" data-since="0.2">
	<h2>
		<a href="#!Matreshka.Array-Model">
			<span class="signature">&lt;virtual&gt;</span><span class="memberof">Matreshka.Array#</span>Model<wbr>(<span class="args">data, mkArray</span>)
				
		</a> 
		<i class="important" title="Важно"></i>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Свойство определяет класс элементов, которые будет содержать коллекция</p></div>
	<div class="description"><p>При каждом добавлении элементов в массив, встроенный обработчик проверяет, является ли добавленный элемент экземпляром <code>Model</code> и конвертирует его в таковой, если проверка не пройдена. Это поведение очень напоминает поведение свойства <code>model</code> из <code>Backbone.Collection</code>. Рекомендуется наследовать <code>Model</code> от класса <a href="#!Matreshka.Object">Matreshka.Object</a> или <a href="#!Matreshka.Array">Matreshka.Array</a> (на случай, если требуется получить коллекцию коллекций), чтоб получить возможность конвертации массива в обычный массив методом <a href="#!Matreshka.Array-toJSON">Matreshka.Array#toJSON</a>.</p>
<p>Для более гибкого контроля класса элементов (например, если для одних элементов нужно использовать одну Модель, а для других - другую), используйте <a href="#!Matreshka.Array-mediateItem">Matreshka.Array#mediateItem</a>.</p></div>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						data
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Данные, переданные в конструктор</td>
				</tr>
			 
				<tr>
					<td>
						mkArray
						
					</td>
					 
					<td>
	<span data-type="matreshkaArray">matreshkaArray</span>
</td>
					<td> Массив, в который добавили элемент</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka.Array-mediateItem">Matreshka.Array#mediateItem</a>
	
		<li><a href="#!Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>// определяем Модель
var MyModel = Class({
	// она наследуется от MK.Object
	'extends': MK.Object,
	constructor: function(data, parentArray) {
		// устанавливаем переданные свойства методом jset
		this.jset(data);
		this.doSomething();
	},
	doSomething: function() { ... }
});

// определяем класс для коллекции
var MyArray = Class({
    'extends': MK.Array,
    Model: MyModel
});

// создаем экземпляр класса
var myArray = new MyArray();

// добавляем два элемента
myArray.push({
    a: 1,
    b: 2
}, {
    a: 3,
    b: 4
})

// вернет [{ a: 1, b: 2 }, { a: 3, b: 4 }]
myArray.toJSON();</code></pre><h5><p><code>Model</code> и ECMAScript 2015</p></h5>
<pre class="prettyprint source lang-js"><code>class MyArray extends MK.Array {
	get Model() {
		return MyModel;
	}
	constructor() { ... }
}</code></pre><h5><p><code>Model</code> и ECMAScript 7</p></h5>
<pre class="prettyprint source lang-js"><code>class MyArray extends MK.Array {
	Model = MyModel;
	constructor() { ... }
}</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-Model" data-title="Метод Matreshka.Array-Model">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-Model"
  title="Метод Matreshka.Array-Model"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-mediateItem" data-since="0.1">
	<h2>
		<a href="#!Matreshka.Array-mediateItem">
			<span class="memberof">Matreshka.Array#</span>mediateItem()
		</a> 
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Трансформирует значение элемента при вставке</p></div>
	<div class="description"><p>Этот метод служит для того, чтоб установить типизацию для вставляемых элементов. Обратите внимание, метод переопределяет свойство <a href="#!Matreshka.Array-Model">Matreshka.Array#Model</a>.</p></div>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka.Array-Model">Matreshka.Array#Model</a>
	
		<li><a href="#!Matreshka-mediate">Matreshka#mediate</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>// все элементы массива - числа
this.mediateItem(Number);</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.push(1, 2, 3, 4, 5);

// все элементы массива - строки
this.mediateItem(function(value) {
	return String(value);
});

this.push(6, 7);

this.unshift(true, {});

// ["true", "[object Object]", "1", "2", "3", "4", "5", "6", "7"]
console.log(mkArray.toJSON());</code></pre><h5><p>Условная Модель</p></h5>
<pre class="prettyprint source lang-js"><code>this.mediateItem(function(item) {
	if(item.something) {
		return new FirstModel(item);
	} else {
		return new SecondModel(item);
	}
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-mediateItem" data-title="Метод Matreshka.Array-mediateItem">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-mediateItem"
  title="Метод Matreshka.Array-mediateItem"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-recreate" data-since="">
	<h2>
		<a href="#!Matreshka.Array-recreate">
			<span class="memberof">Matreshka.Array#</span>recreate<wbr>(<span class="args">array, eventOptions</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaArray">matreshkaArray</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Пересоздает экземпляр <a href="#!Matreshka.Array">Matreshka.Array</a></p></div>
	<div class="description"><p>Метод позволяет конвертировать любой массив (или объект, подобный массиву) в экземпляр <a href="#!Matreshka.Array">Matreshka.Array</a>. Если ничего не передано в качестве первого аргумента, экземпляр очищается.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaArray">matreshkaArray</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">recreate</span> <span class="event">modify</span> <span class="event">add</span> <span class="event">addone</span> <span class="event">remove</span> <span class="event">removeone</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						array
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="array">array</span>
</td>
					<td> Массив</td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> Объект события</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka.Array-trackBy">Matreshka.Array#trackBy</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>// очищаем массив и добавляем 5 новых элементов
this.recreate([1, 2, 3, 4, 5]);

// очищаем массив
this.recreate();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-recreate" data-title="Метод Matreshka.Array-recreate">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-recreate"
  title="Метод Matreshka.Array-recreate"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-restore" data-since="1.3">
	<h2>
		<a href="#!Matreshka.Array-restore">
			<span class="memberof">Matreshka.Array#</span>restore<wbr>(<span class="args">selector, eventOptions</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaArray">matreshkaArray</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Воссоздаёт <a href="#!Matreshka.Array">Matreshka.Array</a> из HTML узлов на странице.</p></div>
	<div class="description"><p>В случае, если коллекция заранее отрисована на странице (например, с помощью сервера), метод может воссоздать коллекцию из отрендеренных HTML узлов.</p>
<pre class="prettyprint source lang-html"><code>&lt;!-- One, Two, Three заранее отрисованы -->
&lt;ul class=&quot;collection-node&quot;>
    &lt;li>One&lt;/li>
    &lt;li>Two&lt;/li>
    &lt;li>Three&lt;/li>
    &lt;script type=&quot;text/html&quot; class=&quot;renderer&quot;>
        &lt;li>&lt;/li>
    &lt;/script>
&lt;/ul></code></pre><pre class="prettyprint source lang-js"><code>var MyModel = Class({
    'extends': MK.Object,
    constructor: function() {
        this.addDataLeys('value');
        this.set(data);
    },
    onRender: function() {
        this.bindNode('value', ':sandbox', MK.binders.html())
    }
});

var MyCollection = Class({
    'extends': MK.Array,
    itemRenderer: ':sandbox .renderer',
    constructor: function() {
        this
            .bindNode('sandbox', '.collection-node')
            .restore(':sandbox li');
    }
});

var myCollection = new MyCollection();
myCollection.push({
    value: 'Four'
});

console.log(myCollection.toJSON());
// [{value: 'One'}, {value: 'Two'}, {value: 'Three'}, {value: 'Four'}]</code></pre><p>Если аргумент <code>selector</code> не задан, то коллекция будет воссоздана из элементов, входящих в контейнер (<code>&quot;container&quot;</code> или <code>&quot;sandbox&quot;</code>).</p>
<p>При воссоздании, на каждом элементе массива генерируется событие <code>render</code> и вызываются методы <code>onRender</code> и <code>onItemRender</code> (см <a href="#!Matreshka.Array-onItemRender">документацию</a>), как и при <a href="#!Matreshka.Array-itemRenderer">обычном рендеринге</a>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaArray">matreshkaArray</span>

		 - self

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">recreate</span> <span class="event">modify</span> <span class="event">add</span> <span class="event">addone</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						selector
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="selector">selector</span>
</td>
					<td> Селектор</td>
				</tr>
			 
				<tr>
					<td>
						eventOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> Объект события</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.restore();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-restore" data-title="Метод Matreshka.Array-restore">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-restore"
  title="Метод Matreshka.Array-restore"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-toArray" data-since="">
	<h2>
		<a href="#!Matreshka.Array-toArray">
			<span class="memberof">Matreshka.Array#</span>toArray()
		</a> <span class="returns">→ 
	<span data-type="array">array</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Конвертирует <a href="#!Matreshka.Array">Matreshka.Array</a> в обычный массив, но не конвертирует входящие в него элементы</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="array">array</span>

		

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.toArray();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-toArray" data-title="Метод Matreshka.Array-toArray">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-toArray"
  title="Метод Matreshka.Array-toArray"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-toNative" data-since="">
	<h2>
		<a href="#!Matreshka.Array-toNative">
			<span class="memberof">Matreshka.Array#</span>toNative()
		</a> <span class="returns">→ 
	<span data-type="array">array</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Делает то же самое, что и <a href="#!Matreshka.Array-toArray">Matreshka.Array#toArray</a></p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="array">array</span>

		

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.toNative();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-toNative" data-title="Метод Matreshka.Array-toNative">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-toNative"
  title="Метод Matreshka.Array-toNative"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-rerender" data-since="0.3">
	<h2>
		<a href="#!Matreshka.Array-rerender">
			<span class="memberof">Matreshka.Array#</span>rerender<wbr>(<span class="args">options</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaArray">matreshkaArray</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Перерисовывает DOM узлы элементов, входящих в массив</p></div>
	<div class="description"><p>Этот метод заново рендерит элементы массива в контейнере массива. Если узел, который ассоциирован с элеменом масива уже создан, метод, вместо перерисовки с нуля, &quot;перевставляет&quot; его в контейнер или песочницу массива.</p>
<p>Метод может быть полезным на случай, когда элементы добавлены в массив перед объявлением песочницы или контейнера.</p>
<p>Начиная с версии 1.1, для того, чтоб заставить массив перерисоваться, независимо от наличия отрендеренных узлов (например, вы используете handlebars в <code>itemRenderer</code>), передайте в метод объект со свойством <code>forceRerender</code> равным <code>true</code>.</p></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaArray">matreshkaArray</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						options
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Объект с флагами (на сегодняшний день, единственный флаг - ``forceRerender``)</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.rerender({
	forceRerender: true
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-rerender" data-title="Метод Matreshka.Array-rerender">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-rerender"
  title="Метод Matreshka.Array-rerender"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-hasOwnProperty" data-since="">
	<h2>
		<a href="#!Matreshka.Array-hasOwnProperty">
			<span class="memberof">Matreshka.Array#</span>hasOwnProperty()
		</a> <span class="returns">→ 
	<span data-type="boolean">boolean</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Существует ли свойство в экземпляре (индекс или свойство <code>length</code>)</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="boolean">boolean</span>

		

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkArray = new MK.Array(42); // создает массив длиной 42

mkArray.hasOwnProperty(5); // true

mkArray.hasOwnProperty(100500); // false

mkArray.hasOwnProperty('length'); // true

mkArray.hasOwnProperty('blah'); // false</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-hasOwnProperty" data-title="Метод Matreshka.Array-hasOwnProperty">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-hasOwnProperty"
  title="Метод Matreshka.Array-hasOwnProperty"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-toJSON" data-since="">
	<h2>
		<a href="#!Matreshka.Array-toJSON">
			<span class="memberof">Matreshka.Array#</span>toJSON()
		</a> <span class="returns">→ 
	<span data-type="object">object</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Конвертирует экземпляр и элементы, входящие в него в обычный массив</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="object">object</span>

		

	</p>
	
	

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var data = this.toJSON();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-toJSON" data-title="Метод Matreshka.Array-toJSON">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-toJSON"
  title="Метод Matreshka.Array-toJSON"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-pull" data-since="0.1">
	<h2>
		<a href="#!Matreshka.Array-pull">
			<span class="memberof">Matreshka.Array#</span>pull<wbr>(<span class="args">index, evtOptions</span>)
				
		</a> <span class="returns">→ 
	<span data-type="*">*</span>

	<span data-type="null">null</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Удаляет элемент с заданным индексом из массива и возвращает этот элемент. Начиная с версии 0.3, метод поддерживает удаляемый элемент в качестве аргумента.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="*">*</span>

	<span data-type="null">null</span>

		 - Удаленный элемент или ``null``

	</p>
	
	
	<p>
		<b>Генерирует события</b> <span class="event">pull</span> <span class="event">remove</span> <span class="event">removeone</span> <span class="event">modify</span>

	</p>
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						index
						
					</td>
					 
					<td>
	<span data-type="string">string</span>

	<span data-type="number">number</span>

	<span data-type="*">*</span>
</td>
					<td> Индекс элемента, который нужно удалить (число или строка) либо сам удаляемый элемент (не являющийся ни числом ни строкой)</td>
				</tr>
			 
				<tr>
					<td>
						evtOptions
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="eventOptions">eventOptions</span>
</td>
					<td> Объект события на случай, если нужно передать в обработчик события какие-нибудь данные или установить флаг ``silent``, предотвращающий срабатывание события</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5><p>Передача индекса массива</p></h5>
<pre class="prettyprint source lang-js"><code>var removed;

this.recreate(['a', 'b', 'c']);

removed = this.pull(1);

alert(removed); // 'b'

alert(this.toString()); // 'a,c'</code></pre><h5><p>Передача удаляемого элемента</p></h5>
<pre class="prettyprint source lang-js"><code>var object1 = {},
	object2 = {},
	object3 = {},
	removed;

this.push(object1, object2, object3);

removed = this.pull(object2);

alert(removed === object2); // true

alert(this.length); // 2</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-pull" data-title="Метод Matreshka.Array-pull">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-pull"
  title="Метод Matreshka.Array-pull"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-each" data-since="">
	<h2>
		<a href="#!Matreshka.Array-each">
			<span class="memberof">Matreshka.Array#</span>each<wbr>(<span class="args">callback, thisArg</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaArray">matreshkaArray</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Работает точно так же, как и метод <code>forEach</code>, который перебирает элементы массива</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaArray">matreshkaArray</span>

		 - self

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						callback
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Функция, запускаемая на каждой итерации</td>
				</tr>
			 
				<tr>
					<td>
						thisArg
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> Объект, который используется в качестве ``this`` при вызове ``callback``</td>
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.each(function(item, index) {
	console.log(index, item);
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-each" data-title="Метод Matreshka.Array-each">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-each"
  title="Метод Matreshka.Array-each"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-METHOD" data-since="">
	<h2>
		<a href="#!Matreshka.Array-METHOD">
			<span class="memberof">Matreshka.Array#</span>METHOD()
		</a> 
		<i class="important" title="Важно"></i>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Любой метод из <code>Array.prototype</code></p></div>
	<div class="description"><p><a href="#!Matreshka.Array">Matreshka.Array</a> включает в себя все методы, входящие в нативный JavaScript массив:</p>
<p><ul>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank">concat</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join" target="_blank">join</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank">pop</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank">push</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank">reverse</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank">shift</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank">slice</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank">sort</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank">splice</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString"  target="_blank">toString</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank">unshift</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank">every</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank">filter</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank">forEach</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">indexOf</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf" target="_blank">lastIndexOf</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank">map</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank">some</a></li>
</ul>
При этом, они работают точно так же, как и методы <code>Array.prototype</code>. Есть лишь несколько оговорок:</p>
<ul>
<li>Метод <code>forEach</code> возвращает себя вместо <code>undefined</code></li>
<li>Методы, которые в оригинальном виде возвращают новый массив (<code>splice</code>, <code>slice</code>, <code>filter</code>, <code>map</code>...), в Матрешке возвращают новый экземпляр <code>Matreshka.Array</code>.</li>
</ul>
<p>Кроме всего, методы генерируют события связанные с любой модификацией массива. Подробнее см. <a href="#!Matreshka.Array">Matreshka.Array</a>.</p></div>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka.Array-_METHOD">Matreshka.Array#_METHOD</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.push(1, 2, 3);</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>var mapped = this
	.forEach(function(value, index) {
		//...
	})
	.map( function(value, index) {
		//...
	})
;
alert(mapped.isMKArray);</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.reverse();</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-METHOD" data-title="Метод Matreshka.Array-METHOD">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-METHOD"
  title="Метод Matreshka.Array-METHOD"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array-METHOD_" data-since="">
	<h2>
		<a href="#!Matreshka.Array-METHOD_">
			<span class="memberof">Matreshka.Array#</span>METHOD_()
		</a> 
		<i class="important" title="Важно"></i>
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Любой метод из <code>Array.prototype</code> с возможностью передать объект события</p></div>
	<div class="description"><p>Ознакомившись с <a href="#!Matreshka.Array-METHOD">Matreshka.Array#METHOD</a> становится понятно, что методы не поддерживают передачу объекта события, так как в точности повторяют синтаксис и количество аргументов встроенного <code>Array</code>. Синтаксис <code>МЕТОД_</code> позволяет передать в обработчик события какие-нибудь данные либо установить служебные флаги, отвечающие за поведение массива после вызова метода.</p>
<p>Список доступных флагов:</p>
<ul>
<li><code>silent: true</code> - отключает генерацию событий</li>
<li><code>dontRender: true</code> - отключает <a href="#!Matreshka.Array-itemRenderer">рендеринг</a></li>
<li><code>skipMediator: true</code> - отключает <a href="#!Matreshka.Array-mediateItem">медиаторы</a></li>
</ul></div>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="#!Matreshka.Array-METHOD">Matreshka.Array#METHOD</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>this.push_(1, 2, 3, {
    silent: true
});

this.pop_({
    silent: true
});</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>this.on('modify', function(evt) {
	alert(evt.flag); // 42
});

this.push_(1, 2, 3, {
	flag: 42
});</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array-METHOD_" data-title="Метод Matreshka.Array-METHOD_">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array-METHOD_"
  title="Метод Matreshka.Array-METHOD_"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

	
	
<article class="item method" id="!Matreshka.Array.from" data-since="1.1">
	<h2>
		<a href="#!Matreshka.Array.from">
			<span class="memberof">Matreshka.Array.</span>from<wbr>(<span class="args">arrayLike, mapFn, thisArg</span>)
				
		</a> <span class="returns">→ 
	<span data-type="matreshkaArray">matreshkaArray</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Метод создаёт новый экземпляр <a href="#!Matreshka.Array">Matreshka.Array</a> из массивоподобного объекта.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaArray">matreshkaArray</span>

		

	</p>
	
	

	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						arrayLike
						
					</td>
					 
					<td>
	<span data-type="object">object</span>
</td>
					<td> Массивоподобный объект.</td>
				</tr>
			 
				<tr>
					<td>
						mapFn
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="function">function</span>
</td>
					<td> Отображающая функция, вызываемая для каждого элемента массива.</td>
				</tr>
			 
				<tr>
					<td>
						thisArg
						
							<span class="signature">optional</span>
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> Объект, который используется в качестве ``this`` при вызове ``mapFn``</td>
				</tr>
			
		</tbody>
	</table>

	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank">Array.from</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkArray = MK.Array.from([1, 2, 3, 4]);</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>var mkArray = MK.Array.from([1, 2, 3, 4], function(item) {
	return item*2;
}, this);</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array.from" data-title="Метод Matreshka.Array.from">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array.from"
  title="Метод Matreshka.Array.from"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

<article class="item method" id="!Matreshka.Array.of" data-since="1.1">
	<h2>
		<a href="#!Matreshka.Array.of">
			<span class="memberof">Matreshka.Array.</span>of()
		</a> <span class="returns">→ 
	<span data-type="matreshkaArray">matreshkaArray</span>
</span>
		
		
		<span class="new-badge"></span>
	</h2>
	<div class="summary"><p>Метод Array.of() создаёт новый экземпляр <a href="#!Matreshka.Array">Matreshka.Array</a> из произвольного числа агрументов, вне зависимости от числа или типа аргумента.</p></div>
	<div class="description"></div>
	
	<p>
		<b>Возвращает</b> 
	<span data-type="matreshkaArray">matreshkaArray</span>

		

	</p>
	
	

	
	
<h4>Ссылки</h4>
<ul class="see">
	
		<li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/of" target="_blank">Array.of</a>
	
</ul>


	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var mkArray = MK.Array.of(1, 2, 3, 4);</code></pre>

	<!--<a href="//jsbin.com/iwovaj/74/embed?js,output">JSBIN</a>-->
	<a class="comments" data-id="Matreshka.Array.of" data-title="Метод Matreshka.Array.of">Задать вопрос<i></i></a>
<!--<div class="comments-container"></div>-->
<div class="comments-container"
  href="https://muut.com/i/matreshka/comments/matreshka-ru:Matreshka.Array.of"
  title="Метод Matreshka.Array.of"
  data-channel="Matreshka"
  data-show_online="false"
  data-upload="false"></div>
</article>

	
</section>



<section>

</section>
<section>

	
<article class="item typedef" data-typedef="eventHandler">
	<i class="close-modal"></i>
	<h2>
		eventHandler:
			<span data-type="function">function</span>
		
	</h2>
	
	<p>Функция-обработчик события. Принимает любые аргументы, переданные в <a href="#!Matreshka-trigger">Matreshka#trigger</a></p>
	
	<h4>Аргументы</h4>
	<table class="arguments">
		<thead>
			<tr>
				<th>Имя
				
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						options
						
					</td>
					 
					<td>
	<span data-type="*">*</span>
</td>
					<td> любые аргументы, переданные в вызов <a href="#!Matreshka-trigger">Matreshka#trigger</a> после имени собыия</td>
				</tr>
			
		</tbody>
	</table>

	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var eventHandler = function() {
	console.log(arguments); 
}
this.on('fyeah', eventHandler);
this.trigger('fyeah', 'foo', 'bar', 'baz'); // logs 'foo', 'bar', 'baz'</code></pre>
</article>


	
<article class="item typedef" data-typedef="matreshka">
	<i class="close-modal"></i>
	<h2>
		matreshka:
			<span data-type="object">object</span>
		
	</h2>
	
	<p>Экземпляр класса <a href="#!Matreshka">Matreshka</a></p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="matreshkaObject">
	<i class="close-modal"></i>
	<h2>
		matreshkaObject:
			<span data-type="object">object</span>
		
	</h2>
	
	<p>Экземпляр класса <a href="#!Matreshka.Object">Matreshka.Object</a></p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="matreshkaArray">
	<i class="close-modal"></i>
	<h2>
		matreshkaArray:
			<span data-type="object">object</span>
		
	</h2>
	
	<p>Экземпляр класса <a href="#!Matreshka.Array">Matreshka.Array</a></p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="balalaika">
	<i class="close-modal"></i>
	<h2>
		balalaika:
			<span data-type="array">array</span>
		
	</h2>
	
	<p>Коллекция <a href="#!$b">балалайки</a></p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="eventNames">
	<i class="close-modal"></i>
	<h2>
		eventNames:
			<span data-type="string">string</span>
		
	</h2>
	
	<p>Имя события или несколько имен, разделенных пробелами.</p>
<blockquote>
<p>Здесь представлен краткий список событий с небольшими примерами. Для получения полной информации, прочтите <a href="http://habrahabr.ru/company/matreshka/blog/267513/">эту статью на Хабре</a>.</p>
</blockquote>
<h5>Произвольные события</h5><pre class="prettyprint source lang-js"><code>this.on('myevent', function() {...});
this.trigger('myevent');</code></pre><h5><code>change:KEY</code>, вызывающееся, когда свойство меняется</h5><pre class="prettyprint source lang-js"><code>this.on('change:x', function(evt) {...});
this.x = 42;</code></pre><h5><code>beforechange:KEY</code>, вызывающееся перед изменением свойства</h5><pre class="prettyprint source lang-js"><code>this.on('beforechange:x', function(evt) {...});
this.x = 42;</code></pre><h5><code>bind:KEY</code> и <code>bind</code>, вызывающееся после связывания данных</h5><pre class="prettyprint source lang-js"><code>//для всех свойств
this.on('bind', function(evt) {...});
//для свойства &quot;x&quot;
this.on('bind:x', function(evt) {...});
this.bindNode('x', '.my-node');</code></pre><h5><code>delete:KEY</code> и <code>delete</code>, вызывающееся при удалении свойства</h5><pre class="prettyprint source lang-js"><code>//для всех свойств
this.on('delete', function(evt) {...});
//для свойства &quot;x&quot;
this.on('delete:x', function(evt) {...});
this.remove('x');</code></pre><h5><code>addevent:NAME</code> и <code>addevent</code>, вызывающееся при инициализации события</h5><pre class="prettyprint source lang-js"><code>//для всех событий
this.on('addevent', function(evt) {...});
//для события &quot;someevent&quot;
this.on('addevent:someevent', function(evt) {...});
//генерирует события &quot;addevent&quot; и &quot;addevent:someevent&quot;
this.on('someevent', function(evt) {...});</code></pre><h5><code>DOM_EVENT::KEY</code>, где DOM_EVENT - имя DOM события, KEY - ключ. Генерируется тогда, когда событие DOM_EVENT срабатывает на элементе, связанным с KEY.</h5><pre class="prettyprint source lang-js"><code>this.bindNode('x', '.my-div');
this.on('click::x', function(evt) {
    alert('clicked &quot;.my-div&quot;');
});</code></pre><h5><code>DOM_EVENT::KEY(SELECTOR)</code>, где DOM_EVENT - имя DOM события, KEY - ключ, SELECTOR - селектор.  Генерируется тогда, когда событие DOM_EVENT срабатывает на элементе, который соответствует селектору SELECTOR, и находится в элементе, который связан со свойством KEY.</h5><pre class="prettyprint source lang-html"><code>&lt;div class=&quot;my-div&quot;>
    &lt;button class=&quot;my-button&quot;>&lt;/button>
&lt;/div></code></pre><pre class="prettyprint source lang-js"><code>this.bindNode('x', '.my-div');
this.on('click::x(.my-button)', function(evt) {
    alert('clicked &quot;.my-button&quot;');
});</code></pre><h5><code>DOM_EVENT::(SELECTOR)</code>, где DOM_EVENT - имя DOM события, SELECTOR - селектор. Генерируется тогда, когда событие DOM_EVENT срабатывает на элементе, который соответствует селектору SELECTOR, и находится в песочнице текущего объекта.</h5><pre class="prettyprint source lang-js"><code>this.bindNode('sandbox', '.my-div');
this.on('click::(.my-button)', function(evt) {
    alert('clicked &quot;.my-button&quot;');
});</code></pre><p>То же самое, что и:</p>
<pre class="prettyprint source lang-js"><code>this.bindNode('sandbox', '.my-div');
this.on('click::sandbox(.my-button)', function(evt) {
    alert('clicked &quot;.my-button&quot;');
});</code></pre><h5>Делегированные события <code>PATH@EVENT</code>, где PATH - путь к объекту, события которого мы желаем прослушивать, EVENT - имя события.</h5><pre class="prettyprint source lang-js"><code>this.on('a@someevent', function() {...});
this.on('a.b.c@change:d', function() {...});</code></pre><p>При возникновении необходимости слушать изменения во всех элементах <a href="#!Matreshka.Array">Matreshka.Array</a> или во всех ключах, отвечающих за данные <a href="#!Matreshka.Object">Matreshka.Object</a>, вместо имени свойства можно указать звездочку &quot;*&quot;.</p>
<pre class="prettyprint source lang-js"><code>this.on('*@someevent', function() {...});
this.on('*.b.*.d@change:e', function() {...});</code></pre><h4>Всевозможные комбинации</h4><p>Все приведенные выше варианты синтаксиса можно комбинировать произвольным способом.</p>
<pre class="prettyprint source lang-js"><code>this.on('x.y.z@click::(.my-selector)', function() {...});</code></pre>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="binder">
	<i class="close-modal"></i>
	<h2>
		binder:
			<span data-type="object">object</span>
		
	</h2>
	
	<p><code>binder</code> (байндер, привязчик) содержит всю информацию о том, как синхронизировать значение свойства с привязанным к нему DOM элементом. Для всех методов байндера контекст (<code>this</code>) - соответствующий DOM узел.</p>
	
	
	<h4>Свойства</h4>
	<table class="properties">
		<thead>
			<tr>
				<th>Имя
				<th>Тип
				<th>Описание
			</tr>
		</thead>
		<tbody>
			 
				<tr>
					<td>
						on
						
							<span class="signature">optional</span>
						
					<td>
	<span data-type="string">string</span>

	<span data-type="function">function</span>

					<td>DOM событие (или список событий, разделенных пробелами), после срабатывания которого извлекается состояние DOM элемента и устанавливается свойство. Кроме этого, значением свойства может быть функция, которая устанавливает обработчик произвольным образом.
				</tr>
			 
				<tr>
					<td>
						getValue
						
							<span class="signature">optional</span>
						
					<td>
	<span data-type="function">function</span>

					<td>Функция, которая отвечает за то, как извлечь значение (или "состояние") DOM элемента
				</tr>
			 
				<tr>
					<td>
						setValue
						
							<span class="signature">optional</span>
						
					<td>
	<span data-type="function">function</span>

					<td>Функция, которая отвечает за то, как установить значение свойства DOM элементу
				</tr>
			 
				<tr>
					<td>
						initialize
						
							<span class="signature">optional</span>
						
					<td>
	<span data-type="function">function</span>

					<td>Функция, которая запускается при инициализации привязки. Например, может быть использована для инициализации jQuery плагина.
				</tr>
			
		</tbody>
	</table>

	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var binder = {
	on: 'click',
	getValue: function(options) {
		return this.value;
	} 
	setValue: function(v, options) {
		this.value = v;
	},
	initialize: function(options) {
		alert('Binder is initialized. Initial input value=' + this.value);
	}
};

this.bindNode('a', '.my-checkbox', binder);</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>var binder = {
	on: function(callback) {
		this.onclick = callback;
	},
	getValue: function(options) {
		return this.value;
	} 
	setValue: function(v, options) {
		this.value = v;
	},
	initialize: function(options) {
		alert('Binder is initialized. Initial input value=' + this.value);
	}
};

this.bindNode('a', '.my-checkbox', binder);</code></pre>
</article>


	
<article class="item typedef" data-typedef="eventOptions">
	<i class="close-modal"></i>
	<h2>
		eventOptions:
			<span data-type="object">object</span>
		
	</h2>
	
	<p>Это обычный объект, которй может содержать служебные флаги или произвольные данные, которые попадут в обработчик события</p>
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var eventOptions = {silent: true};

this.a = 1;

this.on('change:a', function() {
	alert('a is changed');
});

this.set('a', 2, eventOptions); // no alert</code></pre><h5></h5>
<pre class="prettyprint source lang-js"><code>var eventOptions = {f: 'yeah'};

this.a = 1;

this.on('change:a', function(eventOptions) {
	alert(eventOptions.f);
});

this.set('a', 2, eventOptions); // alerts "yeah"</code></pre>
</article>


	
<article class="item typedef" data-typedef="class">
	<i class="close-modal"></i>
	<h2>
		class:
			<span data-type="function">function</span>
		
	</h2>
	
	<p>Класс (точнее, конструктор класса) возвращаемый функцией <a href="#!Class">Class</a></p>
	
	
	

	 
	<h4>Примеры</h4>
  
<h5></h5>
<pre class="prettyprint source lang-js"><code>var MyClass = Class({
	method: function() { ... }
});</code></pre>
</article>


	
<article class="item typedef" data-typedef="node">
	<i class="close-modal"></i>
	<h2>
		node
	</h2>
	
	<p>DOM узел</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="$nodes">
	<i class="close-modal"></i>
	<h2>
		$nodes
	</h2>
	
	<p>Коллекция DOM узлов. Например, jQuery-элемент(ы)</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="string">
	<i class="close-modal"></i>
	<h2>
		string
	</h2>
	
	<p>Строка</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="boolean">
	<i class="close-modal"></i>
	<h2>
		boolean
	</h2>
	
	<p>Логический тип</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="number">
	<i class="close-modal"></i>
	<h2>
		number
	</h2>
	
	<p>Число</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="object">
	<i class="close-modal"></i>
	<h2>
		object
	</h2>
	
	<p>Объект</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="array">
	<i class="close-modal"></i>
	<h2>
		array
	</h2>
	
	<p>Массив</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="function">
	<i class="close-modal"></i>
	<h2>
		function
	</h2>
	
	<p>Функция</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="null">
	<i class="close-modal"></i>
	<h2>
		null
	</h2>
	
	<p>null</p>
	
	
	

	  

</article>


	
<article class="item typedef" data-typedef="*">
	<i class="close-modal"></i>
	<h2>
		*
	</h2>
	
	<p>Любой тип</p>
	
	
	

	  

</article>


</section>
<section>
<article id="!matreshka-magic" data-since="1.1"><h2><a href="#!matreshka-magic">MatreshkaMagic</a></h2><p>Некоторые разработчики не нуждаются в богатом функционале Матрешки, но хотят пользоваться потрясающими утилитами, имеющимися во фреймворке. Поэтому, было решено создать новую, компактную библиотеку, которая называется <strong>MatreshkaMagic</strong>. Библиотека не включает в себя классы (<a href="#!Matreshka">Matreshka</a>, <a href="#!Matreshka.Object">Matreshka.Object</a>, <a href="#!Matreshka.Array">Matreshka.Array</a> и функцию <a href="#!Class">Class</a>), но содержит все статичные методы и свойства класса <a href="#!Matreshka">Matreshka</a>:</p>
<ul>
<li><a href="#!Matreshka.on">Matreshka.on</a></li>
<li><a href="#!Matreshka.once">Matreshka.once</a></li>
<li><a href="#!Matreshka.onDebounce">Matreshka.onDebounce</a></li>
<li><a href="#!Matreshka.mediate">Matreshka.mediate</a></li>
<li><a href="#!Matreshka.setClassFor">Matreshka.setClassFor</a></li>
<li><a href="#!Matreshka.linkProps">Matreshka.linkProps</a></li>
<li><a href="#!Matreshka.off">Matreshka.off</a></li>
<li><a href="#!Matreshka.trigger">Matreshka.trigger</a></li>
<li><a href="#!Matreshka.bindNode">Matreshka.bindNode</a></li>
<li><a href="#!Matreshka.bindOptionalNode">Matreshka.bindOptionalNode</a></li>
<li><a href="#!Matreshka.unbindNode">Matreshka.unbindNode</a></li>
<li><a href="#!Matreshka.selectAll">Matreshka.selectAll</a></li>
<li><a href="#!Matreshka.select">Matreshka.select</a></li>
<li><a href="#!Matreshka.boundAll">Matreshka.boundAll</a></li>
<li><a href="#!Matreshka.$bound">Matreshka.$bound</a></li>
<li><a href="#!Matreshka.bound">Matreshka.bound</a></li>
<li><a href="#!Matreshka.get">Matreshka.get</a></li>
<li><a href="#!Matreshka.set">Matreshka.set</a></li>
<li><a href="#!Matreshka.parseBindings">Matreshka.parseBindings</a></li>
<li><a href="#!Matreshka.remove">Matreshka.remove</a></li>
<li><a href="#!Matreshka.define">Matreshka.define</a></li>
<li><a href="#!Matreshka.defineGetter">Matreshka.defineGetter</a></li>
<li><a href="#!Matreshka.defineSetter">Matreshka.defineSetter</a></li>
<li><a href="#!Matreshka.trim">Matreshka.trim</a></li>
<li><a href="#!Matreshka.toArray">Matreshka.toArray</a></li>
<li><a href="#!Matreshka.extend">Matreshka.extend</a></li>
<li><a href="#!Matreshka.each">Matreshka.each</a></li>
<li><a href="#!Matreshka.randomString">Matreshka.randomString</a></li>
<li><a href="#!Matreshka.binders">Matreshka.binders</a></li>
<li><a href="#!Matreshka.defaultBinders">Matreshka.defaultBinders</a></li>
<li><a href="#!Matreshka.lookForBinder">Matreshka.lookForBinder</a></li>
<li><a href="#!Matreshka.debounce">Matreshka.debounce</a></li>
<li><a href="#!Matreshka.noop">Matreshka.noop</a></li>
<li><a href="#!Matreshka.$(static)">Matreshka.$</a></li>
<li><a href="#!Matreshka.$b">Matreshka.$b</a></li>
<li><a href="#!Matreshka.useAs$">Matreshka.useAs$</a></li>
<li><a href="#!Matreshka.version">Matreshka.version</a></li>
</ul>
<p>Библиотека находится в папке <code>/magic/</code> репозитория на <a href="https://github.com/finom/matreshka">github</a>. Подключив скрипт с помощью тега <code>script</code>, программисту доступна глобальная переменная <code>MatreshkaMagic</code> и её краткий вариант <code>magic</code>. Переменная - это обычный объект с методами.</p>
<pre class="prettyprint source lang-html"><code>&lt;script src="magic/matreshka-magic.min.js">&lt;/script></code></pre><pre class="prettyprint source lang-js"><code>var object = {};
magic.bindNode(object, 'x', '.my-node');
magic.linkProps(object, 'y', 'x z', function(x, z) {
    return x + z;
});
magic.mediate(object, 'z', Number);
// и т. д.</code></pre><p>При использовании AMD или CJS, глобальные переменные не создаются:</p>
<pre class="prettyprint source lang-js"><code>require(['magic/matreshka-magic.min'], function(magic) {
    //...
});</code></pre><pre class="prettyprint source lang-js"><code>var magic = require('magic/matreshka-magic.min');</code></pre><p>На момент написания этой документации, файл <strong>matreshka-magic.min.js</strong> занимает чуть меньше 30КБ в несжатом виде против 46КБ <strong>matreshka.min.js</strong>. Если на каком-то этапе потребуется подключить весь фреймворк в проект, нужно лишь изменить пути к файлу скрипта и поменять имена переменных с <code>magic</code> или <code>MatreshkaMagic</code> на <code>MK</code> или <code>Matreshka</code> (второе обязательно только в том случае, если вы не используете AMD или CJS в проекте).</p>
<p>Обратите внимание. Фреймворк Матрешка работает в Internet Explorer 8 благодаря хакам, возвращающим из конструктора объект <code>XDomainRequest</code>, вместо "чистого" JavaScript объекта. Так как MatreshkaMagic позволяет работать исключительно с произвольными объектами, поддeржка IE8 для MatreshkaMagic невозможна. Это значит, библиотека работает везде, включая IE9+.</p></article><article id="!10-reasons"><h2><a href="#!10-reasons">10 причин попробовать Матрешку</a></h2><h3>1. Чистый JavaScript и HTML</h3><p>Многие фреймворки пытаются починить веб, создавая собственный язык программирования. Идея Матрешки проста: с вебом всё в порядке. Вся логика, которую пишет программист, находится, как и должна, в JavaScript файлах, а HTML остаётся языком разметки гипертекста. Шутка об HTML программисте должна остаться шуткой.</p>
<h3>2. Минимум сущностей</h3><p>Матрешка не требует создания избыточных сущностей. Благодаря простому синтаксису привязок, связь между JavaScript и HTML может быть описана там же, где и логика. Программисту не требуется задумываться сразу о нескольких вещах, размышляя о балансе полномочий объектов. Вопрос где прописать обработчик: во “вьюхе” или в контроллере отпадает сам по себе. Хотя, никто не запрещает разделить данные и контроллер, разместив их в разных JS файлах.</p>
<h3>3. Работай с данными, забудь о представлении</h3><p>Попробовав популярный (но уступающий под натиском более современных продуктов) фреймворк Backbone, сталкиваешься с серьезным неудобством: объявляя данные, зависящие от UI и UI, зависящий от данных, вам, как правило, требуется создать два обработчика события. Один ловит изменения данных, второй ловит пользовательские действия. Проблема подкрепляется еще тем, что HTML элементы, как правило, совершенно идентичны в рамках operaприложения: <code>input</code>, <code>select</code>, кастомные виджеты из jQuery UI могут многократно встречаться на странице. Программисту, который реализует еще одну “единицу” приложения (например, форму), приходится пользоваться “копи-пастой”.</p>
<p>С Матрешкой всё намного проще. Вам нужно лишь однажды объявить привязку (в одном месте, а не в двух), затем работать с данными (как с обычными JavaScript объектами), забыв, что у нас вообще есть представление.</p>
<h3>4. Гибкость</h3><p>Новичку часто непонятно, как перейти на новую архитектуру. Порой, для того, чтоб добавить сторонний виджет, нужно приложить немало усилий, изучая адаптеры, директивы и т. п…</p>
<p>Задавшись вопросом, как прикрутить тот или иной скрипт (например, какой-нибудь jQuery плагин), верным ответом будет, в том числе, «сделаю как знаю». Вывод какого-нибудь виджета, будь то Google Maps или одна из многочисленных галерей, делается так, как указано в официальной документации к виджету. Не надо больше искать в интернете  директивы (которых может и не быть), плагины и пр.</p>
<h3>5. Ненавязчивая архитектура</h3><p>Большинство популярных фреймворков закладывают принципы структурирования кода, ограничивая творчество программиста, как архитектора ПО. Это не всегда плохо, хотя часто задаешься вопросом «а почему нужно делать именно так»?..</p>
<p>Матрешка не заставляет использовать определенную структуру проекта, и не принуждает пользоваться хорошими, но, возможно, не самыми удачными решениями. Вы сами выбираете паттерны проектирования и структурирования приложения. Хоть Матрешка и позиционируется, как фреймворк, но, скорее, это библиотека, уменьшающая объем предстоящей работы.</p>
<h3>6. Меньше кода</h3><p>Самая главная задача, которая ставилась при разработке фреймворка — решение максимально большого круга задач (в разумных пределах). Поэтому, результирующий код, как правило, выглядит достаточно компактно, особенно, если пользоваться ECMAScript 2015/7.</p>
<h3>7. Легко понять, что происходит</h3><p>Из-за ненавязчивости рекомендаций и отсутствии жесткого регламентирования любой, кто не знаком с фреймворком, но хорошо знает JavaScript, скорее всего, разберется в вашем коде (если вы, конечно, сами хороший программист :). При создании методов, одним из важных приоритетов была очевидность их функциональности.</p>
<h3>8. Легко начать</h3><p>Для того, чтоб начать работать с Матрешкой, нужно всего лишь знать назначение трех классов и нескольких методов. Остальное — синтаксических сахар. В документации они помечены красным флажком, чтоб было легче ориентироваться.</p>
<h3>9. Высокая производительность</h3><p>На это есть две причины:</p>
<p>1) Благодаря использованию акцессоров в качестве "слушателя" данных Матрешка сильно выигрывает у фреймворков, использующих другие подходы (например, dirty-checking).</p>
<p>2) Матрешка напрямую меняет DOM и, при увеличении количества байндингов, скорость приложения уменьшается по линейному закону. Этот способ взаимодействия с элементами на странице ставится в противоположность решений на основе "посредников" между объектной моделью документа и данными. Во фреймворках, использующих так называемый "virtual DOM", при большом количестве элементов (например, при рендеринге коллекций), скорость падает по экспоненте, отбирая у разработчика возможность работы с большими массивами данных.</p>
<h3>10. Поддержка синтаксиса ECMAScript 2015</h3><p>Поддержка JavaScript следующего поколения является одной из самых приоритетных задач. На сегодняшний день, Матрешка, кроме основных возможностей ECMAScript 2015/7, поддерживает классы и циклы <code>for..of</code>. В дальнейшем, при развитии языка ES, новые возможности будут добавляться в первую очередь.</p></article><article id="!whats-new"><h2><a href="#!whats-new">Что нового?</a></h2><p>Не забывайте голосовать за новые возможности в <a href="https://trello.com/b/E5KcQESk/matreshka-js-features">trello</a>.</p>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.3.2">Матрешка 1.3.2</a></h3><ul>
<li>Устранена проблема "Cannot find module 'matreshka'" при использовании Browserify.</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.3.1">Матрешка 1.3.1</a></h3><ul>
<li>Исправлена проблема импорта AMD модуля при использовании SystemJS Builder.</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.3.0">Матрешка 1.3.0</a></h3><ul>
<li>Новый метод  <a href="#!Matreshka.Array-restore">Matreshka.Array#restore</a></li>
<li>Некоторые байндеры из <a href="#!Matreshka.binders">Matreshka.binders</a> переименованы (старые названия будут по-прежнему работать)<ul>
<li><code>innerHTML</code> -&gt; <a href="#!Matreshka.binders.html">html</a></li>
<li><code>innerText</code> -&gt; <a href="#!Matreshka.binders.text">text</a></li>
<li><code>property</code> -&gt; <a href="#!Matreshka.binders.prop">prop</a></li>
<li><code>attribute</code> -&gt; <a href="#!Matreshka.binders.attr">attr</a></li>
</ul>
</li>
<li>Байндеры <code>html</code> и <code>text</code> поддерживают двустороннее связывание при использовании атрибута <code>"contenteditable"</code>.</li>
<li>Новые события <code>"removeevent"</code> и <code>"removeevent:NAME"</code>, вызывающиеся при удалении события.</li>
<li><a href="#!Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a> не обязательно должен быть валидным HTML элементом. Теперь, если HTML строка содержит несколько узлов (HTML или текстовых), она оборачивается в <code>span</code>.</li>
<li>Балалайка поддерживает любые объекты, а не только DOM узлы.</li>
<li>Изменения в способе подключения исходника Матрешки при помощи AMD.</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.2.0">Матрешка 1.2.0</a></h3><ul>
<li>Добавлено виртуальное свойство <a href="#!Matreshka.Array-trackBy">Matreshka.Array#trackBy</a></li>
<li>Исправлена ошибка в <a href="#!Matreshka.to">Matreshka.to</a></li>
<li>Кастомные селекторы при глубоком связывании работали некорректно</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.1.2">Матрешка 1.1.2</a></h3><ul>
<li>Улучшена производительность кастомных селекторов (<code>:bound(KEY)</code> и <code>:sandbox</code>)</li>
<li>Восстановлен <a href="#!Matreshka-parseBindings">Matreshka#parseBindings</a></li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.1.1">Матрешка 1.1.1</a></h3><ul>
<li>Поддержка Матрешкой Opera Mini за счет включения <code>oMatchesSelector</code> для Балалайки</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.1.0">Матрешка 1.1.0</a></h3><ul>
<li>Упрощенная проверка версии Internet Explorer: используется <code>documentMode</code> вместо useragent.</li>
<li>Улучшена производительность <a href="#!Matreshka-parseBindings">Matreshka#parseBindings</a> и исправлена ошибка для старых WebKit.</li>
<li>"Глубокие ссылки" для метода <a href="#!Matreshka-linkProps">Matreshka#linkProps</a>.</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.1.0-rc3">Матрешка 1.1.0 RC3</a></h3><ul>
<li>Исправлена ошибка в <code>setClassFor</code>, возникающая в Internet Explorer 8.</li>
<li>Небольшая оптимизация метода <code>off</code>.</li>
<li>Восстановлен байндер <code>innerText</code>.</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.1.0-rc2">Матрешка 1.1.0 RC2</a></h3><ul>
<li>Исправлены некоторые ошибки, возникающие в Internet Explorer 8.</li>
<li>Небольшая оптимизация метода <code>on</code>.</li>
<li>Убраны неиспользующиеся псевдо-приватные методы.</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.1.0-rc">Матрешка 1.1.0 RC</a></h3><h4>Новые методы и свойства</h4><ul>
<li>Статичные методы, работающие с любым объектом (полный список методов можно увидеть <a href="#!matreshka-magic">здесь</a>)</li>
<li>Свойства <a href="#!Matreshka-nodes">Matreshka#nodes</a> и <a href="#!Matreshka-$nodes">Matreshka#$nodes</a></li>
<li>Метод <a href="#!Matreshka-setClassFor">Matreshka#setClassFor</a></li>
<li>Статичный метод  <a href="#!Matreshka.to">Matreshka.to</a></li>
<li>Метод <a href="#!Matreshka.trim">Matreshka.trim</a></li>
<li>Метод <a href="#!Matreshka.toArray">Matreshka.toArray</a></li>
<li>Простой шаблонизатор <a href="#!Matreshka-parseBindings">Matreshka#parseBindings</a>.</li>
<li>Новые байндеры<ul>
<li><a href="#!Matreshka.binders.progress">progress</a></li>
<li><a href="#!Matreshka.binders.innerText">innerText</a></li>
<li><a href="#!Matreshka.binders.style">style</a></li>
<li><a href="#!Matreshka.binders.dataset">dataset</a></li>
<li><a href="#!Matreshka.binders.file">file</a></li>
</ul>
</li>
<li>Статичные методы  <a href="#!Matreshka.Array.of">Matreshka.Array.of</a> и <a href="#!Matreshka.Array.from">Matreshka.Array.from</a></li>
<li>Новый виртуальный метод <a href="#!Matreshka.Array-onItemRender">Matreshka.Array#onItemRender</a> и его альтернатива <code>onRender</code> для элементов, входящих в массив.</li>
</ul>
<h4>Расширение функционала Матрешки</h4><ul>
<li>"Глубокое связывание", позволяющее связать элемент со свойством, находящемся где-то в глубине дерева объектов.<pre class="prettyprint source lang-js"><code>this.bindNode('a.b.c.d', '.my-node');</code></pre></li>
<li>Изменение синтаксиса делегированных событий и реализация совместимости со старыми приложениями.<pre class="prettyprint source lang-js"><code>this.on('a.b.*.*.e@someevent', f);</code></pre></li>
<li>Дополнительный синтаксис  <a href="#!Matreshka-bindNode">Matreshka#bindNode</a><pre class="prettyprint source lang-js"><code>this.bindNode({
  x: '.my-x-node',
  y: ['.my-y-node', MK.binders.className()],
  z: ['.my-z-node', {
      setValue: function(v) {...}
  }]
})</code></pre></li>
<li>Новые вариации методов <a href="#!Matreshka-on">Matreshka#on</a>, <a href="#!Matreshka-once">Matreshka#once</a>, <a href="#!Matreshka-onDebounce">Matreshka#onDebounce</a>, позволяющие передать объект событие-обработчик.</li>
<li>Улучшенный багрепорт в случае, если нода не найдена при использовании <a href="#!Matreshka-bindNode">Matreshka#bindNode</a>. В тексте ошибки теперь видно селектор, а не только ключ.</li>
<li><code>getValue</code> для старых байндеров (для получения значения ноды в момент привязки).<ul>
<li><a href="#!Matreshka.binders.innerHTML">innerHTML</a></li>
<li><a href="#!Matreshka.binders.className">className</a></li>
<li><a href="#!Matreshka.binders.property">property</a></li>
<li><a href="#!Matreshka.binders.attribute">attribute</a></li>
</ul>
</li>
</ul>
<ul>
<li>Флаг <code>forceRerender</code> для <a href="#!Matreshka.Array-rerender">Matreshka.Array#rerender</a>.</li>
<li>Рендеринг любых объектов в <a href="#!Matreshka.Array">Matreshka.Array</a>.</li>
<li>Включение шаблонизатора для  <a href="#!Matreshka.Array-renderer">Matreshka.Array#renderer</a> по умолчанию.</li>
<li>Возможность создавать DOM дерево произвольной вложенности с помощью функции <a href="#!$b">$b.create</a>.</li>
<li>Возврат <code>this</code> из всех конструкторов для красивого цепочечного вызова после <code>super</code> в ECMAScript 2015.<pre class="prettyprint source lang-js"><code>class X extends Matreshka.Array {
  constructor(data) {
      super(...data).bindNode(/*...*/);
  }
}</code></pre></li>
</ul>
<h4>События</h4><ul>
<li>Новые события: <code>beforechange</code> и <code>beforechange:KEY</code>, вызывающиеся перед изменением свойства.</li>
<li>Новые события: <code>addevent</code> и <code>addevent:NAME</code> для отслеживания добавления новых событий.</li>
</ul>
<h4>Исправления</h4><ul>
<li><a href="#!Matreshka.Object#jset">Matreshka.Object#jset</a> не генерирует исключение, если передан <code>null</code>.</li>
<li>Исправлена ошибка зацикливания <a href="#!Matreshka-linkProps">Matreshka#linkProps</a> в некоторых специфичных случаях.</li>
<li>Исправлен кейс, когда флаг <code>forceHTML</code> не срабатывал в методе <a href="#!Matreshka-set">Matreshka.#set</a></li>
<li>Исправлен баг в методе <a href="#!Matreshka.Array-METHOD">Matreshka.Array#concat</a>.</li>
<li>Исправление небольшого бага для старых WebKit браузеров при использовании шаблонизатора.</li>
<li>Исправлен баг в MacOS, появляющися при использовании <a href="#!Matreshka-mediate">Matreshka#mediate</a>.</li>
<li>Рендерить массивы, даже если в модифицирующий метод передан <code>silent: true</code>.</li>
<li>Мелкие исправления.</li>
</ul>
<h4>Другие новости</h4><ul>
<li>Объекты, использующиеся Матрешкой получают свойство <code>Symbol(matreshka)</code> вместо <code>__events</code>, <code>__special</code> и <code>__id</code>.</li>
<li>Добавлены автоматические тесты (на текущий момент, 145 штук).</li>
<li>Исходный код разбит на мелкие кусочки.</li>
<li>Многократное увеличение производительности фреймворка. В некоторых местах производительность улучшена в 40 (!) раз.</li>
<li>Библиотека <a href="#!matreshka-magic">MatreshkaMagic</a>.</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.0.7">Матрешка 1.0.7</a></h3><ul>
<li>Устранена ошибка в MacOS, возникающая при использовании <a href="#!Matreshka-mediate">Matreshka#mediate</a></li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.0.6">Матрешка 1.0.6</a></h3><ul>
<li>Устранена проблема работы AMD в минифицированной версии</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.0.5">Матрешка 1.0.5</a></h3><ul>
<li>Исправлен баг: не работает байндинг при автозаполнении, когда текст вводится руками, а браузер выдаёт подсказки</li>
<li>Теперь ловится событие <code>input</code> вместо <code>paste</code> + <code>change</code> в байндерах <code>input</code> и <code>textarea</code> (кроме IE8)</li>
<li><code>setValue</code> теперь вызывается при нестрогом неравенстве (вместо строгого). Этим исправлением убрана проблема перепрыгивания курсора в конец строки при использовании <a href="#!Matreshka-mediate">Matreshka#mediate</a>.</li>
<li><a href="#!Matreshka.version">Matreshka.version</a> обновляется автоматически при сборке</li>
<li>Исправлен баг: отвязанные элементы можно было получить из <code>$bound</code>/<code>bound</code>, <code>select</code>/<code>$</code></li>
<li>Небольшой рефакторинг</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.0.4">Матрешка 1.0.4</a></h3><ul>
<li>Исправлена ошибка рендеринга, связанная с удалением элементов <a href="#!Matreshka.Array">Matreshka.Array</a>.</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.0.3">Матрешка 1.0.3</a></h3><ul>
<li>Исправлена ошибка <a href="#!Matreshka.binders.select">Matreshka.binders.select</a>, возникающая при использовании аргумента <code>multiple</code></li>
<li>Серьезная оптимизация скорости большинства методов <a href="#!Matreshka.Array">Matreshka.Array</a></li>
<li>Исправлены неочевидные ошибки рендеринга <a href="#!Matreshka.Array">Matreshka.Array</a></li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.0.2">Матрешка 1.0.2</a></h3><ul>
<li>Исправлены ошибки <a href="#!Matreshka.Array">Matreshka.Array</a> для Internet Explorer 8</li>
<li>Небольшая оптимизация методов <a href="#!Matreshka.Array">Matreshka.Array</a></li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.0.1">Матрешка 1.0.1</a></h3><ul>
<li>Серьезная оптимизация скорости всех методов <a href="#!Matreshka.Array">Matreshka.Array</a></li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v1.0.0">Матрешка 1.0</a></h3><ul>
<li>Убраны предупреждения об использовании устаревших методов и событий, очищен код</li>
<li>Несколько небольших исправлений</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v0.4.1">Матрешка 0.4.1</a></h3><ul>
<li>Устранена проблема со сборкой</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v0.4.0">Матрешка 0.4</a></h3><ul>
<li>Исправлена небольшая ошибка при работе с Babel</li>
<li>Все файлы проекта теперь используют строгий режим</li>
<li>Новое свойство <a href="#!Matreshka-sandbox">Matreshka#sandbox</a></li>
<li>Новое свойство <a href="#!Matreshka-$sandbox">Matreshka#$sandbox</a></li>
<li>Ключ <code>value</code> объекта события</li>
<li>Ключ <code>element</code> объекта события переименован в <code>node</code></li>
<li>Ключ <code>elements</code> объекта события переименован в <code>$nodes</code></li>
<li>Ключ <code>fromElement</code> объекта события переименован в <code>fromNode</code></li>
<li>Ключ <code>originaEvent</code> для объекта события, содержащее оригинальное DOM событие в случае использования jQuery</li>
<li>Опция <code>moveSandbox</code> для <code>MK.Array</code></li>
<li>Другие небольшие исправления</li>
</ul>
<h3><a href="https://github.com/finom/matreshka/releases/tag/v0.3.0">Матрешка 0.3</a></h3><p><strong>Новые возможности</strong></p>
<ul>
<li>Метод <a href="#!Matreshka.randomString">Matreshka.randomString</a></li>
<li>Метод <a href="#!Matreshka-onDebounce">Matreshka#onDebounce</a></li>
<li>Метод <a href="#!Matreshka-bindOptionalNode">Matreshka#bindOptionalNode</a></li>
<li>Метод <a href="#!Matreshka-delay">Matreshka#delay</a></li>
<li>Методы <code>Matreshka.Array</code>, позволяющие передать объект события (<code>push_</code>, <code>sort_</code>, <code>splice_</code>...). См. <a href="#!Matreshka.Array-METHOD_">Matreshka.Array#METHOD_</a></li>
<li>Свойство <a href="#!Matreshka.version">Matreshka.version</a></li>
<li>Новый односторонний байндер <a href="#!Matreshka.binders.visibility">Matreshka.binders.visibility</a></li>
<li>Свойство <code>on</code> у привязчика может быть функцией</li>
<li>Добавлен флаг <code>skipMediator</code> для методов <code>Matreshka.Array</code></li>
<li>Переопределение <a href="#!Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a> свойством <code>renderer</code> дочернего элемента</li>
<li>Свойство <a href="#!Matreshka.Array-renderIfPossible">Matreshka.Array#renderIfPossible</a></li>
<li>Функция <a href="#!Matreshka.lookForBinder">Matreshka.lookForBinder</a> теперь статичный метод класса <a href="#!Matreshka">Matreshka</a></li>
<li>Для привязки песочницы теперь используется ключ <code>sandbox</code> вместо <code>__this__</code></li>
<li>События <code>addone</code> и <code>removeone</code> для <a href="#!Matreshka.Array">Matreshka.Array</a></li>
<li><a href="#!Matreshka.Array-push">Matreshka.Array#push</a> и <a href="#!Matreshka.Array-unshift">Matreshka.Array#unshift</a> теперь возвращают длину массива вместо себя (как и в нативном массиве)</li>
<li>Реализованы привязчики для всех HTML5 элементов формы</li>
<li>Новые служебные флаги для метода  <a href="#!Matreshka-set">Matreshka#set</a>: <code>silentHTML</code>, <code>skipLinks</code></li>
<li><a href="#!Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a> теперь поддерживает строку, как значение</li>
<li>Добавлен ключ <code>self</code> для всех событий <code>Matreshka.Array</code></li>
<li>Можно менять <a href="#!Matreshka.Array-Model">Matreshka.Array#Model</a> динамически</li>
<li>Вызывать событие <code>change</code>, если при привязке Матрешка меняет значение свойства на состояние элемента (если свойство не определено и не передан флаг <code>assignDefaultValue: false</code>)</li>
<li>Новые селекторы: <code>:sandbox</code> и <code>:bound(KEY)</code></li>
<li>Поддержка свойства <code>attributes</code> для функции <code>Balalaika.create</code></li>
<li>Экспериментальный шаблонизатор для <a href="#!Matreshka.Array-itemRenderer">Matreshka.Array#itemRenderer</a> если <a href="#!Matreshka.Array-useBindingsParser">Matreshka.Array#useBindingsParser</a> установлен, как <code>true</code></li>
<li>Перенесены все привязчики в объект <a href="#!Matreshka.binders">Matreshka.binders</a></li>
<li><a href="#!Matreshka.Array-pull">Matreshka.Array#pull</a> теперь поддерживает объект в качестве аргумента</li>
<li>Короткая запись для делегированных событий DOM внутри песочницы (click::(.selector) вместо click::sandbox(.selector))</li>
<li>Поддержка цикла <code>for..of</code> для <a href="#!Matreshka.Array">Matreshka.Array</a> и <a href="#!Matreshka.Object">Matreshka.Object</a></li>
<li>Свойство <code>domEvent</code> содержащее объект события для событий DOM</li>
<li>Делегированные DOM события (<code>this.on( 'click::something(.x &gt; .y)' )</code>)</li>
</ul>
<p><strong>Устаревшие методы и события</strong></p>
<ul>
<li>Все методы, имя которых начинается с <code>silent</code> (<code>silentPush</code>, <code>silentSplice</code>, <code>silentSort</code> ...) удалены. Для этих целей теперь используются методы с нижним подчеркиванием в конце имени и флагом <code>silent</code> (например, <code>this.push_(1,2,3, {silent: true})</code>)</li>
<li>Метод <code>Matreshka#initMK</code> удален, теперь используется ленивая инициализация</li>
<li>Метод <code>Matreshka#defineNotEnum</code> удален по причине отсутствия в нем потребности</li>
<li>Matreshka.Array#initializeSmartArray -&gt; <a href="#!Matreshka.Array-rerender">Matreshka.Array#rerender</a></li>
<li>Matreshka#setMediator -&gt; <a href="#!Matreshka-mediate">Matreshka#mediate</a></li>
<li>Matreshka#bindElement -&gt; <a href="#!Matreshka-bindNode">Matreshka#bindNode</a></li>
<li>Matreshka#unbindElement -&gt; <a href="#!Matreshka-unbindNode">Matreshka#unbindNode</a></li>
<li>Matreshka#addDependency -&gt; <a href="#!Matreshka-linkProps">Matreshka#linkProps</a></li>
<li>Matreshka.Array#setItemMediator -&gt; <a href="#!Matreshka.Array-mediateItem">Matreshka.Array#mediateItem</a></li>
<li>Matreshka.Object#addJSONKeys -&gt; <a href="#!Matreshka.Object-addDataKeys">Matreshka.Object#addDataKeys</a></li>
<li>Matreshka.Object#removeJSONKeys -&gt; <a href="#!Matreshka.Object-removeDataKeys">Matreshka.Object#removeDataKeys</a></li>
<li>Matreshka.procrastinate -&gt; <a href="#!Matreshka.debounce">Matreshka.debounce</a></li>
<li>Удалено событие <code>itemrender</code> из Matreshka.Array. Можно использовать <code>@render</code> вместо него</li>
</ul>
<p><strong>Исправленные баги</strong></p>
<ul>
<li>Фиксы в <a href="#!$b">Балалайке</a> для старых браузеров WebKit, например, iOS 5 Safari</li>
<li>Обработчик DOM события вызывался несколько раз</li>
<li><a href="#!Matreshka-off">Matreshka#off</a> теперь возвращает себя</li>
<li>Исправлен баг в <a href="#!Matreshka-defineGetter">Matreshka#defineGetter</a></li>
<li>Исправлен баг в <a href="#!Matreshka.Array-concat">Matreshka.Array#concat</a></li>
<li>Исправлен баг в <a href="#!Matreshka-once">Matreshka#once</a></li>
<li>Исправлен баг в <a href="#!Matreshka.Array-itemMediator">Matreshka.Array#itemMediator</a></li>
<li>Исправлен баг в механизме рендеринга <a href="#!Matreshka.Array">Matreshka.Array</a></li>
<li>Небольшие исправления в <a href="#!Matreshka-bindNode">Matreshka#bindNode</a></li>
<li>Небольшие исправления для стандартных байндеров</li>
<li>Делегированные события не работали для <a href="#!Matreshka.Object">Matreshka.Object</a></li>
<li>Всегда возвращать <code>null</code> из <a href="#!Matreshka-bound">Matreshka#bound</a> если элемент не найден</li>
<li>Исправлен неочевидный баг в <a href="#!Matreshka-set">Matreshka#set</a>, возникающий при использовании <a href="#!Matreshka.Array-mediateItem">Matreshka.Array#mediateItem</a> и <a href="#!Matreshka.Array-linkProps">Matreshka.Array#linkProps</a> вместе</li>
<li>Использовать событие <code>delete</code> вместо <code>remove</code></li>
<li><code>binder.setValue</code> вызывался даже если значение свойства не было изменено</li>
<li>Привязанные HTML элементы не обновлялись после вызова <a href="#!Matreshka-mediate">Matreshka#mediate</a></li>
<li>Фиксы для Internet Explorer 8</li>
<li>Matreshka.lookForBinder теперь возвращает <code>undefined</code> если байндер не найден</li>
<li>Генерировать события модификации Matreshka.Array только когда коллекция изменилась</li>
</ul>
<p><strong>Изменения в коде</strong></p>
<ul>
<li>Оптимизирована генерация событий</li>
<li>Созданы методы _on и _off для внутреннего использования и улучшения производительности</li>
<li>Создан приватный метод Matreshka#_initMK</li>
<li>Оптимизирован код <a href="#!Matreshka.Object">Matreshka.Object</a></li>
<li>Убран полифил Number.isNaN</li>
</ul></article><article id="!faq"><h2><a href="#!faq">FAQ</a></h2><h3>Имеется ли в Матрешке обертка над <code>XMLHttpRequest</code> (AJAX)?</h3><p>Нет. Во-первых есть много прекрасных библиотек, реализующих коммуникации с сервером: некогда популярный <a href="http://api.jquery.com/jquery.ajax/">jQuery.ajax</a>, потрясающая библиотека <a href="https://github.com/pyrsmk/qwest">qwest</a>, основанная на <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise">"промисах"</a> и многие другие.</p>
<p>Во-вторых, в качестве альтернативы <code>XMLHttpRequest</code>, все браузеры, возможно, очень скоро получат нативную поддержку <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>. <code>fetch</code> имеет более простое и чистое API, основанное на "промисах", позволяющее избежать катастрофического количества callback'ов и необходимости помнить API <code>XMLHttpRequest</code>. Пока <code>fetch</code> поддерживается не всем браузерами, можно воспользоваться <a href="https://github.com/github/fetch">популярным полифилом</a>.</p>
<blockquote>
<p>"Промисы" и асинхронные функции из спецификации ECMAScript 7 дают возможность писать великолепной красоты JavaScript код:</p>
</blockquote>
<pre class="prettyprint source lang-js"><code>async function getData() {
    let resp = await fetch(someUrl);
    let data = await resp.text();

    console.log(data);
}

getData();</code></pre><h3>Есть ли в Матрешке роутинг?</h3><p>Нет. Как и в случае с AJAX, в интернете есть полно замечательных библитек, реализующих роутинг, например <a href="https://github.com/flatiron/director">director</a>.</p>
<h3>Как работает Матрешка?</h3><p>Матрешка использует акцессоры (accessors), в частности, сеттеры (setters) для реализации двустороннего связывания данных и отлова событий изменения свойств. Эта технология существует достаточно давно (Internet Explorer 8 был первым браузером, который включал поддержку <code>Object.defineProperty</code>). Одной из главных особенностей сеттеров, является молниеносная скорость, сравнимая со скоростью работы с обычными свойствами. В производительности акцессоры выигрывают у других решений: <code>Object.observe</code> и, особенно, dirty-checking.</p>
<p>В качестве примера того, как работает двустороннее связывание (в частности, функция <a href="#!Matreshka-bindNode">bindNode</a>), взгляните на этот код:</p>
<pre class="prettyprint source lang-js"><code>window.bindNode = function bindNode(object, key, node, binder) {
    var value = object[key];
    Object.defineProperty(object, key, {
        get: function() {
            return value;
        },
        set: function(v) {
            binder.setValue.call(node, v);
        }
    });

    node.addEventListener(binder.on, function() {
        value = binder.getValue.call(node);
    });
};</code></pre><p>Как видите, ничего сложного (для упрощения, функция не поддерживает связь многие-ко-многим).</p>
<p>Пример работы функции можно посмотреть на <a href="http://jsbin.com/mabetap/7/edit?html,js,output">jsbin</a>.</p>
<h3>Поддерживает ли Матрешка серверный рендеринг?</h3><p>К сожалению, (возможно, пока) нет. Матрешка использует DOM шаблонизацию, которая требует наличия на сервере библиотеки, реализующей DOM API. Хорошим примером такой библиотеки является <a href="https://github.com/tmpvar/jsdom">jsdom</a>. Проблема в том, что к серверу присоединяется много клиентов, каждый из которых может запросить соверщенно разные страницы, генерирующиеся динамически. DOM шаблонизация работает заметно медленнее, чем HTML шаблонизация, где шаблоном выступает обычный текст, а не многочисленные DOM объеты.</p>
<p>В качестве примера, можно привести серверный рендеринг React компонентов, которые тоже требуют DOM шаблонизатор. Как правило, эта задача решается хитрыми трюками и рекомендациями использовать кеширование шаблонов (что не всегда возможно, а если возможно, может вызвать утечки памяти). Даже используя лучшие практики и хитроумные решения, обычный текстовый HTML шаблонизатор (скажем, <a href="https://github.com/janl/mustache.js">mustache.js</a>) решит проблему многократно быстрее, а скорость на сервере, как известно, намного важне, чем на клиенте.</p>
<p>Поэтому, на сегодняшний день, единственной рекомендацией к серверному рендерингу является перекладывание задачи генерации HTML строки на любой текстовый шаблонизатор. Оставим узкоспециализированные задачи выполнять инструментам, делающим это лучше всего.</p></article>
</section>