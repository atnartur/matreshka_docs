/**
@class Matreshka
@lang en
@version 0.3
@author Andrey Gubanov <a@odessite.com.ua>
@license {@link https://raw.github.com/finom/matreshka/master/LICENSE MIT}
Version 2.0, January 2004
@alias MK
@see {@link Class}
@classdesc The class ``Matreshka`` is a core of the Matreshka.js framework which is inherited by {@link Matreshka.Array}, {@link Matreshka.Object} and every class of the application you create. It contains the main functionality of the framework, among which there are some very useful functions, such as {@link Matreshka#mediate mediators}, {@link Matreshka#linkProps dependencies}, {@link Matreshka#bindNode two-way data binding}, {@link Matreshka#on an event engine}, etc. The inheritance of this class, the same as the inheritance of any other class, is carried out with the help of the {@link Class} function.

As a rule, this class, (like {@link Matreshka.Array} and {@link Matreshka.Object}), isn't used directly. Instead, it is inherited by the classes that you create. Therefore, the examples to the properties and methods in this documentation, as a rule, will be given with the use of the keyword ``this``.
@example <caption>Creating of the instance</caption>
var mk = new Matreshka;
@example <caption>You can use ``MK`` global variable instead of ``Matreshka``</caption>
var mk = new MK;
@example <caption>Inheritance</caption>
var MyClass = Class({
	'extends': Matreshka,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});
@example <caption>Matreshka uses prototypes for implementing the inheritance. The {@link Class} function just brings in some syntactic sugar and adds some hacks for the Internet Explorer 8. That's why you can use any other way of the inheritance you like, for example, using classes from ECMAScript 2015</caption>
class MyClass extends Matreshka {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}
*/


/**
@member {boolean} Matreshka#isMK
@summary ``isMK`` always equals ``true``. This property is used for defining whether  the object is an instance of the {@link Matreshka} class
@example
alert(object.isMK);
*/


/**
@member {$nodes} Matreshka#$sandbox
@since 0.4
@summary The property contains HTML sandbox as collection (jQuery, Zepto, Balalaika)
@see {@link Matreshka#bindNode}
@example
this.bindNode( 'sandbox', '.app' );
this.$sandbox; // the same as $( '.app' )
*/


/**
@member {node} Matreshka#sandbox
@since 0.4
@summary The property contains HTML sandbox
@see {@link Matreshka#bindNode}
@example
this.bindNode( 'sandbox', '.app' );
this.sandbox; // the same as $( '.app' )[0]
*/


/**
@member {$nodes} Matreshka#$nodes
@since 1.1
@summary The object contains quick-accessible collections (jQuery, Zepto, Balalaika) of bound nodes.
@see {@link Matreshka#bindNode}
@example
this.bindNode( 'myKey', '.my-node' );
this.$nodes.myKey; // Ñ‚the same as $( '.my-node' )
*/


/**
@member {node} Matreshka#nodes
@since 1.1
@summary The object contains quick-accessible bound nodes.
@desc Play attention: every property of this object contains the first bound to given key DOM node. To get all bound nodes use {@link Matreshka#$nodes}.
@see {@link Matreshka#bindNode}
@example
this.bindNode( 'myKey', '.my-node' );
this.nodes.myKey; // the same as $( '.my-node' )[0]
*/

/**
@method Matreshka#on
@summary Adds the event handler
@desc The {@link Matreshka#on} method adds the event handler for an instance of the ``Matreshka`` class. Refer to the complete list of possible events with the description here: {@link #typedef-eventNames}.
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@param {eventNames} names - The event name or some names which are separated by a space (for example, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} callback - The function which is caused by the event
@param {boolean} [triggerOnInit=false] - If the ``triggerOnInit`` argument  equals ``true``, the handler will be  called immediately after the initialization.
@param {object} [context] - The context of the handler. In other words, ``this`` when called ``callback``
@returns {matreshka} self
@example
this.on( 'foo', function() {
	alert( 'Custom Event is fired' );
});

this.trigger( 'foo' );
@example <caption>Passing the context</caption>
this.on( 'foo', function() {
	alert( this.a ); // 5
}, { a: 5 } );

this.trigger( 'foo', 'Hello world' );
@example <caption>Calling the handler immediately after the initialization</caption>
// Displays "bar" at once and waits for the firing of the event "foo"
this.on( 'foo', function() {
	alert( 'bar' );
}, true );
*/


/**
@method Matreshka#on
@variation 2
@since 1.1
@summary Alternative syntax: "eventname-handler" pairs
@desc In the {@link Matreshka#on} method the object with the key-element pairs can be passed to avoid the multiple invocation of the method and reduce the code.

@param {object} evtnameHandlerObject - An object where keys are event names and values are event handlers
@param {boolean} [triggerOnInit=false] - If the ``triggerOnInit`` argument  equals ``true``, the handler will be  called immediately after the initialization.
@param {object} [context] - The context of the handler
@returns {matreshka} self
@example
this.on({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});

@example ECMAScript 2015
this.on({
	'custom': evt => ...,
	'click::x': evt => ...,
	'change:y': evt => ...,
});
*/


/**
@method Matreshka#onDebounce
@summary adds the event handler which is called only once during a definite period of time
@desc The method allows to add the event handler to an instance of the {@link Matreshka} class, debouncing the handler. The function can be called only once during a definite period of time. As to the rest the method works the same as {@link Matreshka#on}.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@see {@link Matreshka.debounce}
@see {@link http://davidwalsh.name/javascript-debounce-function JavaScript Debounce Function}
@param {eventNames} names - An event name or some names which are separated by a space (for example, ``"change:x ajaxcomplete change:y"``).
@param {eventHandler} callback - A handler which is caused by an event
@param {number} [debounceDelay=0] - A delay
@param {boolean} [triggerOnInit=false] - If ``triggerOnInit`` argument equals ``true``, the handler will be  called immediately after the initialization.
@param {object} [context] - A context of a handler. In other words, ``this`` when called ``callback``
@returns {matreshka} self
@example
this.onDebounce( 'change:x', function() {
	alert( 'x = ' + this.x ); // x = 100
}, 300 );

this.x = 1;

for( var i = 0; i < 100; i++ ) {
	this.x++;
}
*/


/**
@method Matreshka#onDebounce
@variation 2
@since 1.1
@summary Alternative syntax: "eventname-handler" pairs
@see {@link Matreshka#on(2)}
@param {object} evtnameHandlerObject - An object where keys are event names and values are event handlers
@param {number} [debounceDelay=0] - A delay
@param {boolean} [triggerOnInit=false] - If ``triggerOnInit`` argument equals ``true``, the handler will be  called immediately after the initialization
@param {object} [context] - A context of a handler
@returns {matreshka} self
@example
this.onDebounce({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});
*/

/**
@method Matreshka#once
@summary Adds the event handler which can be called only once
@desc The method works the same as {@link Matreshka#on} but the passing handler can be called only once. Note  the method lacks the <code>triggerOnInit</code> argument.
@see {@link Matreshka#on}
@see {@link Matreshka#off}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} names - An event name or some names which are separated by a space (for example, <code>"change:x ajaxcomplete change:y"</code>)
@param {eventHandler} callback - A handler which is caused by an event
@param {object} [context] - A context of a handler
@returns {matreshka} self
@example
this.x = 1;

this.once( 'change:x', function() {
	alert( 'x is changed' );
});

this.x = 2; // displays 'x is changed'

this.x = 3; // does nothing
*/


/**
@method Matreshka#once
@variation 2
@since 1.1
@summary Alternative syntax: "eventname-handler" pairs
@see {@link Matreshka#on(2)}
@param {object} evtnameHandlerObject - An object where keys are event names and values are event handlers
@param {object} [context] -A context of a handler
@returns {matreshka} self
@example
this.once({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});
*/

/**
@method Matreshka#off
@summary Deletes an event handler
@desc It deletes a handler which has been created before. All the three arguments are optional. You can delete both all the events (without passing a single argument) and separate ones (having passed only the event name, the event name and the handler, the event name and the handler and the context)
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} [names] - A list of event names which are separated by spaces (for example, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} [callback] - A function-handler
@param {object} [context] - A context
@returns {matreshka} self
@example
this.off( 'change:x bind' );
@example <caption>The deletion of all events</caption>
this.off();
@example <caption>The deletion of an event with definite handler</caption>
var handler = function() {
	//...
}
this.on( 'change:x', handler );
this.off( 'change:x', handler );
@example <caption>The deletion of an event with definite context</caption>
var object = {};
this.on( 'change:x', handler, object );
this.off( 'change:x', handler, object );
*/


/**
@method Matreshka#trigger
@summary Fires an event
@desc After adding event handlers with the help of the {@link Matreshka#on}, {@link Matreshka#onDebounce} or {@link Matreshka#once}, method , any event can be fired manually using this method.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#off}
@param {eventNames} [names] - An event name or some names which are separated by a space
@param {...*} [arg] - Any arguments which will be passed to every handler
@returns {matreshka} self
@example
this.on( 'foo bar', function( a, b, c ) {
	alert( a + b + c );
});
this.trigger( 'foo', 1, 2, 3 ); // alerts 6
*/


/**
@method Matreshka#bindNode
@fires bind
@fires bind:KEY
@summary Binds a property of an object to HTML node, implementing two-way data binding
@desc {@link Matreshka#bindNode} is the only method of the {@link Matreshka} class  which is responsible for changing DOM. It creates a bridge between value of a property and state of HTML node on the page: from a simple input to a complicated widget (the complexity of elements is unlimited). ``bindNode``can be truly regarded as the main method of the framework. After using this method, it isn't necessary to monitor the synchronizations between model and view.

The method acepts three arguments: **a property name** (key), **HTML node** (or a selector) and a **binding rule**. In its turn, a binder is an ordinary object and it can have the following properties: ``on``, ``getValue``, ``setValue``, ``initialize`` (Read more here: {@link #typedef-binder}). All the four properties are optional. It also allows to declare one-way data bindings (any direction).

> The ``bindNode`` method  supports the many-to-many bindings. Several elements can be bound to one property and several properties can be bound to one element, including ones from different instances of various classes.

```js
this.bindNode( 'myKey', '.my-element', {
	on: 'click',
	getValue: function() { ... },
	setValue: function() { ... }
});
```

For example, you want to bind the property of the object to the ``input[type="checkbox"]`` node:
```js
this.bindNode( 'myKey', '.my-checkbox', {
	// when is the element state changed?
	// - after the event 'click'
	on: 'click',
	// how to extract the element state?
	// - return the value 'checked'
	getValue: function() {
		return this.checked;
	},
	// how to set the element state?
	// - set the value 'checked'
	setValue: function( v ) {
		this.checked = !!v;
	}
});
```

After binding is declared, you can set value of the object property in your most habitual way and the HTML node (in this case, a checkbox) will change its state in no time. After clicking on the checkbox, the property value will be changed to the corresponding one as well.
```js
// sets checked = false
this.myKey = true;
```

> If the property value of the class instance is not given, after the binding Matreshka will try to extract its value from the HTML node using ``getValue``. This behavior can be cancelled by passing the ``assignDefaultValue: false`` property to event object.
```js
this.bindNode( 'myKey', '.my-element', binder, {
	assignDefaultValue: false
});
```

More complicated example: binding the object property to the jQuery UI widget
```html
<div class="my-slider"></div>
```

```js
this.bindNode( 'myKey', '.my-slider', {
	// when is the element state changed?
	// - after the event 'slide'
	on: 'slide',
	// how to extract the element state?
	// - return the value of the 'value' widget
	getValue: function() {
		return $( this ).slider( 'option', 'value' );
	},
	// how to set the element state?
	// - set the 'value' value
	setValue: function( v ) {
		$( this ).slider( 'option', 'value', v );
	},
	// how to initialize the widget?
	// you can initialize the slider in any way,
	// but initialize provides some syntactic sugar
	initialize: function() {
		$( this ).slider({ min: 0, max: 100 });
	}
});
```

```js
// will set the slider value 42
this.myKey = 42;
```

It looks easy but you may ask a question: "What should I do to avoid writing these rules every time?". The question is absolutely correct. Indeed, there can be a lot of elements of the same type on the page: text fields, drop down menus, new fields from the specification of HTML5 as well as third party widgets (see the example above).

As observed in the documentation, the third argument is not obligatory for  the ones of the {@link Matreshka#bindNode} method (see below). This problem is solved by the {@link Matreshka.defaultBinders} array which contains functions checking an HTML node against a set of rules. You get an opportunity to reduce your code a great deal, putting  binding rules into a separate part of your code and to use a syntax for binding without  the third argument:
```js
this.bindNode( 'myKey', '.my-element' );
```
How to do it? You should add the function checking  your element against a set of rules to the beginning of the {@link Matreshka.defaultBinders} array. The example below can be used as a template for creating your **default binder**.
```js
// add the binder to the collection of binders
// it is necessary to keep the possibility of overriding
Matreshka.binders.checkbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return this.checked;
		},
		setValue: function( v ) {
			this.checked = !!v;
		}
	}
};

// the unshift method adds the function
// to the beginning of the Matreshka.defaultBinders array
Matreshka.defaultBinders.unshift( function( node ) {
	// check if the element is a checkbox
	if( node.tagName == 'INPUT' && node.type == 'checkbox' ) {
		// if checking is OK, return a new binder
		return Matreshka.binders.checkbox();
	}
});
```
```js
this.bindNode( 'myKey', '.my-checkbox' );
this.myKey = true;
```

What should you do if you need to pass arguments for initializing some plug-in or a widget? It is a piece of cake: you can do with adding the binder to the {@link Matreshka.binders} collection  without creating a function for {@link Matreshka.defaultBinders}.
```js
Matreshka.binders.uiSlider = function( min, max ) {
	return {
		on: 'slide',
		getValue: function() {
			return $( this ).slider( 'option', 'value' );
		},
		setValue: function( v ) {
			$( this ).slider( 'option', 'value', v );
		},
		initialize: function() {
			$( this ).slider({ min: min, max: max });
		}
	}
};
```
```js
this.bindNode( 'myKey1', '.my-slider1', Matreshka.binders.uiSlider( 0, 100 ) );
this.bindNode( 'myKey2', '.my-slider2', Matreshka.binders.uiSlider( 1, 1000 ) );
this.myKey1 = 42;
this.myKey2 = 999;
```

{@link Matreshka.defaultBinders} OOB, starting with the version 0.3, has a support for **all form elements** without any exception: ``select`` (including ``multiple``), ``textarea``, ``input`` (including all types from the specification of HTML5: ``text``, ``checkbox``, ``radio``, ``range``, ``number``, ``date``, ``search``, ``time``, ``datetime``, ``datetime-local``, ``color`` and others). That means it is not necessary to designate a binder for standard elements.
```html
<input type="color" class="my-color-input">
```
```js
this.bindNode( 'myColor', '.my-color-input' );
this.myColor = '#66bb6a';
```


Besides, after the binding, a new non-standard ``:bound(KEY)`` CSS selector is available for you.
```js
this.bindNode( 'myKey', '.my-element' );

// will find the element '.my-inner-element' inside '.my-element'
this.bindNode( 'myAnotherKey', ':bound(myKey) .my-inner-element' );
```

And the syntax of possible event names is extended:
```js
this.bindNode( 'myKey', '.my-element' );

// will catch the click on the .my-element element
this.on( 'click::myKey', function() { ... });

// will catch the click on the .my-inner-element element
this.on( 'click::myKey(.my-inner-element)', function() { ... });
```


#### The creation of a sandbox
{@link Matreshka#bindNode} can associate a class instance with the "main" HTML element on the page creating the so-called **sandbox**. It is necessary to limit the instance influence on HTML nodes contained in another sandbox (i. e. inside another HTML node). A special property ``'sandbox'`` is used for binding a sandbox.
```html
<div class="my-sandbox">
	<!-- your HTML code -->
</div>
```

```js
this.bindNode( 'sandbox', '.my-sandbox' );
```

The definition of the sandbox adds lots of conveniences for you. For example:
+ allows to use the {@link Matreshka#select} and {@link Matreshka#$} methods
+ allows to use the {@link Matreshka#bound} and {@link Matreshka#$bound} methods without specifying an argument
+ adds a new ``:sandbox`` selector for the {@link Matreshka#bindNode}, {@link Matreshka#select}, {@link Matreshka#$} methods and others
+ adds syntactic sugar for delegated DOM events in the {@link Matreshka#on} method


```js
// declare a sandbox
this.bindNode( 'sandbox', '.my-sandbox' );

// .my-element is being searched for in the sandbox
this.bindNode( 'myKey', ':sandbox .my-element' );

// it is not required to specify a key
// for the delegated events inside a sandbox
this.on( 'click::(.my-button)', function() { ... } );

// will print a sandbox element into the console
console.log( this.$bound() );

// will put the .inner-node element
// which is inside the sandbox into the console
console.log( this.$( '.inner-node' ) );
```

#### Deep binding
Since version 1.1, the ``bindNode`` method supports the new feature called "deep binding". The method can bind DOM node to some property of nested object. For example, you have some nested object:
```js
this.a = { b: { c: { d: 42 } } };
```

And you want to bind some DOM node to ``d``. The only thing you need is to pass a path to needed property and Matreshka will listen all changes throughout a tree of nested object by breaking a binding then re-creating it again:
```js
this.bindNode( 'a.b.c.d', '.my-node' );
```

When some changes appear in the nested tree ``bindNode`` catches them and recreates binding again.
```js
this.a.b = { c: { d: 41 } };
```


@see {@link Matreshka#unbindNode}
@see {@link Matreshka#bindOptionalNode}
@see {@link Matreshka#$}
@see {@link Matreshka#$bound}
@see {@link Matreshka.binders}
@see {@link Matreshka.defaultBinders}


@param {string|matreshka} key - A key (a property name)
@param {string|node|$nodes} node - An HTML element which must be bound to a ``key``
@param {binder} [binder] - The binder containing the following properties: ``on`` - which event must happen to an HTML node, informing that a user has changed something (for example, ``keyup`` or ``click``), ``getValue`` -  how to get the value from an HTML node, ``setValue`` - how to set a new value to a node and ``initialize`` - a function which is executed once after the initialization of the binding. You can get more detailed information about binders in their documentation: see {@link #typedef-binder}.
@param {eventOptions} [eventOptions] - An event object which accepts ``"silent"`` (don't fire ``"bind"`` and ``"bind:KEY"``), ``"assignDefaultValue"`` or some custom data.
@returns {matreshka} self

@example <caption>A custom checkbox. This example demonstrates the creation of the custom element whose ``"checked"`` class is changed after clicking on it.</caption>
this.bindNode( 'myKey', '.custom-checkbox', {
	on: 'click',
	getValue: function() {
		return $( this ).hasClass( 'checked' );
	},
	setValue: function( v ) {
		$( this ).toggleClass( 'checked', !!v );
	},
	// initialize the element behavior
	// the presence of the 'checked' class name is changed after clicking on the element
	initialize: function() {
		$( this ).on( 'click', function() {
			$( this ).toggleClass( 'checked' );
		});
	}
});

@example <caption>A custom checkbox 2. This example is the same as the previous one but it uses {@link Matreshka#defaultBinders}, and checks the element if the ``custom-checkbox``. class is present. If checking is OK, it returns the binder.</caption>
// add the binder to the collection of binders
Matreshka.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $( this ).hasClass( 'checked' );
		},
		setValue: function( v ) {
			$( this ).toggleClass( 'checked', !!v );
		},
		initialize: function() {
			$( this ).on( 'click', function() {
				$( this ).toggleClass( 'checked' );
			});
		}
	}
};

MK.defaultBinders.unshift( function( element ) {
	// check if the element has the "custom-checkbox" class
	if( $( element ).hasClass( 'custom-checkbox' ) ) {
		// if checking is OK, return a new binder
		return Matreshka.binders.customCheckbox();
	}
});

this.bindNode( 'myKey', '.my-custom-checkbox' );

@example <caption>The ``"bind"`` event which is fired after any binding</caption>
this.on( 'bind', function() { alert( 'ok!' ); });
this.bindNode( 'myKey', '.my-element' ); // alerts "ok!"

@example <caption>The ``"bind:KEY"`` event which is fired after binding the specific property to HTML node</caption>
this.on( 'bind:myKey', function() { alert( 'ok!' ); });
this.bindNode( 'myKey', '.my-element' ); // alerts "ok!"

@example <caption>The DOM event overriding for default binder. For example, we want to bind ``input[type="text"]`` to a property. By default, the standard binder contains ``"on"`` property with the ``"keydown paste"`` value for this kind of node. It means that a value of an instance property and node state will be synchronized when a user releases a key of the keyboard or pastes text from clipboard. In case if you want synchronization to be performed after the ``"blur"`` DOM event,  you will have to pass the object containing the only ``"on"`` property as the third argument. This object will join a default binder, having retained ``getValue`` and ``setValue`` values.</caption>
this.bindNode( 'myKey', '.my-input', { on: "blur" });

@example <caption>If an element is not found, the ``"Bound element is missing"`` exception is thrown. In order to avoid the error, use the {@link Matreshka#bindOptionalNode} method</caption>
var $el = $();
this.bindNode( 'x', $el ); // an error because $el is empty

@example <caption>Synchronization of a property value and HTML contents of a node</caption>
this.bindNode( 'myKey', '.my-element', {
	setValue: function( v ) {
		this.innerHTML = v;
	}
});

// it can be done easier
this.bindNode( 'myKey', '.my-element', MK.binders.innerHTML() );
*/


/**
@method Matreshka#bindNode
@variation 2
@summary Alternative syntax: "key-element" pairs
@desc In the {@link Matreshka#bindNode} method the object with the key-element pairs can be passed to avoid the multiple invocation of the method and reduce the code.

@param {object} keyElementPairs - (see the example)
@param {binder} [binder] - (see above)
@param {eventOptions} [eventOptions] - (see above)

@example
this.bindNode({
	myKey1: '.custom-checkbox',
	myKey2: 'textarea'
});
*/


/**
@method Matreshka#bindNode
@variation 3
@summary Alternative syntax: "heap of arguments"
@desc Another syntax for the {@link Matreshka#bindNode} method. This way may seem unattractive but sometimes you have need of binding lots of nodes to different properties at one operation. With such a syntax you can assign definite binders to some variable and then easily delete all at once using {@link Matreshka#unbindNode}.

@param {array} setOfArguments - The array of arrays (see the example)
@param {eventOptions} [eventOptions] - (see above)

@example
this.bindNode([
	[{
		myKey1: '.my-element1',
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3',
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5',
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
]);
*/

/**
@method Matreshka#bindOptionalNode
@since 0.3
@summary Works just the same as {@link Matreshka#bindNode} but it does not throw an exception if the ``node`` argument is an empty array, ``undefined`` or non-existent.
@see {@link Matreshka#bindNode}
@example
this.bindOptionalNode( 'myKey', '.my-element' );
*/

/**
@method Matreshka#unbindNode
@fires unbind
@fires unbind:KEY
@summary Breaks the binding between given property and HTML node.
@desc Using this method you can delete the binding between a property and HTML node, which has been added recently and no longer needed.
@param {string|null} The key or a list of keys which are separated by spaces. If you pass ``null`` instead of the key, all bindings for the given instance will be deleted
@param {string|node|$nodes} [node] - HTML node
@param {eventOptions} [eventOptions] -  The event object (``"silent"`` key disables firing the events ``"unbind"`` and ``"unbind:KEY"``)
@returns {matreshka} self
@example
this.bindNode( 'myKey', '.my-element' );

// changes the property value and the state of the HTML element
this.myKey = true;

this.unbindNode( 'myKey', '.my-element' );

// only the property value is being changed now
this.myKey = false;
*/


/**
@method Matreshka#unbindNode
@variation 2
@summary Alternative syntax "key-element" for {@link Matreshka#unbindNode}
@see {@link Matreshka#bindNode(2)}
@param {object} keyElementPairs (see the example)
@param {eventOptions} [eventOptions] (see above)
@returns {matreshka} self
@example
this.unbindNode({
	myKey1: '.my-element1'
	myKey1: '.my-element2'
});
*/


/**
@method Matreshka#unbindNode
@variation 3
@summary Alternative syntax "heap of arguments" for {@link Matreshka#unbindNode}
@see {@link Matreshka#bindNode(3)}
@param {array} setOfArguments - An array of arrays (see the example)
@param {eventOptions} [eventOptions] (see above)
@returns {matreshka} self
@example
var temporaryBindings = [
	[{
		myKey1: '.my-element1'
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3'
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5'
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
];

this.bindNode( temporaryBindings );

// these bindings are no longer needed
this.unbindNode( temporaryBindings );
*/


/**
@method Matreshka#boundAll
@summary Returns a collection of bound nodes by given key
@param {string} [key] - The key of the property (or the list of the keys separated by spaces), which bound elements we want to get. If no arguments are passed the method returns a sandbox.
@returns {$nodes} Bound nodes
@example
this.bindNode( 'myKey', '.my-element' );
this.boundAll( 'myKey' ); // will return $( '.my-element' )
@example <caption>Getting sandbox node (you can use {@link Matreshka#$sandbox} property instead)</caption>
this.bindNode( 'sandbox', '.app' );
this.boundAll(); // will return $( '.app' )
*/


/**
@method Matreshka#$bound
@summary Does the same as {@link Matreshka#boundAll}
@example
this.$bound( 'myKey' );
*/


/**
@method Matreshka#bound
@summary Returns the first bound element or ``null``
@param {string} [key] - A key of a property (or the list of the keys separated by spaces), which bound nodes we need to get. If no arguments are passed the method returns a sandbox.
@returns {node|null} The bound element
@example
this.bindNode( 'myKey', '.my-element' );
this.bound( 'mykey' ); // will return $( '.my-element' )[0]
@example <caption>Getting sandbox node (you can use {@link Matreshka#sandbox} property instead)</caption>
this.bindNode( 'sandbox', '.app' );
this.bound(); // will return $( '.app' )[0]
*/


/**
@method Matreshka#selectAll
@summary Returns HTML nodes corresponding to the selector from the sandbox
@desc After sandbox creation by the {@link Matreshka#bindNode} method, you can get and use HTML nodes which are located in it. Besides, the method supports the ``:bound(KEY)`` selector
@param {string} A selector
@returns {$nodes}
@example
this.bindNode( 'sandbox', '.app' );
this.selectAll( '.my-element' );
// the same as
this.$bound().find( '.my-element' );
// the same as
$( '.app' ).find( '.my-element' );

@example <caption>The ``:bound(KEY)`` selector</caption>
this.bindNode( 'myKey', '.my-element' );
this.selectAll( ':bound(myKey) .my-another-element' );
// the same as
this.$bound( 'myKey' ).find( '.my-another-element' );
// the same as
$( '.my-element' ).find( '.my-another-element' );
*/


/**
@method Matreshka#$
@variation instance
@summary Does the same as {@link Matreshka#selectAll}
@example
this.$( '.my-element' );
*/


/**
@method Matreshka#select
@summary Returns HTML node corresponding to the selector from the sandbox
@desc The method is very similar to {@link Matreshka#selectAll}, but it returns only one element or ``null``
@param {string} The selector
@returns {node}
@example
this.bindNode( 'sandbox', '.app' );
this.select( '.my-element' );
// the same as
this.bound().querySelector( '.my-element' );
// the same as
$( '.app' ).find( '.my-element' )[ 0 ];
*/


/**
@method Matreshka#eq
@since 0.0.2
@summary Tests the instance for other object equality
@desc Internet Explorer 8 throws an exception while attempting the traditional comparison for equality using ``==`` or ``===``. The ``.eq`` method solves this problem. If the support of IE8 is not necessary, the use of this method is not obligatory.
@param {object} object - The object which the instance must be compared to
@example
this.eq( object ); // true or false
@example <caption>The exception in IE8</caption>
// sometimes IE8 throws "Class doesn't support Automation"
this === object;
*/


/**
@method Matreshka#defineGetter
@summary Defines custom getter for a property
@desc This method allows to define a getter using the native ``Object.defineProperty`` method and it works in all browsers starting with Internet Explorer 8. The returned property value is calculated on every accessing the property, that is why, from viewpoint of performance, the most preferred method is {@link Matreshka#linkProps}.
@param {string} key - The key property which the getter is set for
@param {function} getter - The function-getter
@example
this.defineGetter( 'myKey', function() {
	// a function can return any calculated value
	return 42;
});
*/


/**
@method Matreshka#defineGetter
@variation 2
@summary Alternative "key-getter" syntax of the {@link Matreshka#defineGetter} method
@param {object} keyGetterPairs - An object with the key-getter properties
@example
this.defineGetter({
	myKey1: function() { return 1; }
	myKey2: function() { return 2; }
});
*/


/**
@method Matreshka#defineSetter
@summary Defines a custom setter for a property
@desc This method allows to define a setter using the ``Object.defineProperty`` native method and it works in all browsers starting with Internet Explorer 8. While using this method you should remember that it overrides the setter which has been built in by Matreshka and in this way it disables the opportunity to catch the events like ``change:KEY``. Use this method if you are 100% sure what you are doing. The {@link Matreshka#on} and {@link Matreshka#mediate} methods are safe from viewpoint of stability of the application you create so it is better to use them.
@param {string} key - A key which the setter is required to be defined for
@param {function} setter - A function-setter
@example
this.defineSetter( 'mykey', function( v ) {
	alert( v );
});
*/


/**
@method Matreshka#defineSetter
@variation 2
@summary Alternative  "key-setter" syntax of the {@link Matreshka#defineSetter} method
@param {object} keySetterPairs - The object with the key-setter properties
@example
this.defineSetter({
	myKey1: function( v ) { alert( v ); }
	myKey2: function( v ) { alert( v ); }
});
*/


/**
@method Matreshka#mediate
@since 0.1
@summary Transforms the property value on its changing
@desc This method is used for transforming the property value on its changing. For example, you want the property value to be always either of a certain type or an integer value, or to be no less than zero and no more than a hundred etc.
@param {string|array} key - A key or an array of keys or a list of keys which are separated by spaces
@param {function} mediator - A function-mediator which returns a new value
@example
this.mediate( 'x', function( value ) {
	return String( value );
});

this.x = 1;

alert( typeof this.x ); // "string"
@example <caption>A list of keys which are separated by spaces</caption>
this.mediate( 'x y', function( value ) {
	return String( value );
});
@example <caption>An array of keys</caption>
this.mediate( [ 'x', 'y' ], function( value ) {
	return String( value );
});
*/


/**
@method Matreshka#mediate
@variation 2
@since 0.1
@summary Alternative syntax of the {@link Matreshka#mediate} method which accepts "key-mediator" object as an argument
@param {object} keyMediatorPairs - An object with the key-mediator properties
@example
this.mediate({
	x: String,
	y: Number,
	z: Boolean
});
this.x = 1;
this.y = 2;
this.z = 3;
alert( typeof this.x ); // "string"
alert( typeof this.y ); // "number"
alert( typeof this.z ); // "boolean"
@example <caption>A list of keys which are separated by spaces</caption>
this.mediate({
	'u v': String,
	'w x': Number,
	'y z': Boolean
});
*/


/**
@method Matreshka#setClassFor
@since 1.1
@summary Docs are coming soon...
@param {string|array} key
@param {function} class
@param {function} [updateCallback]

*/


/**
@method Matreshka#setClassFor
@variation 2
@since 1.1
@summary Docs are coming soon...
@param {object} keyClassPairs
@param {function} [updateCallback]
@example
this.setClassFor({
	x: Class1,
	y: Class2,
	z: Class3
}, function( data ) {
	instance.jset( data );
});
*/


/**
@method Matreshka#linkProps
@since 0.1
@summary Creates a dependency of one property value on the values of others
@desc The ``linkProps`` method creates a dependency of a property value (the first argument) on values of other properties (the second argument). The method is protected from the loop links (for example, ``a`` depends on ``b``, ``b`` depends on ``c`` and ``c`` depends on ``a``) and if there is a calculation error, it does not block the page and does not throw an exception about the stack over-flow.
@param {string|array} keys1 - A property (properties) which depends on other ones
@param {string|array} keys2 - Which properties the desired property (properties) is depended on
@param {function} [handler=function(v){return v}] - A function which returns a new value
@param {boolean} [setOnInit=true] - Whether to set a property value immediately after declaring a dependency
@example
this.linkProps( 'greeting', 'name', function() {
	return 'Hello, ' + this.name + '!';
});

this.name = 'Joe';

alert( this.greeting ); // 'Hello, Joe!'

@example <caption>A complicated example: the calculation of the rectangle perimeter with two sides known (and the calculation of the sides with the perimeter known). As you see, ``linkProps`` can be used for the solution of mathematical problems as well, where every member of equation can be used as the unknown</caption>
this.a = 3;

this.b = 4;

this.linkProps( 'p', 'a b', function( a, b ) {
	return ( a + b ) * 2;
});

this.linkProps( 'a', 'p b', function( p, b ) {
	return p/2 - b;
});

this.linkProps( 'b', 'p a', function( p, a ) {
	return p/2 - a;
});

alert( this.p ); // 14

this.on( 'change:p', function() {
	alert( 'The perimeter has been changed and equals ' + this.p );
});

this.a = 5; // alerts "The perimeter has been changed and equals 18"
*/


/**
@method Matreshka#linkProps
@variation 2
@since 0.2
@summary An additional possibility of the {@link Matreshka#linkProps} method: a dependency on property values of other instances
@param {string|array} keys - a property (properties) which depends on other ones
@param {array} instancesAndKeys - An array which contains instances (even elements) and their keys (uneven elements), which a desired property (properties) is depended on. This syntax which may seem strange is the consequence of JavaScript syntax constraints.
@param {function} [handler=function(v){return v}] - A function which returns a new value
@param {boolean} [setOnInit=true] - Whether to set a property value immediately after declaring a dependency
@example <caption>The ``sum`` property is a sum of ``a`` and ``b`` values of other instances and it is calculated every time on their changing</caption>
anotherInstance1.a = 2;

anotherInstance2.b = 3;

this.linkProps( 'sum', [
	anotherInstance1, 'a',
	anotherInstance2, 'b'
], function( a, b ) {
	return a + b;
});

alert( this.sum ); // 5

this.on( 'change:sum', function() {
	alert( 'this.sum equals ' + this.sum );
});

anotherInstance1.a = 5; // "this.sum equals 8"
*/


/**
@method Matreshka#get
@summary Returns the property value
@param {string} key
@example
// the same as this[ 'myKey' ] or this.myKey
this.get( 'myKey' );
*/


/**
@method Matreshka#set
@fires change
@fires change:KEY
@summary Sets a property value allowing to pass the event object as the third argument
@desc The list of the supported flags:
+ ``silent`` -  do not call the ``change`` and ``change:KEY`` events
+ ``silentHTML`` - do not change the state of the bound objects
+ ``force`` - call the ``change`` and ``change:KEY`` events even though the property value has not been changed
+ ``forceHTML`` - change the state of the bound element even though the property value has not been changed. This option is necessary if the bound element has been rendered after the binding (for example, the ``option`` tags have been added to ``select`` tag)
+ ``skipMediator`` - prevents the property transformation by a mediator (see {@link Matreshka#mediate})
+ ``skipLinks`` - prevents the work of dependencies created with the help of {@link Matreshka#linkProps}
@param {string} key - A key
@param {*} value - A value
@param {eventOptions} [eventOptions] - An event object
@example
this.on( 'change:myKey', function( eventOptions ) {
	alert( eventOptions.value );
});

// the same as this[ 'myKey' ] = 3
// or this.myKey = 3
// displays 3
this.set( 'myKey', 3 );
@example <caption>Using ``eventOptions``</caption>
this.on( 'change:myKey', function( eventOptions ) {
	alert( eventOptions.value );
});

// handler isn't called
this.set( 'myKey', 4, {
	silent: true
});

@example <caption>Passing custom data to a handler</caption>
this.on( 'change:myKey', function( eventOptions ) {
	alert( eventOptions.myCustomFlag );
});

// displays 42
this.set( 'myKey', 4, {
	myCustomFlag: 42
});
*/


/**
@method Matreshka#set
@variation 2
@summary Alternative "key-value" syntax of the {@link Matreshka#set} method
@param {object} keyValuePairs - An object containing key-value pairs
@param {eventOptions} [eventOptions] - An event object
@example
this.set({
	myKey1: 1,
	myKey2: 2
});
@example <caption>Passing  ``eventOptions`` as second argument</caption>
this.set({
	myKey: 3
}, {
	myFlag: 'Jigurda'
});
*/


/**
@method Matreshka#remove
@fires delete
@fires delete:KEY
@summary Deletes a property
@param {string} key - A key or keys which are separated by a space
@param {eventOptions} [eventOptions] - An event object
@returns {matreshka} self
@example
this.remove( 'myKey' );
this.remove( 'myKey1 myKey2' );
@example <caption>using  ``eventOptions``</caption>
this.remove( 'myKey', {
	silent: true
});
*/


/**
@method Matreshka#define
@summary Overrides a property descriptor completely using ``Object.defineProperty``
@desc Note, ``Object.defineProperty``  works incorrectly in Internet Explorer 8. Use this method only when you know what you are doing.
@param {string} key - A key
@param {function} descriptor - A descriptor
@returns {matreshka} self
@example
this.define( 'myKey', {
	get: function() { ... }
	set: function() { ... }
});
*/


/**
@method Matreshka#define
@variation 2
@summary Alternative "key-descriptor" syntax for the {@link Matreshka#define} method
@desc The work of the method is very similar to ``Object.defineProperties``
@param {object} keyObjectPairs - The object containing key-descriptor pairs
@returns {matreshka} self
@example
this.define({
	myKey1: {
		get: function() { ... }
		set: function() { ... }
	},
	myKey2: {
		get: function() { ... }
		set: function() { ... }
	}
});
*/

/**
@method Matreshka#delay
@since 0.3
@summary Calls given function after timed delay
@desc The work of the method is very similar to ``setTimeout``. A current instance or a passed object is taken as a context.
@see {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers.setTimeout setTimeout on MDN}
@param {function} f - A function which must be called after the timer has expired
@param {number} [delay=0] - A delay in milliseconds
@param {object} [thisArg] - A context
@returns {matreshka} self
@example
this.on( 'change:x', function() {
	alert( this.x ); // 1 ... 2
});

this.delay( function() {
	this.x = 2;
}, 100 );

this.x = 1;
*/

/**
@method Matreshka#getAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything
@since 0.4
@summary Computes the answer to the Ultimate Question of Life, the Universe, and Everything and displays the answer in 7.5 million years.
@example
this.getAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything();
*/

/**
@method Matreshka.extend
@summary A little additional function which extends one object by means of the other object properties
@prop {object} o1
@prop {...object} o2
@returns {object} o1
@example
var o1 = { a: 3 },
	o2 = { b: 4 };

MK.extend( o1, o2 );
*/


/**
@member {string} Matreshka.version
@summary The version of Matreshka
@example
alert( Matreshka.version );
*/


/**
@method Matreshka.Class
@since 0.2
@summary A link to the {@link Class} global function
@desc This way of using the ``Class`` function is applied when the application you develop uses {@link https://github.com/amdjs/amdjs-api/blob/master/AMD.md AMD}
@example
MK.Class({
	method: function() {}
});

// the same as
Class({
	method: function() {}
});
*/


/**
@method Matreshka.$
@variation static
@summary A library used by Matreshka (jQuery, Zepto, {@link Matreshka.$b Balalaika} or others)
@example
MK.$( '.my-element' );
*/


/**
@method Matreshka.$b
@summary a built-in micro-library {@link $b Balalaika}
@example
MK.$b( '.my-element' );
*/


/**
@method Matreshka.useAs$
@since 0.2
@summary Forces to use a definite DOM-library
@desc By default, Matreshka uses the library which can be found by reference ``window.$``. If there is no such a variable in the global namespace or it does not include  a necessary set of methods, the built-in micro-library {@link $b Balalaika} is used.

The {@link Matreshka.useAs$} method makes Matreshka use the library you would like to use in spite of its absence in the global namespace or for a different reason (for example, if two different versions of jQuery are used on the page). It is desirable to launch the method before your code starts.
@param {function} $ - Any library (jQuery, Zepto, Balalaika or others)
@example
Matreshka.useAs$( jQuery.noConflict() );
*/


/**
@member {boolean} Matreshka.isXDR
@summary If Matreshka uses a XDomainRequest hack. In other words, if the current browser is Internet Explorer 8
@example
alert( Matreshka.isXDR );
*/


/**
@member {array} Matreshka.defaultBinders
@enum {function}
@summary An array of functions which return the corresponding binder
@desc {@link Matreshka.defaultBinders} - The array of functions which check the element in turn against the given rules in these functions and return the binder (see {@link #typedef-binder}). This method is used when the third argument has not been passed to the {@link Matreshka#bindNode} method. See more detailed information about bindings in the documentation of {@link Matreshka#bindNode}.
@see {@link Matreshka#bindNode}
@see {@link Matreshka.lookForBinder}
@example <caption>A custom checkbox</caption>
// add the binder to the collection of binders
MK.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $( this ).hasClass( 'checked' );
		},
		setValue: function( v ) {
			$( this ).toggleClass( 'checked', !!v );
		},
		initialize: function() {
			$( this ).toggleClass( 'checked' );
		}
	}
};

// the unshift method adds the function to the beginning of the  Matreshka.defaultBinders array
MK.defaultBinders.unshift( function( element ) {
	// check if the element has the "custom-checkbox" class name
	if( $( element ).hasClass( 'custom-checkbox' ) ) {
		// if checking is OK, return a new binder
		return MK.binders.customCheckbox();
	}
});

// ...

this.bindNode( 'myKey', '.custom-checkbox' );
*/


/**
@method Matreshka.noop
@summary An empty function which does nothing
@example
this.on( 'x', MK.noop );
*/


/**
@method Matreshka.each
@summary Iterates any object running its every property through ``callback`` function
@desc This static method is similar to the work of ``Array.prototype.forEach``.
@param {object} o - An object
@param {function} callback - A function which is launched on every iteration
@param {*} [thisArg] - An object which is used as ``this`` on calling ``callback``
@example
var myObject = {
	a: 1,
	b: 2
};
MK.each( myObject, function( value, key ) {
	// ...
});
*/


/**
@method Matreshka.debounce
@since 0.3
@summary Calls a function only once after the timer has expired. At every attempt of launching the timer is updated.
@desc This method is an implementation of the **debounce** micro pattern which solves the problem of the multiple call of a function for a certain period of time. See the example and {@link http://davidwalsh.name/javascript-debounce-function JavaScript Debounce Function}.
@param {function} f - The original function
@param {number} [duration=0] - The delay
@param {*} [thisArg] - The context which the function must be launched in
@example
var debounced = MK.debounce( function( x ) {
	console.log( x );
}, 10 );

for( var i = 0; i < 100; i++ ) {
	debounced( i );
}

// >>> 99
*/

/**
@method Matreshka.lookForBinder
@desc Returns a binder corresponding to an element. If it is not found, it returns ``undefined``. The function uses {@link Matreshka.defaultBinders}.
@see {@link Matreshka#bindNode}
@see {@link Matreshka.defaultBinders}
@param {node} node
@returns {object} properties
@example
console.log( Matreshka.lookForBinder( $( 'input[type="text"]' ) ) );

// will return the object
{
	on: 'keyup paste',
	getValue: function() { return this.value; },
	setValue: function( v ) {
		if( this.value != v ) {
			this.value = v;
		}
	}
}
*/

/**
@method Matreshka.randomString
@summary The function which returns a unique pseudo-random string.
@desc The ``new Date().getTime`` and ``Math.random()`` functions are used for generating a string, so the returned string is unique.
@returns {string} A random string
@example
var id = MK.randomString();
*/


/**
@method Matreshka.to
@since 1.1
@summary Docs are coming soon...
@returns {matreshka}
@example
var mk = MK.to({
	a: 1,
	b: {
		c: 2
	},
	d: [{e: 1}, {e: 2}, {e: 3}]
});
*/