/**
@method Matreshka#bindNode
@importance 1
@fires bind
@fires bind:KEY
@summary Связывает свойство объекта с HTML элементом
@desc {@link Matreshka#bindNode} - это единственный метод класса {@link Matreshka}, отвечающий за изменения DOM. Он создаёт мост между значением свойства и состоянием HTML элемента на странице: от простого инпута до сложного виджета (сложность элементов не ограничена).  После связывания свойства экземпляра и HTML элемента не нужно больше следить за синхронизацией данных и представления.

Для двустороннего связывания элемента и значения свойства, в метод передаются три аргумента: **имя свойства** (ключ), **HTML элемент** (или селектор) и **правило привязки** (синонимы: байндер, биндер, binder, привязчик). Байндер, в свою очередь, является обычным объектом и может иметь следующие свойства: ``on``, ``getValue``, ``setValue``, ``initialize``, ``destroy`` (подробнее см. {@link #typedef-binder}). Все пять свойств опциональны. Это позволяет также объявлять и односторонние привязки.

> Метод ``bindNode`` поддерживает привязки "многие ко многим". С одним свойством можно связать несколько элементов, а с одним элементом можно связать несколько свойств, в том числе и от разных экземпляров разных классов.

```js
this.bindNode('myKey', '.my-element', {
	on: 'click',
	getValue: function() { ... },
	setValue: function() { ... }
});
```

Например, вы хотите связать свойство объекта с элементом ``input[type="checkbox"]``:
```js
this.bindNode('myKey', '.my-checkbox', {
	// когда менятся состояние элемента?
	// - по событию 'click'
	on: 'click',
	// как извлечь состояние элемента?
	// - вернуть значение 'checked'
	getValue: function() {
		return this.checked;
	},
	// как установить состояние элемента?
	// - установить значение 'checked'
	setValue: function(v) {
		this.checked = !!v;
	}
});
```

После объявления привязки можно устанавливать значение свойства объекта самым привычным способом, а элемент (в данном случае, чекбокс) моментально изменит своё состояние. При клике на чекбокс, значение свойства тоже изменится на соответствующее.
```js
// устанавливает checked = true
this.myKey = true;
```


Более сложный пример: связывание свойства объекта с виджетом jQuery UI
```html
<div class="my-slider"></div>
```

```js
this.bindNode('myKey', '.my-slider', {
	// когда менятся состояние элемента?
	// - по событию 'slide'
	on: 'slide',
	// как извлечь состояние элемента?
	// - вернуть значение виджета 'value'
	getValue: function() {
		return $(this).slider('option', 'value');
	},
	// как установить состояние элемента?
	// - установить значение 'value'
	setValue: function(v) {
		$(this).slider('option', 'value', v);
	},
	// как инициализировать виджет?
	// инициализировать слайдер можно любым способом,
	// но initialize предоставляет немного синтаксического сахара
	initialize: function() {
		$(this).slider({min: 0, max: 100});
	}
});
```

```js
// установит знaчeние слайдера 42
this.myKey = 42;
```

Выглядит просто, но вы, скорее всего, задаётесь вопросом: "Как сделать так, чтоб мне не пришлось каждый раз прописывать эти правила?". Вопрос очень правильный. Действительно, на странице может быть очень много однотипных элементов: текстовых полей, выпадающих меню, новых полей из спецификации HTML5, могут быть и сторонние виджеты (о чем говорит пример выше).

Как видно из документации к аргументам метода {@link Matreshka#bindNode} (см. ниже), третий аргумент не обязателен. Этот вопрос решает массив {@link Matreshka.defaultBinders}, который содержит функции, проверяющие HTML элемент на соответствие заданным правилам. Вы получаете возможность многократно сократить код, вынося правила привязки в отдельную часть вашего кода, а для привязки использовать синтаксис без третьего аргумента:
```js
this.bindNode('myKey', '.my-element');
```
Как это сделать? Нужно добавить функцию, проверяющую ваш элемент на соответствие некоторым правилам в начало массива {@link Matreshka.defaultBinders}. Пример ниже можно использовать в качестве шаблона для создания своего "стандартного байндера".
```js
// добавляем байндер в коллекцию байндеров
// это нужно для того, чтоб сохранить возможность переопределения
Matreshka.binders.checkbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return this.checked;
		},
		setValue: function(v) {
			this.checked = !!v;
		}
	}
};

// метод unshift добавляет функцию в начало массива Matreshka.defaultBinders
Matreshka.defaultBinders.unshift(function(node) {
	// проверяем, является ли элемент чекбоксом
	if(node.tagName == 'INPUT' && node.type == 'checkbox') {
		// если проверка пройдена, возвращаем новый байндер
		return Matreshka.binders.checkbox();
	}
});
```
```js
this.bindNode('myKey', '.my-checkbox');
this.myKey = true;
```

Что делать, если вам нужно передать аргументы для инициализации какого-нибудь плагина или виджета? Всё очень просто: можно ограничиться добавлением байндера в коллекцию {@link Matreshka.binders}, не создавая функцию для {@link Matreshka.defaultBinders}.
```js
Matreshka.binders.uiSlider = function(min, max) {
	return {
		on: 'slide',
		getValue: function() {
			return $(this).slider('option', 'value');
		},
		setValue: function(v) {
			$(this).slider('option', 'value', v);
		},
		initialize: function() {
			$(this).slider({min: min, max: max});
		}
	}
};
```
```js
this.bindNode('myKey1', '.my-slider1', Matreshka.binders.uiSlider(0, 100));
this.bindNode('myKey2', '.my-slider2', Matreshka.binders.uiSlider(1, 1000));
this.myKey1 = 42;
this.myKey2 = 999;
```


{@link Matreshka.defaultBinders} из коробки, начиная с версии 0.3, содержит поддержку **всех без исключения** HTML элементов форм: ``select`` (включая ``multiple``), ``textarea``, ``output``,``input`` (в том числе и все типы из спецификации HTML5: ``text``, ``checkbox``, ``radio``, ``range``, ``number``, ``date``, ``search``, ``time``, ``datetime``, ``datetime-local``, ``color`` и остальных). Это значит, что для стандартных элементов указывать байндер вовсе не обязательно.
```html
<input type="color" class="my-color-input">
```
```js
this.bindNode('myColor', '.my-color-input');
this.myColor = '#66bb6a';
```


Кроме всего, после привязки, вам доступен новый нестандартный CSS селектор ``:bound(KEY)``.
```js
this.bindNode('myKey', '.my-element');

// найдет элемент '.my-inner-element' внутри '.my-element'
this.bindNode('myAnotherKey', ':bound(myKey) .my-inner-element');
```

И расширяется синтаксис возможных имен событий:
```js
this.bindNode('myKey', '.my-element');

// отловит клик на элементе .my-element
this.on('click::myKey', function() { ... });

// отловит клик на элементе .my-element .my-inner-element
this.on('click::myKey(.my-inner-element)', function() { ... });
```


#### Создание песочницы
{@link Matreshka#bindNode} умеет ассоциировать экземпляр класса с "главным" HTML элементом, создавая так называемую **песочницу**. Это нужно для того, чтоб ограничить влияние экземпляра на HTML элементы, содержащиеся в другой песочнице (т. е. в другом HTML элементе). Для привязки песочницы используется специальное свойство ``'sandbox'``.
```html
<div class="my-sandbox">
	<!-- your HTML code -->
</div>
```

```js
this.bindNode('sandbox', '.my-sandbox');
```

Определение песочницы добавляет множество удобств программисту. Например:
+ Позволяет использовать методы {@link Matreshka#select} и {@link Matreshka#$}
+ Добавляет новый селектор ``:sandbox`` в методах {@link Matreshka#bindNode}, {@link Matreshka#select}, {@link Matreshka#$}
+ Добавляет синтаксический сахар для делегированных DOM событий в методе {@link Matreshka#on}

> Для объявления песочницы можно воспользоваться методом {@link Matreshka#bindSandbox}, который требует только один аргумент.

```js
// объявляем песочницу
this.bindNode('sandbox', '.my-sandbox');

// .my-element ищется в песочнице
this.bindNode('myKey', ':sandbox .my-element');

// для делегированных событий внутри песочницы не требуется указывать ключ
this.on('click::(.my-button)', function() { ... });

// выведет в консоль элемент .inner-node, который находится внутри песочницы
console.log(this.$('.inner-node'));
```

--------govno start
> Изменения DOM происходят синхронно, сразу после изменения свойства. Для того, чтоб DOM менялся после небольшой задержки только один раз, несмотря на то, как часто меняется свойство, передайте в аргумент ``eventOptions`` свойство ``debounce: true``. См.  {@link Matreshka.debounce}.

> Если значение свойства экземпляра класса не задано, Матрешка, после привязки, попробует извлечь это значение из HTML узла, используя ``getValue``. Отменить это поведение можно передав свойство ``assignDefaultValue: false`` в объект события.
```js
this.bindNode('myKey', '.my-element', binder, {
	assignDefaultValue: false
});
```

#### Глубокое связывание
Начиная с версии 1.1, метод ``bindNode`` поддерживает так называемое "глубокое связывание". Метод научился связывать DOM узел со свойством внутри дерева вложенных объектов. Например, у вас есть вложенный объект:
```js
this.a = {b: {c: {d: 42}}};
```

И вы хотите связать некий узел со свойством ``d`` из этого объекта. Достаточно только указать путь к свойству, а Матрешка будет слушать изменения во всём дереве объектов, то разрывая связь, то создавая её вновь:

```js
this.bindNode('a.b.c.d', '.my-node');
```

Когда произойдут какие-нибудь изменения в дереве, ``bindNode`` отловит эти изменения и пересоздаст связь между свойством и нодой.

```js
this.a.b = {c: {d: 41}};
```

> Это поведение можно отменить, передав свойство ``deep: false`` в объект события (``eventOptions``), тогда точка в имени свойства будет проигнорирована.
--------govno end

@see {@link Matreshka#unbindNode}
@see {@link Matreshka#bindOptionalNode}
@see {@link Matreshka#$}
@see {@link Matreshka.binders}
@see {@link Matreshka.defaultBinders}


@param {string|matreshka} key - Ключ (имя свойства)
@param {string|node|$nodes} node - HTML элемент, который должен быть связан со свойством экземпляра
@param {binder} [binder] - Байндер (привязчик), содержащий следующие свойства: ``on`` - какое событие должно произойти на HTML элементе, говорящее о том, что пользователь что-то изменил (например, ``keyup`` или ``click``), ``getValue`` - как извлечь значение из HTML элемента, ``setValue`` - как установить новое значение элементу и ``initialize`` - функция, выполняющаяся однажды, при инициализации привязки. Более подробно о привязчиках можно найти в документации к ним: см. {@link #typedef-binder}.
@param {eventOptions} [eventOptions] - Объект события, в который можно передать ключ ``"silent"`` (не генерировать события ``"bind"`` и ``"bind:KEY"``), ``"assignDefaultValue"`` (извлечь ли текущее значение элемента при привязке), ``debounce`` (оптимизировать ли изменения DOM), ``deep`` (использовать ли "глубокое связывание" или игнорировать точку в имени свойства) или другие данные
@returns {matreshka} self

@example <caption>Кастомный чекбокс. Этот пример демонстрирует создание кастомного элемента, по клику на который у него меняется класс ``"checked"``</caption>
this.bindNode('myKey', '.custom-checkbox', {
	on: 'click',
	getValue: function() {
		return $(this).hasClass('checked');
	},
	setValue: function(v) {
		$(this).toggleClass('checked', !!v);
	},
	// инициализируем поведение элемента
	// по клику на элемент меняется наличие класса 'checked'
	initialize: function() {
		$(this).on('click', function() {
			$(this).toggleClass('checked');
		});
	}
});

@example <caption>Кастомный чекбокс 2. Этот пример повторяет предыдущий, но использует {@link Matreshka#defaultBinders}, и проверяет элемент на наличие класса ``custom-checkbox``. Если проверка пройдена, возвращает байндер</caption>
// добавляем байндер в коллекцию байндеров
Matreshka.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $(this).hasClass('checked');
		},
		setValue: function(v) {
			$(this).toggleClass('checked', !!v);
		},
		initialize: function() {
			$(this).on('click', function() {
				$(this).toggleClass('checked');
			});
		}
	}
};

MK.defaultBinders.unshift(function(element) {
	// проверяем, есть ли у элемента класс "custom-checkbox"
	if($(element).hasClass('custom-checkbox') ) {
		// если проверка пройдена, возвращаем новый байндер
		return Matreshka.binders.customCheckbox();
	}
});

this.bindNode('myKey', '.my-custom-checkbox');

@example <caption>Событие ``"bind"``, которое генерируется после связывания любого свойства и HTML узла</caption>
this.on('bind', function() { alert('ok!'); });
this.bindNode('myKey', '.my-element'); // alerts "ok!"

@example <caption>Событие ``"bind:KEY"``, которое генерируется при связывании конкретного свойства и HTML узла</caption>
this.on('bind:myKey', function() { alert('ok!'); });
this.bindNode('myKey', '.my-element'); // alerts "ok!"

@example <caption>Подмена DOM события для стандартного байндера. Например, мы хотим связать ``input[type="text"]`` со свойством. По умолчанию, стандартный байндер для этого элемента содержит свойство ``"on"`` со значением ``"keydown paste"``. Это значит, что значение свойства экземпляра и состояние элемента будут синхронизированы, когда пользователь отпускает клавишу клавиатуры или вставляет содержимое из буфера обмена. В случае, если вы хотите, чтоб синхронизация происходила по DOM событию ``"blur"``, вам потребуется передать третьим аргументом объект, содержащий единственное свойство ``"on"``. Этот объект объединится со стандартным байндером, сохранив при этом значения ``getValue`` и ``setValue``</caption>
this.bindNode('myKey', '.my-input', {on: "blur"});


@example <caption>Если элемент не найден, бросается исключение ``"Bound element is missing"``. Для того, чтоб избежать ошибки используйте метод {@link Matreshka#bindOptionalNode}</caption>
var $el = $();
this.bindNode('x', $el); // Ошибка, так как $el пуст

@example <caption>Синхронизация значения свойства и HTML содержимого элемента</caption>
this.bindNode('myKey', '.my-element', {
	setValue: function(v) {
		this.innerHTML = v;
	}
});

// можно сделать проще
this.bindNode('myKey', '.my-element', MK.binders.html());
*/


/**
@method Matreshka#bindNode
@importance 2
@variation 2
@summary Альтернативный синтаксис: пары "ключ-элемент"
@desc В метод {@link Matreshka#bindNode} можно передать объект с парами ключ-элемент, чтобы избежать многократного вызова метода и сократить код

@param {object} keyElementPairs - (см. пример)
@param {binder} [binder] - (см. выше)
@param {eventOptions} [eventOptions] - (см. выше)

@example
this.bindNode({
	myKey1: '.custom-checkbox',
	myKey2: 'textarea'
});

@example <caption>Начиная с версии 1.1 синтаксис метода немного расширился: вместо элемента, можно передать массив, состоящий из элемента и байндера</caption>
this.bindNode({
	myKey1: ['.custom-checkbox', MK.binders.customCheckbox()],
	myKey2: 'textarea',
	myKey3: ['.my-node', {
		setValue: function(v) {
			// do something
		}
	}]
});
*/


/**
@method Matreshka#bindNode
@importance 2
@variation 3
@summary Альтернативный синтаксис "куча аргументов"
@desc Еще один синтаксис для метода {@link Matreshka#bindNode}. Этот способ может показаться непривлекательным, но, иногда, есть нужда привязать много элементов с различными байндерами за один присест. С таким синтаксисом вы можете присвоить определенные байндеры какой-нибудь переменной, затем легко удалить все и сразу, используя {@link Matreshka#unbindNode}.

@param {array} setOfArguments - Массив массивов аргументов (см. пример)
@param {eventOptions} [eventOptions] - (см. выше)

@example
this.bindNode([
	[{
		myKey1: '.my-element1',
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3',
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5',
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
]);
*/
