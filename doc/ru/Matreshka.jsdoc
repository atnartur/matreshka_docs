/**
@class Matreshka
@importance 1
@lang ru
@author Андрей Губанов <a@odessite.com.ua>
@license {@link https://raw.github.com/finom/matreshka/master/LICENSE MIT}
Version 2.0, January 2004
@alias MK
@see {@link Class}
@classdesc Класс Matreshka - ядро фреймворка Matreshka.js, от которого наследуются {@link Matreshka.Array}, {@link Matreshka.Object} и каждый класс создаваемого приложения. Он содержит основной функционал фреймворка, среди которого есть несколько полезнейших функций: {@link Matreshka#mediate медиаторы}, {@link Matreshka#linkProps зависимости}, {@link Matreshka#bindNode привязки к DOM}, {@link Matreshka#on движок событий} и пр. Наследование этого класса, как и наследование любого другого класса, осуществляется при помощи функции {@link Class}.

Как правило, этот класс, (как и {@link Matreshka.Array} и {@link Matreshka.Object}), не используются напрямую. Вместо этого, от него наследуются классы, создаваемые вами. Поэтому, примеры к свойствам и методам в этой документации, как правило, будут приведены с использованием ключевого слова ``this``.
@example <caption>Создание экземпляра</caption>
var mk = new Matreshka;
@example <caption>Краткая запись: MK вместо Matreshka</caption>
var mk = new MK;
@example <caption>Наследование</caption>
var MyClass = MK.Class({
	'extends': Matreshka,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});
@example <caption>Матрешка использует прототипы для реализации наследования. Функция {@link Class} лишь вносит синтаксический сахар. Поэтому вы можете воспользоваться любым другим полюбившимся способом наследования, например, используя классы из ECMAScript 2015</caption>
class MyClass extends Matreshka {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}
*/


/**
@member {boolean} Matreshka#isMK
@importance 3
@summary ``isMK`` всегда равен ``true``. Это свойство используется для того, чтоб определить, является ли объект экземпляром класса {@link Matreshka}
@example
alert(object.isMK);
*/


/**
@member {$nodes} Matreshka#$nodes
@importance 2
@since 1.1
@summary Объект содержит коллекции (jQuery, Zepto, bQuery) привязанных элементов для быстрого доступа.
@see {@link Matreshka#bindNode}
@example
this.bindNode('myKey', '.my-node');
this.$nodes.myKey; // то же самое, что и $('.my-node')
*/

/**
@member {node} Matreshka#nodes
@importance 2
@since 1.1
@summary Объект содержит привязанные элементы для быстрого доступа, в виде отдельных DOM узлов.
@desc Обратите внимание, каждое свойство объекта содержит первый узел из связанных с соотвутствующим свойством.  Для получения всех узлов, связанных с определенным свойством, используйте {@link Matreshka#$nodes}.
@see {@link Matreshka#bindNode}
@example
this.bindNode('myKey', '.my-node');
this.nodes.myKey; // то же самое, что и $('.my-node')[0]
*/


/**
@method Matreshka#on
@importance 1
@fires addevent
@fires addevent:NAME
@summary Добавляет обработчик события
@desc Метод {@link Matreshka#on} добавляет обработчик события для экземпляра класса ``Matreshka``. Полный список возможных событий с описанием см. здесь: {@link #typedef-eventNames}.
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@param {eventNames} names - Имя события или несколько имен, разделенных пробелом  (например, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} callback - Функция, которая вызывается по событию
@param {boolean} [triggerOnInit=false] - Если аргумент ``triggerOnInit`` равен ``true``, то обработчик будет вызван немедленно после инициализации.
@param {object} [context] - Контекст обработчика. Другими словами, ``this`` при вызове ``callback``
@returns {matreshka} self
@example
this.on('foo', function() {
	alert('Custom Event is fired');
});

this.trigger('foo');
@example <caption>Передача контекста</caption>
this.on('foo', function() {
	alert(this.a); // 5
}, {a: 5});

this.trigger('foo', 'Hello world');
@example <caption>Вызов обработчика сразу после инициализации</caption>
//Выводит на экран "bar" сиюсекундно и ждет генерации события "foo"
this.on('foo', function() {
	alert('bar');
}, true);
*/


/**
@method Matreshka#on
@importance 2
@variation 2
@since 1.1
@summary Альтернативный синтаксис: пары "событие-обработчик"
@desc В метод {@link Matreshka#on} можно передать объект с парами событие-обработчик, чтобы избежать многократного вызова метода и сократить код.

@param {object} evtnameHandlerObject - Объект с событиями
@param {boolean} [triggerOnInit=false] - Если аргумент ``triggerOnInit`` равен ``true``, то обработчики будут вызван немедленно после инициализации
@param {object} [context] - Контекст обработчика
@returns {matreshka} self
@example
this.on({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});

@example <caption>Особенно круто этот способ вызова метода ``on`` выглядит с использованием синтаксиса ECMAScript 2015</caption>
this.on({
	'custom': evt => ...,
	'click::x': evt => ...,
	'change:y': evt => ...,
});
*/


/**
@method Matreshka#onDebounce
@importance 2
@fires addevent
@fires addevent:NAME
@summary Добавляет обработчик события, вызываемый лишь однажды за определенный промежуток времени
@desc Метод позволяет добавить обработчик события на экземпляр класса {@link Matreshka}, устраняя "дребезжание" обработчика. Функция может быть вызвана лишь один раз за определенный промежуток времени. В остальном, метод работает так же, как и {@link Matreshka#on}.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@see {@link Matreshka.debounce}
@see {@link http://habrahabr.ru/post/60957/ Статья на Хабре о микропаттерне debounce}
@param {eventNames} names - Имя события или несколько имен, разделенных пробелом  (например, ``"change:x ajaxcomplete change:y"``).
@param {eventHandler} callback - Функция, которая вызывается по событию
@param {number} [debounceDelay=0] - Задержка
@param {boolean} [triggerOnInit=false] - Если аргумент ``triggerOnInit`` равен ``true``, то обработчик будет вызван немедленно после инициализации
@param {object} [context] - Контекст обработчика. Другими словами, ``this`` при вызове ``callback``
@returns {matreshka} self
@example
this.onDebounce('change:x', function() {
	alert('x = ' + this.x); // x = 100
}, 300);

this.x = 1;

for(var i = 0; i < 100; i++) {
	this.x++;
}
*/


/**
@method Matreshka#onDebounce
@importance 2
@variation 2
@since 1.1
@summary Альтернативный синтаксис: пары "событие-обработчик"
@desc В метод {@link Matreshka#onDebounce} можно передать объект с парами событие-обработчик, чтобы избежать многократного вызова метода и сократить код.
@see {@link Matreshka#on(2)}
@param {object} evtnameHandlerObject - Объект с событиями
@param {number} [debounceDelay=0] - Задержка
@param {boolean} [triggerOnInit=false] - Если аргумент ``triggerOnInit`` равен ``true``, то обработчики будут вызван немедленно после инициализации
@param {object} [context] - Контекст обработчиков
@returns {matreshka} self
@example
this.onDebounce({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});
*/


/**
@method Matreshka#once
@importance 2
@fires addevent
@fires addevent:NAME
@summary Добавляет обработчик событий, который может быть вызван однажды
@desc Метод работает так же, как и {@link Matreshka#on} но передаваемый обработчик может быть вызван только один раз.
Обратите внимание, что у метода отсутствует аргумент <code>triggerOnInit</code>.
@see {@link Matreshka#on}
@see {@link Matreshka#off}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} names - Имя события или несколько имен, разделенных пробелом (например, <code>"change:x ajaxcomplete change:y"</code>)
@param {eventHandler} callback - Функция, которая вызывается по событию
@param {object} [context] - Контекст обработчика
@returns {matreshka} self
@example
this.x = 1;

this.once('change:x', function() {
	alert('x is changed');
});

this.x = 2; // выводит 'x is changed'

this.x = 3; // ничего не делает
*/


/**
@method Matreshka#once
@importance 2
@variation 2
@since 1.1
@summary Альтернативный синтаксис: пары "событие-обработчик"
@desc В метод {@link Matreshka#once} можно передать объект с парами событие-обработчик, чтобы избежать многократного вызова метода и сократить код.
@see {@link Matreshka#on(2)}
@param {object} evtnameHandlerObject - Объект с событиями
@param {object} [context] - Контекст обработчиков
@returns {matreshka} self
@example
this.once({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});
*/


/**
@method Matreshka#off
@importance 1
@fires removeevent
@fires removeevent:NAME
@summary Удаляет обработчик события
@desc Удаляет созданный ранее обработчик. Все три аргумента опциональны. Вы можете удалить как все события (не передавая ни одного аргумента), так и отдельные (передав только имя события, передав имя события и обработчик, передав и имя события, и обработчик, и контекст)
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} [names] - Разделенный пробелами список имен событий (например, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} [callback] - Функция-обработчик
@param {object} [context] - Контекст
@returns {matreshka} self
@example
this.off('change:x bind');
@example <caption>Удаление всех событий</caption>
this.off();
@example <caption>Удаление события с определенным обработчиком</caption>
var handler = function() {
	//...
}
this.on('change:x', handler);
this.off('change:x', handler);
@example <caption>Удаление события с определенным контекстом</caption>
var object = {};
this.on('change:x', handler, object);
this.off('change:x', handler, object);
*/


/**
@method Matreshka#trigger
@importance 1
@summary Генерирует событие
@desc После добавление обработчиков событий с помощью метода {@link Matreshka#on}, {@link Matreshka#onDebounce} или {@link Matreshka#once}, событие можно генерировать вручную с помощью этого метода.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#off}
@param {eventNames} [names] - Имя события или несколько имен, разделенных пробелом
@param {...*} [arg] - Аргументы, которые будут переданы обработчикам
@returns {matreshka} self
@example
this.on('foo bar', function(a, b, c) {
	alert(a + b + c);
});
this.trigger('bar', 1, 2, 3); // alerts 6
*/


/**
@method Matreshka#bindNode
@importance 1
@fires bind
@fires bind:KEY
@summary Связывает свойство объекта с HTML элементом
@desc {@link Matreshka#bindNode} - это единственный метод класса {@link Matreshka}, отвечающий за изменения DOM. Он создаёт мост между значением свойства и состоянием HTML элемента на странице: от простого инпута до сложного виджета (сложность элементов не ограничена). ``bindNode``, по праву, можно назвать главным методом фреймворка. После связывания свойства экземпляра и HTML элемента не нужно больше следить за синхронизацией данных и представления.

Для двустороннего связывания элемента и значения свойства, в метод передаются три аргумента: **имя свойства** (ключ), **HTML элемент** (или селектор) и **правило привязки** (синонимы: байндер, биндер, binder, привязчик). Байндер, в свою очередь, является обычным объектом и может иметь следующие свойства: ``on``, ``getValue``, ``setValue``, ``initialize`` (подробнее см. {@link #typedef-binder}). Все четыре свойства - опциональны. Это позволяет также объявить и односторонние привязки.

> Метод ``bindNode`` поддерживает привязки "многие ко многим". С одним свойством можно связать несколько элементов, а с одним элементом можно связать несколько свойств, в том числе и от разных экземпляров разных классов.

```js
this.bindNode('myKey', '.my-element', {
	on: 'click',
	getValue: function() { ... },
	setValue: function() { ... }
});
```

Например, вы хотите связать свойство объекта с элементом ``input[type="checkbox"]``:
```js
this.bindNode('myKey', '.my-checkbox', {
	// когда менятся состояние элемента?
	// - по событию 'click'
	on: 'click',
	// как извлечь состояние элемента?
	// - вернуть значение 'checked'
	getValue: function() {
		return this.checked;
	},
	// как установить состояние элемента?
	// - установить значение 'checked'
	setValue: function(v) {
		this.checked = !!v;
	}
});
```

После объявления привязки можно устанавливать значение свойства объекта самым привычным способом, а элемент (в данном случае, чекбокс) моментально изменит своё состояние. При клике на чекбокс, значение свойства тоже изменится на соответствующее.
```js
// устанавливает checked = true
this.myKey = true;
```

> Если значение свойства экземпляра класса не задано, Матрешка, после привязки, попробует извлечь это значение из HTML узла, используя ``getValue``. Отменить это поведение можно передав свойство ``assignDefaultValue: false`` в объект события.
```js
this.bindNode('myKey', '.my-element', binder, {
	assignDefaultValue: false
});
```

Более сложный пример: связывание свойства объекта с виджетом jQuery UI
```html
<div class="my-slider"></div>
```

```js
this.bindNode('myKey', '.my-slider', {
	// когда менятся состояние элемента?
	// - по событию 'slide'
	on: 'slide',
	// как извлечь состояние элемента?
	// - вернуть значение виджета 'value'
	getValue: function() {
		return $(this).slider('option', 'value');
	},
	// как установить состояние элемента?
	// - установить значение 'value'
	setValue: function(v) {
		$(this).slider('option', 'value', v);
	},
	// как инициализировать виджет?
	// инициализировать слайдер можно любым способом,
	// но initialize предоставляет немного синтаксического сахара
	initialize: function() {
		$(this).slider({min: 0, max: 100});
	}
});
```

```js
// установит знaчeние слайдера 42
this.myKey = 42;
```

Выглядит просто, но вы, скорее всего, задаётесь вопросом: "Как сделать так, чтоб мне не пришлось каждый раз прописывать эти правила?". Вопрос очень правильный. Действительно, на странице может быть очень много однотипных элементов: текстовых полей, выпадающих меню, новых полей из спецификации HTML5, могут быть и сторонние виджеты (о чем говорит пример выше).

Как видно из документации к аргументам метода {@link Matreshka#bindNode} (см. ниже), третий аргумент не обязателен. Этот вопрос решает массив {@link Matreshka.defaultBinders}, который содержит функции, проверяющие HTML элемент на соответствие заданным правилам. Вы получаете возможность многократно сократить код, вынося правила привязки в отдельную часть вашего кода, а для привязки использовать синтаксис без третьего аргумента:
```js
this.bindNode('myKey', '.my-element');
```
Как это сделать? Нужно добавить функцию, проверяющую ваш элемент на соответствие некоторым правилам в начало массива {@link Matreshka.defaultBinders}. Пример ниже можно использовать в качестве шаблона для создания своего стандартного байндера.
```js
// добавляем байндер в коллекцию байндеров
// это нужно для того, чтоб сохранить возможность переопределения
Matreshka.binders.checkbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return this.checked;
		},
		setValue: function(v) {
			this.checked = !!v;
		}
	}
};

// метод unshift добавляет функцию в начало массива Matreshka.defaultBinders
Matreshka.defaultBinders.unshift(function(node) {
	// проверяем, является ли элемент чекбоксом
	if(node.tagName == 'INPUT' && node.type == 'checkbox') {
		// если проверка пройдена, возвращаем новый байндер
		return Matreshka.binders.checkbox();
	}
});
```
```js
this.bindNode('myKey', '.my-checkbox');
this.myKey = true;
```

Что делать, если вам нужно передать аргументы для инициализации какого-нибудь плагина или виджета? Всё очень просто: можно ограничиться добавлением байндера в коллекцию {@link Matreshka.binders}, не создавая функцию для {@link Matreshka.defaultBinders}.
```js
Matreshka.binders.uiSlider = function(min, max) {
	return {
		on: 'slide',
		getValue: function() {
			return $(this).slider('option', 'value');
		},
		setValue: function(v) {
			$(this).slider('option', 'value', v);
		},
		initialize: function() {
			$(this).slider({min: min, max: max});
		}
	}
};
```
```js
this.bindNode('myKey1', '.my-slider1', Matreshka.binders.uiSlider(0, 100));
this.bindNode('myKey2', '.my-slider2', Matreshka.binders.uiSlider(1, 1000));
this.myKey1 = 42;
this.myKey2 = 999;
```

> Изменения DOM происходят синхронно, сразу после изменения свойства. Для того, чтоб DOM менялся после небольшой задержки только один раз, несмотря на то, как часто меняется свойство, передайте в аргумент ``eventOptions`` свойство ``debounce: true``. См.  {@link Matreshka.debounce}.

{@link Matreshka.defaultBinders} из коробки, начиная с версии 0.3, содержит поддержку **всех без исключения** HTML элементов форм: ``select`` (включая ``multiple``), ``textarea``, ``output``,``input`` (в том числе и все типы из спецификации HTML5: ``text``, ``checkbox``, ``radio``, ``range``, ``number``, ``date``, ``search``, ``time``, ``datetime``, ``datetime-local``, ``color`` и остальных). Это значит, что для стандартных элементов указывать байндер вовсе не обязательно.
```html
<input type="color" class="my-color-input">
```
```js
this.bindNode('myColor', '.my-color-input');
this.myColor = '#66bb6a';
```


Кроме всего, после привязки, вам доступен новый нестандартный CSS селектор ``:bound(KEY)``.
```js
this.bindNode('myKey', '.my-element');

// найдет элемент '.my-inner-element' внутри '.my-element'
this.bindNode('myAnotherKey', ':bound(myKey) .my-inner-element');
```

И расширяется синтаксис возможных имен событий:
```js
this.bindNode('myKey', '.my-element');

// отловит клик на элементе .my-element
this.on('click::myKey', function() { ... });

// отловит клик на элементе .my-element .my-inner-element
this.on('click::myKey(.my-inner-element)', function() { ... });
```


#### Создание песочницы
{@link Matreshka#bindNode} умеет ассоциировать экземпляр класса с "главным" HTML элементом на странице, создавая так называемую **песочницу**. Это нужно для того, чтоб ограничить влияние экземпляра на HTML элементы, содержащиеся в другой песочнице (т. е. в другом HTML элементе). Для привязки песочницы используется специальное свойство ``'sandbox'``.
```html
<div class="my-sandbox">
	<!-- your HTML code -->
</div>
```

```js
this.bindNode('sandbox', '.my-sandbox');
```

Определение песочницы добавляет множество удобств программисту. Например:
+ Позволяет использовать методы {@link Matreshka#select} и {@link Matreshka#$}
+ Добавляет новый селектор ``:sandbox`` в методах {@link Matreshka#bindNode}, {@link Matreshka#select}, {@link Matreshka#$} и других
+ Добавляет синтаксический сахар для делегированных DOM событий в методе {@link Matreshka#on}

> Для объявления песочницы можно воспользоваться методом {@link Matreshka#bindSandbox}, который требует только один аргумент.

```js
// объявляем песочницу
this.bindNode('sandbox', '.my-sandbox');

// .my-element ищется в песочнице
this.bindNode('myKey', ':sandbox .my-element');

// для делегированных событий внутри песочницы не требуется указывать ключ
this.on('click::(.my-button)', function() { ... });

// выведет в консоль элемент .inner-node, который находится внутри песочницы
console.log(this.$('.inner-node'));
```

#### Глубокое связывание
Начиная с версии 1.1, метод ``bindNode`` поддерживает так называемое "глубокое связывание". Метод научился связывать DOM узел со свойством внутри дерева вложенных объектов. Например, у вас есть вложенный объект:
```js
this.a = {b: {c: {d: 42}}};
```

И вы хотите связать некий узел со свойством ``d`` из этого объекта. Достаточно только указать путь к свойству, а Матрешка будет слушать изменения во всём дереве объектов, то разрывая связь, то создавая её вновь:

```js
this.bindNode('a.b.c.d', '.my-node');
```

Когда произойдут какие-нибудь изменения в дереве, ``bindNode`` отловит эти изменения и пересоздаст связь между свойством и нодой.

```js
this.a.b = {c: {d: 41}};
```

> Это поведение можно отменить, передав свойство ``deep: false`` в объект события (``eventOptions``), тогда точка в имени свойства будет проигнорирована.


@see {@link Matreshka#unbindNode}
@see {@link Matreshka#bindOptionalNode}
@see {@link Matreshka#$}
@see {@link Matreshka.binders}
@see {@link Matreshka.defaultBinders}


@param {string|matreshka} key - Ключ (имя свойства)
@param {string|node|$nodes} node - HTML элемент, который должен быть связан со свойством экземпляра
@param {binder} [binder] - Байндер (привязчик), содержащий следующие свойства: ``on`` - какое событие должно произойти на HTML элементе, говорящее о том, что пользователь что-то изменил (например, ``keyup`` или ``click``), ``getValue`` - как извлечь значение из HTML элемента, ``setValue`` - как установить новое значение элементу и ``initialize`` - функция, выполняющаяся однажды, при инициализации привязки. Более подробно о привязчиках можно найти в документации к ним: см. {@link #typedef-binder}.
@param {eventOptions} [eventOptions] - Объект события, в который можно передать ключ ``"silent"`` (не генерировать события ``"bind"`` и ``"bind:KEY"``), ``"assignDefaultValue"`` (извлечь ли текущее значение элемента при привязке), ``debounce`` (оптимизировать ли изменения DOM), ``deep`` (использовать ли "глубокое связывание" или игнорировать точку в имени свойства) или другие данные
@returns {matreshka} self

@example <caption>Кастомный чекбокс. Этот пример демонстрирует создание кастомного элемента, по клику на который у него меняется класс ``"checked"``</caption>
this.bindNode('myKey', '.custom-checkbox', {
	on: 'click',
	getValue: function() {
		return $(this).hasClass('checked');
	},
	setValue: function(v) {
		$(this).toggleClass('checked', !!v);
	},
	// инициализируем поведение элемента
	// по клику на элемент меняется наличие класса 'checked'
	initialize: function() {
		$(this).on('click', function() {
			$(this).toggleClass('checked');
		});
	}
});

@example <caption>Кастомный чекбокс 2. Этот пример повторяет предыдущий, но использует {@link Matreshka#defaultBinders}, и проверяет элемент на наличие класса ``custom-checkbox``. Если проверка пройдена, возвращает байндер</caption>
// добавляем байндер в коллекцию байндеров
Matreshka.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $(this).hasClass('checked');
		},
		setValue: function(v) {
			$(this).toggleClass('checked', !!v);
		},
		initialize: function() {
			$(this).on('click', function() {
				$(this).toggleClass('checked');
			});
		}
	}
};

MK.defaultBinders.unshift(function(element) {
	// проверяем, есть ли у элемента класс "custom-checkbox"
	if($(element).hasClass('custom-checkbox') ) {
		// если проверка пройдена, возвращаем новый байндер
		return Matreshka.binders.customCheckbox();
	}
});

this.bindNode('myKey', '.my-custom-checkbox');

@example <caption>Событие ``"bind"``, которое генерируется после связывания любого свойства и HTML узла</caption>
this.on('bind', function() { alert('ok!'); });
this.bindNode('myKey', '.my-element'); // alerts "ok!"

@example <caption>Событие ``"bind:KEY"``, которое генерируется при связывании конкретного свойства и HTML узла</caption>
this.on('bind:myKey', function() { alert('ok!'); });
this.bindNode('myKey', '.my-element'); // alerts "ok!"

@example <caption>Подмена DOM события для стандартного байндера. Например, мы хотим связать ``input[type="text"]`` со свойством. По умолчанию, стандартный байндер для этого элемента содержит свойство ``"on"`` со значением ``"keydown paste"``. Это значит, что значение свойства экземпляра и состояние элемента будут синхронизированы, когда пользователь отпускает клавишу клавиатуры или вставляет содержимое из буфера обмена. В случае, если вы хотите, чтоб синхронизация происходила по DOM событию ``"blur"``, вам потребуется передать третьим аргументом объект, содержащий единственное свойство ``"on"``. Этот объект объединится со стандартным байндером, сохранив при этом значения ``getValue`` и ``setValue``</caption>
this.bindNode('myKey', '.my-input', {on: "blur"});


@example <caption>Если элемент не найден, бросается исключение ``"Bound element is missing"``. Для того, чтоб избежать ошибки используйте метод {@link Matreshka#bindOptionalNode}</caption>
var $el = $();
this.bindNode('x', $el); // Ошибка, так как $el пуст

@example <caption>Синхронизация значения свойства и HTML содержимого элемента</caption>
this.bindNode('myKey', '.my-element', {
	setValue: function(v) {
		this.innerHTML = v;
	}
});

// можно сделать проще
this.bindNode('myKey', '.my-element', MK.binders.html());
*/


/**
@method Matreshka#bindNode
@importance 2
@variation 2
@summary Альтернативный синтаксис: пары "ключ-элемент"
@desc В метод {@link Matreshka#bindNode} можно передать объект с парами ключ-элемент, чтобы избежать многократного вызова метода и сократить код

@param {object} keyElementPairs - (см. пример)
@param {binder} [binder] - (см. выше)
@param {eventOptions} [eventOptions] - (см. выше)

@example
this.bindNode({
	myKey1: '.custom-checkbox',
	myKey2: 'textarea'
});

@example <caption>Начиная с версии 1.1 синтаксис метода немного расширился: вместо элемента, можно передать массив, состоящий из элемента и байндера</caption>
this.bindNode({
	myKey1: ['.custom-checkbox', MK.binders.customCheckbox()],
	myKey2: 'textarea',
	myKey3: ['.my-node', {
		setValue: function(v) {
			// do something
		}
	}]
});
*/


/**
@method Matreshka#bindNode
@importance 2
@variation 3
@summary Альтернативный синтаксис "куча аргументов"
@desc Еще один синтаксис для метода {@link Matreshka#bindNode}. Этот способ может показаться непривлекательным, но, иногда, есть нужда привязать много элементов с различными байндерами за один присест. С таким синтаксисом вы можете присвоить определенные байндеры какой-нибудь переменной, затем легко удалить все и сразу, используя {@link Matreshka#unbindNode}.

@param {array} setOfArguments - Массив массивов аргументов (см. пример)
@param {eventOptions} [eventOptions] - (см. выше)

@example
this.bindNode([
	[{
		myKey1: '.my-element1',
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3',
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5',
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
]);
*/

/**
@method Matreshka#bindOptionalNode
@importance 2
@since 0.3
@summary Работает в точности так же, как и {@link Matreshka#bindNode} но не бросает исключение, если аргумент ``node`` - пустой массив, ``undefined`` или не существует
@see {@link Matreshka#bindNode}
@example
this.bindOptionalNode('myKey', '.my-element');
*/

/**
@method Matreshka#bindSandbox
@fires bind
@fires bind:sandbox
@importance 3
@since 1.5
@summary Привязывает песочницу
@desc Оптимизированный метод для быстрого связывания свойства ``"sandbox"`` и элемента на странице.
@param {string|node|$node} node - Элемент, который должен стать песочницей
@param {eventOptions} [eventOptions] -  Объект события, в который можно передать какие-нибудь данные для обработчика или ключ ``"silent"``, который отключает генерацию событий ``"bind"`` и ``"bind:sandbox"``
@see {@link Matreshka#bindNode}
@example
this.bindSandbox('.my-element');
*/

/**
@method Matreshka#unbindNode
@importance 2
@fires unbind
@fires unbind:KEY
@summary Разрывает связь между свойством и HTML элементом
@desc Используя этот метод, можно удалить недавно добавленную, но уже не нужную связь между свойством и элементом.
@param {string|null} key - Ключ или список ключей, разделенных пробелами. Если вместо ключа передать null, удалятся все привязки для данного экземпляра
@param {string|node|$nodes} [node] - HTML элемент, с которым свойство больше не хочет иметь дела
@param {eventOptions} [eventOptions] -  Объект события, в который можно передать какие-нибудь данные для обработчика или ключ ``"silent"``, который отключает генерацию событий ``"unbind"`` и ``"unbind:KEY"``
@returns {matreshka} self
@example
this.bindNode('myKey', '.my-element');

// меняет значение свойства и состояние HTML элемента
this.myKey = true;

this.unbindNode('myKey', '.my-element');

// теперь меняется только значение свойства
this.myKey = false;
*/


/**
@method Matreshka#unbindNode
@importance 2
@variation 2
@summary Альтернативный синтаксис {@link Matreshka#unbindNode} "ключ-элемент" для {@link Matreshka#unbindNode}
@see {@link Matreshka#bindNode(2)}
@param {object} keyElementPairs (см. пример)
@param {eventOptions} [eventOptions] (см. выше)
@returns {matreshka} self
@example
this.unbindNode({
	myKey1: '.my-element1'
	myKey1: '.my-element2'
});
*/


/**
@method Matreshka#unbindNode
@importance 2
@variation 3
@summary Альтернативный синтаксис {@link Matreshka#unbindNode} "большая куча аргументов"
@see {@link Matreshka#bindNode(3)}
@param {array} setOfArguments - Массив массивов аргументов (см. пример)
@param {eventOptions} [eventOptions] (см. выше)
@returns {matreshka} self
@example
var temporaryBindings = [
	[{
		myKey1: '.my-element1'
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3'
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5'
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
];

this.bindNode(temporaryBindings);

// больше не нужны эти привязки
this.unbindNode(temporaryBindings);
*/


/**
@method Matreshka#selectAll
@importance 2
@summary Возвращает элементы из песочницы, соответствующие селектору
@desc После создания песочницы методом {@link Matreshka#bindNode}, можно получать и использовать элементы, находящиеся в ней. Кроме этого, метод поддерживает  селектор ``:bound(KEY)``
@param {string} selector - Cелектор
@returns {$nodes}
@example
this.bindNode('sandbox', '.app');
this.selectAll('.my-element');
// то же самое, что и
this.$nodes.sandbox.find('.my-element');
// и то же самое, что и
$('.app').find('.my-element');

@example <caption>Селектор ``:bound(KEY)``</caption>
this.bindNode('myKey', '.my-element');
this.selectAll(':bound(myKey) .my-another-element');
// то же самое, что и
this.$nodes.myKey.find('.my-another-element');
// и то же самое, что и
$('.my-element').find('.my-another-element');
*/


/**
@method Matreshka#$
@importance 2
@variation instance
@summary Делает то же самое, что и {@link Matreshka#selectAll}
@example
this.$('.my-element');
*/


/**
@method Matreshka#select
@importance 2
@summary Возвращает элемент из песочницы, соответствующий селектору
@desc Метод очень похож на {@link Matreshka#selectAll}, но возвращает лишь один элемент или ``null``
@param {string} selector - Селектор
@returns {node|null}
@example
this.bindNode('sandbox', '.app');
this.select('.my-element');
// то же самое, что и
this.nodes.sandbox.querySelector('.my-element');
// и то же самое, что и
$('.app').find('.my-element')[0];
*/


/**
@method Matreshka#mediate
@importance 2
@since 0.1
@summary Трансформирует значение свойства при его изменении
@desc Этот метод используется для преобразования значения свойства при его изменении. Например, вам нужно, чтоб значение свойства всегда было либо определенного типа, либо целым числом, либо быть не менее нуля и не более ста и т. д.
@param {string|array} key - Ключ или массив ключей или список ключей, разделенных пробелами
@param {function} mediator - Функция-посредник (медиатор, mediator), возвращающая новое значение
@example
this.mediate('x', function(value) {
	return String(value);
});
this.x = 1;
alert(typeof this.x); // "string"
@example <caption>Список ключей, разделенных пробелами</caption>
this.mediate('x y', function(value) {
	return String(value);
});
@example <caption>Массив ключей</caption>
this.mediate(['x', 'y'], function(value) {
	return String(value);
});
*/


/**
@method Matreshka#mediate
@importance 2
@variation 2
@since 0.1
@summary Альтернативный синтаксис метода {@link Matreshka#mediate}, принимающий в качестве аргумента объект "ключ-медиатор"
@param {object} keyMediatorPairs - Объект со свойствами ключ-медиатор
@example
this.mediate({
	x: String,
	y: Number,
	z: Boolean
});
this.x = 1;
this.y = 2;
this.z = 3;
alert(typeof this.x); // "string"
alert(typeof this.y); // "number"
alert(typeof this.z); // "boolean"
@example <caption>Список ключей, разделенных пробелами</caption>
this.mediate({
	'u v': String,
	'w x': Number,
	'y z': Boolean
});
*/


/**
@method Matreshka#setClassFor
@importance 2
@since 1.1
@summary Устанавливает класс для свойства
@desc Метод позволяет строго указать на то, экземпляром какого класса будет заданное свойство. Разработчику не нужно беспокоиться о том, что значение свойства случайно перезапишется "голыми" данными.

> Метод является надстройкой над {@link Matreshka#mediate} и переопределяет медиатор, исключая конфликт двух медиаторов.

Экземпляр класса создается во время запуска метода {@link Matreshka#setClassFor}. Первым аргументом конструктора класса становится текущее значение свойства. В конструкторе класса необходимо предусмотреть то, что в него попадет либо ``undefined`` (если свойство не содержало до этого никаких данных), либо объект, с которым нужно что-то сделать (например, расширить экземпляр класса свойствами объекта).

> На деле это выглядит просто: вы создаете обычный класс, который почти всегда принимает какие-нибудь данные, которые нужно обработать (например, использовать их в методе {@link Matreshka.Object#jset}).

При попытке присвоить свойству другое значение (объект или массив), внутренний механизм метода ``setClassFor``, вместо присваивания, делает следующее:
+ Если указана функция ``updateCallback``, метод запускает его с двумя аргументами: текущим значением свойства и данными, которые код пытается присвоить.
+ Если заданный класс унаследован от {@link Matreshka.Object}, экземпляр обновляется новыми данными, используя метод {@link Matreshka.Object#jset}.
+ Если заданный класс унаследован от {@link Matreshka.Array}, экземпляр обновляется новыми данными, используя метод {@link Matreshka.Object#recreate}.
+ Если не указана функция ``updateCallback`` и если класс не унаследован от {@link Matreshka.Object} или {@link Matreshka.Array}, экземпляр расширяется свойствами объекта, который код пытается присвоить.

> Крутой особенностью функции является отсутствие ограничений на источник класса. В качестве класса может выступать любая функция-конструктор. которая инициализируется с помощью оператора ``new``, а не только наследники {@link Matreshka}.


@param {string|array} key - Ключ или массив ключей, или список ключей, разделенных пробелами
@param {function} class - Класс, который вы хотите установить свойству
@param {function} [updateCallback] - Функция, вызывающаяся при каждой попытке присвоить новые данные свойству, позволяющая кастомизировать логику обновления экземпляра класса новыми данными. Функция принимает два аргумента: текущее значение свойства (экземпляр класса) и данные, которые пытаются присвоить.
@example
var SubClass = MK.Class({
	// ...
});

// ...

this.setClassFor('x', SubClass);

// пытаемся присвоить свойству другое значение
this.x = {a: 42};

// this.x по-прежнему экземпляр класса SubClass
alert(this.x instanceof SubClass); // true
alert(this.x.a); // 42
@example <caption>Использование ``updateCallback``.</caption>
this.setClassFor('x', SubClass, function(instance, data) {
	updateSomeHow(instance, data);
});
@example <caption>Получение родителя и ключа. Кроме данных (первый аргумент), в конструктор создаваемого класса, передается ссылка на объект, вызвавший ``setClassFor`` и ключ свойства</caption>
var MySubClass = MK.Class({
	'extends': Matreshka,
	constructor: function(data, parent, key) {
		// parent - это экземпляр MyClass
		// key - ключ ("х")
	}
});

var MyClass = MK.Class({
	'extends': Matreshka,
	constructor: function() {
		this.setClassFor('x', MySubClass);
	}
});

@example <caption>Нестандартный способ использования ``updateCallback`` для игнорирования любых изменений свойства.</caption>
// MK.noop - пустая функция
this.setClassFor('x', SubClass, MK.noop);
@example <caption>В случае, если ваш класс не подерживает использование оператора ``new``, вместо ``setClassFor`` воспользуйтесь методом {@link Matreshka#mediate}.</caption>
this.mediate('x', function(data, currentValue) {
	return currentValue instanceof SomeClass
		? Object.assign(currentValue, data)
		: SomeLib.initInstance(SomeClass, data);
});
@example <caption>Абстрактный пример с данными большой вложенности (для краткости используется синтаксис ECMAScript 7)</caption>
// app.js
class App extends MK {
	constructor(appData) {
		this.appData = appData;
		this.setClassFor('appData', AppData);
	}
}

// app-data.js
class AppData extends MK.Object {
	constructor(data) {
		super(data)
			.setClassFor({
				friends: Friends,
				settins: Settings
			});
	}
}

// friend.js
class Friend extends MK.Object {
	constructor(data) {
		super(data);
	}
}

// friends.js
class Friends extends MK.Array {
	Model = Friend;
	trackBy = 'id';
	constructor(data) {
		super(...data);
	}
}

// settings.js
class Settings extends MK.Object {
	constructor(data) {
		super(data)
			.setClassFor('credentials', Credentials);
	}
}

// credentials.js
class Credentials extends MK.Object {
	constructor(data) {
		super(data);
	}
}

// app-init.js
var app = new App({
	settings: {
		name: 'Vasiliy Vasiliev',
		credentials: {
			email: 'vasia.vasia@gmail.com'
		}
	},
	friends: [{
		name: 'Yulia Zuyeva',
		id: 1
	}, {
		name: 'Konstantin Konstantinopolsky',
		id: 2
	}, {
		name: 'nagibator3000',
		id: 3
	}]
});

// данные можно сериализировать и передать на сервер
JSON.stringify(app.appData);


// потом просто присвоить новые данные свойству appData
// при этом, структура классов не изменится
app.appData = {
	settings: {
		name: 'Petr Petrov',
		credentials: {
			email: 'petr.petrov@gmail.com'
		}
	},
	friends: [{
		name: 'Yulechka Zuyeva',
		id: 1
	}, {
		name: 'Konstantin Konstantinopolsky',
		id: 2
	}]
};
*/


/**
@method Matreshka#setClassFor
@importance 2
@variation 2
@since 1.1
@summary Альтернативный синтаксис метода {@link Matreshka#setClassFor}, принимающий в качестве аргумента объект "ключ-класс"
@param {object} keyClassPairs - Объект со свойствами ключ-класс
@param {function} [updateCallback] - Функция, вызывающаяся при каждой попытке присвоить новые данные свойству.
@example
this.setClassFor({
	x: Class1,
	y: Class2,
	z: Class3
}, function(data) {
	instance.jset(data);
});
*/


/**
@method Matreshka#linkProps
@importance 1
@since 0.1
@summary Создает зависимость значения одного свойства от значений других
@desc Метод ``linkProps`` создает зависимость значения свойства (первый аргумент) от значений других свойств (второй аргумент). Метод защищен от цикличных ссылок (например a зависит от b, b зависит от c, а c зависит от a) и при ошибке вычислений не блокирует страницу и не бросает исключение о переполнении стека.

В версии 1.5 аргумент ``setOnInit`` заменен на объект ``eventOptions`` (четвертый аргумент), включающий несколько дополнительных возможностей метода.

### Передача данных в обработчик изменения свойства и передача специальных флагов
Вы можете передать какие-нибудь данные в обработчик события изменения искомого свойства, используя аргумент ``eventOptions``.
```js
this.on('change:a', function(evt) {
	alert(evt.foo); // 'bar'
});

this.linkProps('a', 'b c', function(b, c) {
	return b + c;
}, {
	foo: 'bar'
});
```

Кроме этого в ``eventOptions``, можно передать и специальные флаги, например ``silent: true``.
```js
this.on('change:a', function(evt) {
	alert('foo');
});

this.linkProps('a', 'b c', function(b, c) {
	return b + c;
}, {
	silent: true
});

this.b = 1;
```
В примере выше, при изменении свойства механизмом ``linkProps``, обработчик изменения искомого свойства будет молчать.

> Если изменить искомое свойство другим способом, например, присваиванием (``this.a = 42``), то, очевидно, обработчик будет вызван.

Полный список поддерживаемых флагов можно найти в документации к методу {@link Matreshka#set}.



### Вычисление свойства при вызове ``linkProps``

По умолчанию, свойство будет вычислено сразу, при вызове ``linkProps``.
```js
var handler = function(b, c) {
	return b + c;
};

this.b = 1;
this.c = 2;
this.linkProps('a', 'b c', handler);
alert(this.a); // 3
```

Для отмены этого поведения передайте в объект ``eventOptions`` свойство ``setOnInit: false``. Оно необходимо в тех случаях, когда свойства, от которых зависит искомое свойство еще не заданы, и вы не хотите, чтоб значением свойства стала какая-нибудь ерунда. В примере ниже ``linkProps`` вычислит сумму ``b`` и ``c`` как ``undefined + undefined`` и значением свойства ``a`` станет ``NaN``.
```js
var handler = function(b, c) {
	return b + c;
};

this.linkProps('a', 'b c', handler);
alert(this.a); // NaN
```

```js
this.linkProps('a', 'b c', handler, {
	setOnInit: false // теперь всё хорошо
});
```

### Мгновенное вычисление свойства

Реакция на изменения свойств мгновенна и синхронна. Это значит, что при изменении свойста от которого зависит искомое свойство, вычисление второго произойдет моментально. Взгляните на пример:
```js
var handler = function(b, c) {return b + c;};

this.linkProps('a', 'b c', handler);
this.b = 1;
this.c = 2;
```
Функция ``handler`` будет вызвана трижды. Первый раз - при вызове ``linkProps`` (если ``setOnInit`` не задан), второй раз - при изменении свойства ``b``, третий - при изменении свойства ``c``. Такое поведение обусловлено идеей о том, что все реакции на изменения должны происходить последовательно и предсказуемо. Для оптимизации этого поведения, передайте в объект ``eventOptions`` свойство ``debounce: true``. См. {@link Matreshka.debounce}.

```js
var handler = function(b, c) {
	return b + c;
};

this.linkProps('a', 'b c', handler, {
	debounce: true
});
this.b = 1;
this.c = 2;
```
В примере выше функция ``handler`` будет вызвана только один раз после небольшой задержки.

@param {string|array} targetKeys - Свойство (свойства) которое зависит от других свойств
@param {string|array} sourceKeys - От каких свойств зависит искомое свойство (свойства)
@param {function} [handler=function(v){return v}] - Функция, возвращающая новое значение
@param {object} [eventOptions] - Объект, в который можно передать какие-нибудь данные для обработчика события, слушающего изменения ``targetKeys`` или специальные флаги (см. описание метода); кроме этого, к ``linkProps`` можно применить паттерн {@link Matreshka.debounce} для того, чтоб многократные изменения ``sourceKeys`` меняли ``targetKeys`` однократно.
@example
this.linkProps('greeting', 'name', function() {
	return 'Hello, ' + this.name + '!';
});

this.name = 'Joe';

alert(this.greeting); // 'Hello, Joe!'

@example <caption>Сложный пример: вычисление периметра прямоугольника по двум сторонам (и сторон по периметру). Как видите, ``linkProps`` можно использовать и для решения математических задач, где каждый член уравнения можно использовать, как неизвестное</caption>
this.a = 3;

this.b = 4;

this.linkProps('p', 'a b', function(a, b) {
	return (a + b) * 2;
});

this.linkProps('a', 'p b', function(p, b) {
	return p/2 - b;
});

this.linkProps('b', 'p a', function(p, a) {
	return p/2 - a;
});

alert(this.p); // 14

this.on('change:p', function() {
	alert('периметр изменен и равен ' + this.p);
});

this.a = 5; // alerts "периметр изменен и равен 18"

@example <caption>Начиная с версии 1.1, можно использовать путь к ключу во втором аргументе, вместо ключа</caption>
this.a = {b: {c: 21}};

this.linkProps('x', 'a.b.c', function(c) {
	return c * 2;
});

alert(this.x); //42
*/


/**
@method Matreshka#linkProps
@importance 1
@variation 2
@since 0.2
@summary Дополнительная возможность метода {@link Matreshka#linkProps}: зависимость от значений свойств других объектов
@param {string|array} targetKeys - Свойство (свойства) которое зависит от других свойств
@param {array} instancesAndKeys - Массив, который содержит объекты (четные элементы) их ключи (нечетные элементы), от которых зависит искомое свойство (свойства). Такой, возможно, странный синтаксис является следствием ограничений синтаксиса JavaScript.
@param {function} [handler=function(v){return v}] - Функция, возвращающая новое значение
@param {object} [eventOptions] - См. {@link Matreshka#linkProps выше}
@example <caption>Свойство ``sum`` является суммой свойств ``a`` и ``b`` других объектов и вычисляется каждый раз при их изменении</caption>
anotherInstance1.a = 2;

anotherInstance2.b = 3;

this.linkProps('sum', [
	anotherInstance1, 'a',
	anotherInstance2, 'b'
], function(a, b) {
	return a + b;
});

alert(this.sum); // 5

this.on('change:sum', function() {
	alert('this.sum равен ' + this.sum);
});

anotherInstance1.a = 5; // "this.sum равен 8"
*/


/**
@method Matreshka#set
@importance 1
@fires change
@fires change:KEY
@fires beforechange
@fires beforechange:KEY
@summary Устанавливает значение свойства, позволяя передать объект события в качестве третьего аргумента
@desc Список поддерживаемых флагов:
+ ``silent`` - не вызывать события ``change`` и ``change:KEY``
+ ``silentHTML`` - не менять состояние привязанных элементов
+ ``force`` - вызвать события ``change`` и ``change:KEY`` даже если значение свойства не изменилось
+ ``forceHTML`` - изменить состояние привязанного элемента, даже если значение свойства не изменилось. Эта опция нужна, если привязанный элемент был отрисован после привязки (например, в ``select`` были добавлены теги ``option``)
+ ``skipMediator`` - предотвращает трансформацию свойства медиатором (см. {@link Matreshka#mediate})
+ ``skipLinks`` - предотвращает работу зависимостей, созданных с помощью {@link Matreshka#linkProps}
@param {string} key - Ключ
@param {*} value - Значение
@param {eventOptions} [eventOptions] - Объект события
@example
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// то же самое, что и this['myKey'] = 3
// или this.myKey = 3
// выводит на экран 3
this.set('myKey', 3);
@example <caption>Используя ``eventOptions``</caption>
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// alert не срабатывает
this.set('myKey', 4, {
	silent: true
});

@example <caption>Передача произвольных данных в обработчик</caption>
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.myCustomFlag);
});

// выводит на экран 42
this.set('myKey', 4, {
	myCustomFlag: 42
});
*/


/**
@method Matreshka#set
@importance 1
@variation 2
@summary Альтернативный синтаксис метода {@link Matreshka#set} "ключ-значение"
@param {object} keyValuePairs - Объект, содержащий пары ключ-значение
@param {eventOptions} [eventOptions] - Объект события
@example
this.set({
	myKey1: 1,
	myKey2: 2
});
@example <caption>Передача ``eventOptions`` в качестве второго аргумента</caption>
this.set({
	myKey: 3
}, {
	myFlag: 'Jigurda'
});
*/


/**
@method Matreshka#remove
@importance 3
@fires delete
@fires delete:KEY
@summary Удаляет свойство
@param {string} key - Ключ или ключи, разделенные пробелом
@param {eventOptions} [eventOptions] - Объект события
@returns {matreshka} self
@example
this.remove('myKey');
this.remove('myKey1 myKey2');
@example <caption>Использование ``eventOptions``</caption>
this.remove('myKey', {
	silent: true
});
*/


/**
@method Matreshka#parseBindings
@importance 2
@since 1.1
@summary Парсит DOM дерево, объявляя привязки свойств, заключенных в двойные фигурные скобки.
@desc Начиная с версии 1.1, Матрешка включает в себя простой DOM парсер, обрабатывающий синтаксические конструкции, заключенные в двойные фигурные скобки. Метод ``parseBindings`` принимает один опциональный аргумент: HTML строку, DOM узел или селектор, соответствующий DOM узлу. Если аргумент не задан, парсер обрабатывает песочницу (см. {@link Matreshka#bindNode}).

Так как метод является DOM шаблонизатором (а не строковым HTML шаблонизатором), все дочерние DOM узлы переданного элемента остаются в своём прежнем состоянии (например, DOM события не затираются).

#### Поддерживаемый синтаксис.
1. HTML привязка
```html
<!--
Создаст DOM узел на месте {{user.name}}
и свяжет свойство name из объекта user с этим узлом
JS: this.user = {name: 'Joe'}
-->
<span>Hello, &#123;{user.name}}</span>
```

2. Привязка элементов форм.
```html
<!--
Свяжет свойство "x" экземпляра с текстовым
полем (двусторонняя привязка)
JS: this.x = 'some value';
-->
<input type="text" value="&#123;{x}}">
```

```html
<!--
Для привязки textarea и select нужно использовать атрибут value
-->
<textarea value="&#123;{x}}"></textarea>
<select value="&#123;{x}}">...</select>
```

```html
<!--
Свяжет свойство "x" экземпляра с чекбоксом
(двусторонняя привязка)
JS: this.x = true;
-->
<input type="checkbox" checked="&#123;{x}}">
```


3. Привязка атрибутов.
```html
<!--
Значение атрибута href будет зависеть
от значений свойств "category" и "someObject.page"
(односторонняя привязка)
JS:
	this.category = 'matreshka';
	this.someObject = {page: 42}
-->
<a href="http://example.com/&#123;{category}}/&#123;{someObject.page}}">A link</a>
<!--
Результат:
<a href="http://example.com/matreshka/42">A link</a>
-->
```

#### Зачем нужен такой метод?
В случае, если вы разрабатываете большую форму со стандартными HTML5 полями, метод поможет сохранить время на объявление многочисленных привязок. Кроме этого, ``parseBindings`` полезен в случае создания очень простой коллекции, не требующей реализации сложной {@link Matreshka.Array#Model модели}.

#### Не противоречит ли это идеологии Матрешки ("вся логика должна быть заключена в JavaScript файле")?
Нет, в парсере не предусмотрено циклов, условных операторов и любой другой логики. Объявление простых привязок это всё, что доступно разработчику, использующему ``parseBindings``.

#### Производительность
Метод работает несколько медленнее, чем объявление привязок вручную методом {@link Matreshka#bindNode}. Это нужно иметь в виду при создании приложения с очень серьезными требованиями к производительности. Скорость немного падает только во время процесса связывания. В остальном, привязки работают так же быстро, как и с {@link Matreshka#bindNode}.

@param {string|node|$nodes} [node] - HTML строка, селектор, DOM узел или коллекция DOM узлов
@returns {$nodes} Коллекция DOM узлов (как правило, состоящая из одного элемента), переданная в функцию в качестве аргумента или, если аргументов нет, песочница
@example <caption>Парсинг заданного узла</caption>
this.parseBindings(node);

> Если фигурные скобки не устраивают, поменяйте их на что-то другое, используя {@link Matreshka.parserBrackets}


@example <caption>Парсинг узла по селектору</caption>
this.parseBindings('.my-node');

@example <caption>Парсинг HTML строки</caption>
var $node = this.parseBindings('<h3>Hello, &#123;{name}}</h3>');
this.name = 'Arthur Philip Dent';

@example <caption>Парсинг песочницы</caption>
this.bindNode('sandbox', '.my-node');
this.parseBindings();
*/
