/**
@class Matreshka
@importance 1
@lang ru
@author Андрей Губанов <a@odessite.com.ua>
@license {@link https://raw.github.com/finom/matreshka/master/LICENSE MIT}
Version 2.0, January 2004
@alias MK
@see {@link Class}
@classdesc Класс Matreshka - ядро фреймворка Matreshka.js, от которого наследуются {@link Matreshka.Array}, {@link Matreshka.Object} и каждый класс создаваемого приложения. Он содержит основной функционал фреймворка, среди которого есть несколько полезнейших функций: {@link Matreshka#mediate медиаторы}, {@link Matreshka#linkProps зависимости}, {@link Matreshka#bindNode привязки к DOM}, {@link Matreshka#on движок событий} и пр. Наследование этого класса, как и наследование любого другого класса, осуществляется при помощи функции {@link Class}.

Как правило, этот класс, (как и {@link Matreshka.Array} и {@link Matreshka.Object}), не используются напрямую. Вместо этого, от него наследуются классы, создаваемые вами. Поэтому, примеры к свойствам и методам в этой документации, как правило, будут приведены с использованием ключевого слова ``this``.
@example <caption>Создание экземпляра</caption>
var mk = new Matreshka;
@example <caption>Краткая запись: MK вместо Matreshka</caption>
var mk = new MK;
@example <caption>Наследование</caption>
var MyClass = MK.Class({
	'extends': Matreshka,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});
@example <caption>Матрешка использует прототипы для реализации наследования. Функция {@link Class} лишь вносит синтаксический сахар. Поэтому вы можете воспользоваться любым другим полюбившимся способом наследования, например, используя классы из ECMAScript 2015</caption>
class MyClass extends Matreshka {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}
*/


/**
@member {boolean} Matreshka#isMK
@importance 3
@summary ``isMK`` всегда равен ``true``. Это свойство используется для того, чтоб определить, является ли объект экземпляром класса {@link Matreshka}
@example
alert(object.isMK);
*/


/**
@member {$nodes} Matreshka#$nodes
@importance 2
@since 1.1
@summary Объект содержит коллекции (jQuery, Zepto, инстанс встроенной микро-библиотеки, унаследованной от ``Array.prototype``) привязанных элементов для быстрого доступа.
@see {@link Matreshka#bindNode}
@example
this.bindNode('myKey', '.my-node');
this.$nodes.myKey; // то же самое, что и $('.my-node')
*/

/**
@member {node} Matreshka#nodes
@importance 2
@since 1.1
@summary Объект содержит привязанные элементы для быстрого доступа, в виде отдельных DOM узлов.
@desc Обратите внимание, каждое свойство объекта содержит первый узел из связанных с соотвутствующим свойством.  Для получения всех узлов, связанных с определенным свойством, используйте {@link Matreshka#$nodes}.
@see {@link Matreshka#bindNode}
@example
this.bindNode('myKey', '.my-node');
this.nodes.myKey; // то же самое, что и $('.my-node')[0]
*/


/**
@method Matreshka#on
@importance 1
@fires addevent
@fires addevent:NAME
@summary Добавляет обработчик события
@desc Метод {@link Matreshka#on} добавляет обработчик события для экземпляра класса ``Matreshka``. Полный список возможных событий с описанием см. здесь: {@link #typedef-eventNames}.
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@param {eventNames} names - Имя события или несколько имен, разделенных пробелом  (например, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} callback - Функция, которая вызывается по событию
@param {boolean} [triggerOnInit=false] - Если аргумент ``triggerOnInit`` равен ``true``, то обработчик будет вызван немедленно после инициализации.
@param {object} [context] - Контекст обработчика. Другими словами, ``this`` при вызове ``callback``
@returns {matreshka} self
@example
this.on('foo', function() {
	alert('Custom Event is fired');
});

this.trigger('foo');
@example <caption>Передача контекста</caption>
this.on('foo', function() {
	alert(this.a); // 5
}, {a: 5});

this.trigger('foo', 'Hello world');
@example <caption>Вызов обработчика сразу после инициализации</caption>
//Выводит на экран "bar" сиюсекундно и ждет генерации события "foo"
this.on('foo', function() {
	alert('bar');
}, true);
*/


/**
@method Matreshka#on
@importance 2
@variation 2
@since 1.1
@summary Альтернативный синтаксис: пары "событие-обработчик"
@desc В метод {@link Matreshka#on} можно передать объект с парами событие-обработчик, чтобы избежать многократного вызова метода и сократить код.

@param {object} evtnameHandlerObject - Объект с событиями
@param {boolean} [triggerOnInit=false] - Если аргумент ``triggerOnInit`` равен ``true``, то обработчики будут вызван немедленно после инициализации
@param {object} [context] - Контекст обработчика
@returns {matreshka} self
@example
this.on({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});

@example <caption>Особенно круто этот способ вызова метода ``on`` выглядит с использованием синтаксиса ECMAScript 2015</caption>
this.on({
	'custom': evt => ...,
	'click::x': evt => ...,
	'change:y': evt => ...,
});
*/


/**
@method Matreshka#onDebounce
@importance 2
@fires addevent
@fires addevent:NAME
@summary Добавляет обработчик события, вызываемый лишь однажды за определенный промежуток времени
@desc Метод позволяет добавить обработчик события на экземпляр класса {@link Matreshka}, устраняя "дребезжание" обработчика. Функция может быть вызвана лишь один раз за определенный промежуток времени. В остальном, метод работает так же, как и {@link Matreshka#on}.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@see {@link Matreshka.debounce}
@see {@link http://habrahabr.ru/post/60957/ Статья на Хабре о микропаттерне debounce}
@param {eventNames} names - Имя события или несколько имен, разделенных пробелом  (например, ``"change:x ajaxcomplete change:y"``).
@param {eventHandler} callback - Функция, которая вызывается по событию
@param {number} [debounceDelay=0] - Задержка
@param {boolean} [triggerOnInit=false] - Если аргумент ``triggerOnInit`` равен ``true``, то обработчик будет вызван немедленно после инициализации
@param {object} [context] - Контекст обработчика. Другими словами, ``this`` при вызове ``callback``
@returns {matreshka} self
@example
this.onDebounce('change:x', function() {
	alert('x = ' + this.x); // x = 100
}, 300);

this.x = 1;

for(var i = 0; i < 100; i++) {
	this.x++;
}
*/


/**
@method Matreshka#onDebounce
@importance 2
@variation 2
@since 1.1
@summary Альтернативный синтаксис: пары "событие-обработчик"
@desc В метод {@link Matreshka#onDebounce} можно передать объект с парами событие-обработчик, чтобы избежать многократного вызова метода и сократить код.
@see {@link Matreshka#on(2)}
@param {object} evtnameHandlerObject - Объект с событиями
@param {number} [debounceDelay=0] - Задержка
@param {boolean} [triggerOnInit=false] - Если аргумент ``triggerOnInit`` равен ``true``, то обработчики будут вызван немедленно после инициализации
@param {object} [context] - Контекст обработчиков
@returns {matreshka} self
@example
this.onDebounce({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});
*/


/**
@method Matreshka#once
@importance 2
@fires addevent
@fires addevent:NAME
@summary Добавляет обработчик событий, который может быть вызван однажды
@desc Метод работает так же, как и {@link Matreshka#on} но передаваемый обработчик может быть вызван только один раз.
Обратите внимание, что у метода отсутствует аргумент <code>triggerOnInit</code>.
@see {@link Matreshka#on}
@see {@link Matreshka#off}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} names - Имя события или несколько имен, разделенных пробелом (например, <code>"change:x ajaxcomplete change:y"</code>)
@param {eventHandler} callback - Функция, которая вызывается по событию
@param {object} [context] - Контекст обработчика
@returns {matreshka} self
@example
this.x = 1;

this.once('change:x', function() {
	alert('x is changed');
});

this.x = 2; // выводит 'x is changed'

this.x = 3; // ничего не делает
*/


/**
@method Matreshka#once
@importance 2
@variation 2
@since 1.1
@summary Альтернативный синтаксис: пары "событие-обработчик"
@desc В метод {@link Matreshka#once} можно передать объект с парами событие-обработчик, чтобы избежать многократного вызова метода и сократить код.
@see {@link Matreshka#on(2)}
@param {object} evtnameHandlerObject - Объект с событиями
@param {object} [context] - Контекст обработчиков
@returns {matreshka} self
@example
this.once({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});
*/


/**
@method Matreshka#off
@importance 1
@fires removeevent
@fires removeevent:NAME
@summary Удаляет обработчик события
@desc Удаляет созданный ранее обработчик. Все три аргумента опциональны. Вы можете удалить как все события (не передавая ни одного аргумента), так и отдельные (передав только имя события, передав имя события и обработчик, передав и имя события, и обработчик, и контекст)
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} [names] - Разделенный пробелами список имен событий (например, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} [callback] - Функция-обработчик
@param {object} [context] - Контекст
@returns {matreshka} self
@example
this.off('change:x bind');
@example <caption>Удаление всех событий</caption>
this.off();
@example <caption>Удаление события с определенным обработчиком</caption>
var handler = function() {
	//...
}
this.on('change:x', handler);
this.off('change:x', handler);
@example <caption>Удаление события с определенным контекстом</caption>
var object = {};
this.on('change:x', handler, object);
this.off('change:x', handler, object);
*/


/**
@method Matreshka#trigger
@importance 1
@summary Генерирует событие
@desc После добавление обработчиков событий с помощью метода {@link Matreshka#on}, {@link Matreshka#onDebounce} или {@link Matreshka#once}, событие можно генерировать вручную с помощью этого метода.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#off}
@param {eventNames} [names] - Имя события или несколько имен, разделенных пробелом
@param {...*} [arg] - Аргументы, которые будут переданы обработчикам
@returns {matreshka} self
@example
this.on('foo bar', function(a, b, c) {
	alert(a + b + c);
});
this.trigger('bar', 1, 2, 3); // alerts 6
*/


/**
@method Matreshka#bindOptionalNode
@importance 2
@since 0.3
@summary Работает в точности так же, как и {@link Matreshka#bindNode} но не бросает исключение, если аргумент ``node`` - пустой массив, ``undefined`` или не существует
@see {@link Matreshka#bindNode}
@example
this.bindOptionalNode('myKey', '.my-element');
*/


/**
@method Matreshka#selectAll
@importance 2
@summary Возвращает элементы из песочницы, соответствующие селектору
@desc После создания песочницы методом {@link Matreshka#bindNode}, можно получать и использовать элементы, находящиеся в ней. Кроме этого, метод поддерживает  селектор ``:bound(KEY)``
@param {string} selector - Cелектор
@returns {$nodes}
@example
this.bindNode('sandbox', '.app');
this.selectAll('.my-element');
// то же самое, что и
this.$nodes.sandbox.find('.my-element');
// и то же самое, что и
$('.app').find('.my-element');

@example <caption>Селектор ``:bound(KEY)``</caption>
this.bindNode('myKey', '.my-element');
this.selectAll(':bound(myKey) .my-another-element');
// то же самое, что и
this.$nodes.myKey.find('.my-another-element');
// и то же самое, что и
$('.my-element').find('.my-another-element');
*/


/**
@method Matreshka#$
@importance 2
@variation instance
@summary Делает то же самое, что и {@link Matreshka#selectAll}
@example
this.$('.my-element');
*/


/**
@method Matreshka#select
@importance 2
@summary Возвращает элемент из песочницы, соответствующий селектору
@desc Метод очень похож на {@link Matreshka#selectAll}, но возвращает лишь один элемент или ``null``
@param {string} selector - Селектор
@returns {node|null}
@example
this.bindNode('sandbox', '.app');
this.select('.my-element');
// то же самое, что и
this.nodes.sandbox.querySelector('.my-element');
// и то же самое, что и
$('.app').find('.my-element')[0];
*/


/**
@method Matreshka#mediate
@importance 2
@since 0.1
@summary Трансформирует значение свойства при его изменении
@desc Этот метод используется для преобразования значения свойства при его изменении. Например, вам нужно, чтоб значение свойства всегда было либо определенного типа, либо целым числом, либо быть не менее нуля и не более ста и т. д.
@param {string|array} key - Ключ или массив ключей или список ключей, разделенных пробелами
@param {function} mediator - Функция-посредник (медиатор, mediator), возвращающая новое значение
@example
this.mediate('x', function(value) {
	return String(value);
});
this.x = 1;
alert(typeof this.x); // "string"
@example <caption>Список ключей, разделенных пробелами</caption>
this.mediate('x y', function(value) {
	return String(value);
});
@example <caption>Массив ключей</caption>
this.mediate(['x', 'y'], function(value) {
	return String(value);
});
*/


/**
@method Matreshka#mediate
@importance 2
@variation 2
@since 0.1
@summary Альтернативный синтаксис метода {@link Matreshka#mediate}, принимающий в качестве аргумента объект "ключ-медиатор"
@param {object} keyMediatorPairs - Объект со свойствами ключ-медиатор
@example
this.mediate({
	x: String,
	y: Number,
	z: Boolean
});
this.x = 1;
this.y = 2;
this.z = 3;
alert(typeof this.x); // "string"
alert(typeof this.y); // "number"
alert(typeof this.z); // "boolean"
@example <caption>Список ключей, разделенных пробелами</caption>
this.mediate({
	'u v': String,
	'w x': Number,
	'y z': Boolean
});
*/



/**
@method Matreshka#set
@importance 1
@fires change
@fires change:KEY
@fires beforechange
@fires beforechange:KEY
@summary Устанавливает значение свойства, позволяя передать объект события в качестве третьего аргумента
@desc Список поддерживаемых флагов:
+ ``silent`` - не вызывать события ``change`` и ``change:KEY``
+ ``silentHTML`` - не менять состояние привязанных элементов
+ ``force`` - вызвать события ``change`` и ``change:KEY`` даже если значение свойства не изменилось
+ ``forceHTML`` - изменить состояние привязанного элемента, даже если значение свойства не изменилось. Эта опция нужна, если привязанный элемент был отрисован после привязки (например, в ``select`` были добавлены теги ``option``)
+ ``skipMediator`` - предотвращает трансформацию свойства медиатором (см. {@link Matreshka#mediate})
+ ``skipLinks`` - предотвращает работу зависимостей, созданных с помощью {@link Matreshka#linkProps}
@param {string} key - Ключ
@param {*} value - Значение
@param {eventOptions} [eventOptions] - Объект события
@example
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// то же самое, что и this['myKey'] = 3
// или this.myKey = 3
// выводит на экран 3
this.set('myKey', 3);
@example <caption>Используя ``eventOptions``</caption>
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// alert не срабатывает
this.set('myKey', 4, {
	silent: true
});

@example <caption>Передача произвольных данных в обработчик</caption>
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.myCustomFlag);
});

// выводит на экран 42
this.set('myKey', 4, {
	myCustomFlag: 42
});
*/


/**
@method Matreshka#set
@importance 1
@variation 2
@summary Альтернативный синтаксис метода {@link Matreshka#set} "ключ-значение"
@param {object} keyValuePairs - Объект, содержащий пары ключ-значение
@param {eventOptions} [eventOptions] - Объект события
@example
this.set({
	myKey1: 1,
	myKey2: 2
});
@example <caption>Передача ``eventOptions`` в качестве второго аргумента</caption>
this.set({
	myKey: 3
}, {
	myFlag: 'Jigurda'
});
*/


/**
@method Matreshka#remove
@importance 3
@fires delete
@fires delete:KEY
@summary Удаляет свойство
@param {string} key - Ключ или ключи, разделенные пробелом
@param {eventOptions} [eventOptions] - Объект события
@returns {matreshka} self
@example
this.remove('myKey');
this.remove('myKey1 myKey2');
@example <caption>Использование ``eventOptions``</caption>
this.remove('myKey', {
	silent: true
});
*/
