/**
@class Matreshka
@importance 1
@lang ru
@alias MK
@see {@link Class}
@classdesc Класс Matreshka - ядро фреймворка Matreshka.js, от которого наследуются {@link Matreshka.Array}, {@link Matreshka.Object} и каждый класс создаваемого приложения. Он содержит основной функционал фреймворка, среди которого есть несколько полезнейших функций: {@link Matreshka#mediate медиаторы}, {@link Matreshka#linkProps зависимости}, {@link Matreshka#bindNode привязки к DOM}, {@link Matreshka#on движок событий} и пр. Наследование этого класса, как и наследование любого другого класса, осуществляется при помощи функции {@link Class}.

Как правило, этот класс, (как и {@link Matreshka.Array} и {@link Matreshka.Object}), не используются напрямую. Вместо этого, от него наследуются классы, создаваемые вами. Поэтому, примеры к свойствам и методам в этой документации, как правило, будут приведены с использованием ключевого слова ``this``.
@example <caption>Создание экземпляра</caption>
var mk = new Matreshka;
@example <caption>Краткая запись: MK вместо Matreshka</caption>
var mk = new MK;
@example <caption>Наследование</caption>
var MyClass = MK.Class({
	'extends': Matreshka,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});
@example <caption>Матрешка использует прототипы для реализации наследования. Функция {@link Class} лишь вносит синтаксический сахар. Поэтому вы можете воспользоваться любым другим полюбившимся способом наследования, например, используя классы из ECMAScript 2015</caption>
class MyClass extends Matreshka {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}
*/


/**
@member {$nodes} Matreshka#$nodes
@importance 2
@since 1.1
@summary Объект содержит коллекции (jQuery, Zepto, инстанс встроенной микро-библиотеки, унаследованной от ``Array.prototype``) привязанных элементов для быстрого доступа.
@see {@link Matreshka#bindNode}
@example
this.bindNode('myKey', '.my-node');
this.$nodes.myKey; // то же самое, что и $('.my-node')
*/

/**
@member {node} Matreshka#nodes
@importance 2
@since 1.1
@summary Объект содержит привязанные элементы для быстрого доступа, в виде отдельных DOM узлов.
@desc Обратите внимание, каждое свойство объекта содержит первый узел из связанных с соотвутствующим свойством.  Для получения всех узлов, связанных с определенным свойством, используйте {@link Matreshka#$nodes}.
@see {@link Matreshka#bindNode}
@example
this.bindNode('myKey', '.my-node');
this.nodes.myKey; // то же самое, что и $('.my-node')[0]
*/








/**
@method Matreshka#bindOptionalNode
@importance 2
@since 0.3
@summary Работает в точности так же, как и {@link Matreshka#bindNode} но не бросает исключение, если аргумент ``node`` - пустой массив, ``undefined`` или не существует
@see {@link Matreshka#bindNode}
@example
this.bindOptionalNode('myKey', '.my-element');
*/


/**
@method Matreshka#selectAll
@importance 2
@summary Возвращает элементы из песочницы, соответствующие селектору
@desc После создания песочницы методом {@link Matreshka#bindNode}, можно получать и использовать элементы, находящиеся в ней. Кроме этого, метод поддерживает  селектор ``:bound(KEY)``
@param {string} selector - Cелектор
@returns {$nodes}
@example
this.bindNode('sandbox', '.app');
this.selectAll('.my-element');
// то же самое, что и
this.$nodes.sandbox.find('.my-element');
// и то же самое, что и
$('.app').find('.my-element');

@example <caption>Селектор ``:bound(KEY)``</caption>
this.bindNode('myKey', '.my-element');
this.selectAll(':bound(myKey) .my-another-element');
// то же самое, что и
this.$nodes.myKey.find('.my-another-element');
// и то же самое, что и
$('.my-element').find('.my-another-element');
*/


/**
@method Matreshka#$
@importance 2
@variation instance
@summary Делает то же самое, что и {@link Matreshka#selectAll}
@example
this.$('.my-element');
*/


/**
@method Matreshka#select
@importance 2
@summary Возвращает элемент из песочницы, соответствующий селектору
@desc Метод очень похож на {@link Matreshka#selectAll}, но возвращает лишь один элемент или ``null``
@param {string} selector - Селектор
@returns {node|null}
@example
this.bindNode('sandbox', '.app');
this.select('.my-element');
// то же самое, что и
this.nodes.sandbox.querySelector('.my-element');
// и то же самое, что и
$('.app').find('.my-element')[0];
*/


/**
@method Matreshka#mediate
@importance 2
@since 0.1
@summary Трансформирует значение свойства при его изменении
@desc Этот метод используется для преобразования значения свойства при его изменении. Например, вам нужно, чтоб значение свойства всегда было либо определенного типа, либо целым числом, либо быть не менее нуля и не более ста и т. д.
@param {string|array} key - Ключ или массив ключей или список ключей, разделенных пробелами
@param {function} mediator - Функция-посредник (медиатор, mediator), возвращающая новое значение
@example
this.mediate('x', function(value) {
	return String(value);
});
this.x = 1;
alert(typeof this.x); // "string"
@example <caption>Список ключей, разделенных пробелами</caption>
this.mediate('x y', function(value) {
	return String(value);
});
@example <caption>Массив ключей</caption>
this.mediate(['x', 'y'], function(value) {
	return String(value);
});
*/


/**
@method Matreshka#mediate
@importance 2
@variation 2
@since 0.1
@summary Альтернативный синтаксис метода {@link Matreshka#mediate}, принимающий в качестве аргумента объект "ключ-медиатор"
@param {object} keyMediatorPairs - Объект со свойствами ключ-медиатор
@example
this.mediate({
	x: String,
	y: Number,
	z: Boolean
});
this.x = 1;
this.y = 2;
this.z = 3;
alert(typeof this.x); // "string"
alert(typeof this.y); // "number"
alert(typeof this.z); // "boolean"
@example <caption>Список ключей, разделенных пробелами</caption>
this.mediate({
	'u v': String,
	'w x': Number,
	'y z': Boolean
});
*/



/**
@method Matreshka#set
@importance 1
@fires change
@fires change:KEY
@fires beforechange
@fires beforechange:KEY
@summary Устанавливает значение свойства, позволяя передать объект события в качестве третьего аргумента
@desc Список поддерживаемых флагов:
+ ``silent`` - не вызывать события ``change`` и ``change:KEY``
+ ``silentHTML`` - не менять состояние привязанных элементов
+ ``force`` - вызвать события ``change`` и ``change:KEY`` даже если значение свойства не изменилось
+ ``forceHTML`` - изменить состояние привязанного элемента, даже если значение свойства не изменилось. Эта опция нужна, если привязанный элемент был отрисован после привязки (например, в ``select`` были добавлены теги ``option``)
+ ``skipMediator`` - предотвращает трансформацию свойства медиатором (см. {@link Matreshka#mediate})
+ ``skipLinks`` - предотвращает работу зависимостей, созданных с помощью {@link Matreshka#linkProps}
@param {string} key - Ключ
@param {*} value - Значение
@param {eventOptions} [eventOptions] - Объект события
@example
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// то же самое, что и this['myKey'] = 3
// или this.myKey = 3
// выводит на экран 3
this.set('myKey', 3);
@example <caption>Используя ``eventOptions``</caption>
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// alert не срабатывает
this.set('myKey', 4, {
	silent: true
});

@example <caption>Передача произвольных данных в обработчик</caption>
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.myCustomFlag);
});

// выводит на экран 42
this.set('myKey', 4, {
	myCustomFlag: 42
});
*/


/**
@method Matreshka#set
@importance 1
@variation 2
@summary Альтернативный синтаксис метода {@link Matreshka#set} "ключ-значение"
@param {object} keyValuePairs - Объект, содержащий пары ключ-значение
@param {eventOptions} [eventOptions] - Объект события
@example
this.set({
	myKey1: 1,
	myKey2: 2
});
@example <caption>Передача ``eventOptions`` в качестве второго аргумента</caption>
this.set({
	myKey: 3
}, {
	myFlag: 'Jigurda'
});
*/


/**
@method Matreshka#remove
@importance 3
@fires delete
@fires delete:KEY
@summary Удаляет свойство
@param {string} key - Ключ или ключи, разделенные пробелом
@param {eventOptions} [eventOptions] - Объект события
@returns {matreshka} self
@example
this.remove('myKey');
this.remove('myKey1 myKey2');
@example <caption>Использование ``eventOptions``</caption>
this.remove('myKey', {
	silent: true
});
*/
