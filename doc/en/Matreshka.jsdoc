/**
@class Matreshka
@importance 1
@lang en
@author Andrey Gubanov <a@odessite.com.ua>
@license {@link https://raw.github.com/finom/matreshka/master/LICENSE MIT}
Version 2.0, January 2004
@alias MK
@see {@link Class}
@classdesc The class ``Matreshka`` is a core of the Matreshka.js framework which is inherited by {@link Matreshka.Array}, {@link Matreshka.Object} and every class of the application you create. It contains the main functionality of the framework, among which there are some very useful functions, such as {@link Matreshka#mediate mediators}, {@link Matreshka#linkProps dependencies}, {@link Matreshka#bindNode two-way data binding}, {@link Matreshka#on an event engine}, etc. The inheritance of this class, the same as the inheritance of any other class, is carried out with the help of the {@link Class} function.

This class, (like {@link Matreshka.Array} and {@link Matreshka.Object}), usually isn't used directly. Instead, it is inherited by the classes that you create. Therefore, the examples to the properties and methods in this documentation, as a rule, will be given with the use of ``this`` keyword.
@example <caption>Creating of an instance</caption>
var mk = new Matreshka();
@example <caption>You can use ``MK`` variable instead of ``Matreshka``</caption>
var mk = new MK();
@example <caption>Inheritance</caption>
var MyClass = Class({
	'extends': Matreshka,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});
@example <caption>Matreshka uses prototypes for implementing the inheritance. The {@link Class} function just brings in some syntactic sugar. That's why you can use any other way of the inheritance you like, for example, using classes from ECMAScript 2015</caption>
class MyClass extends Matreshka {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}
*/


/**
@member {boolean} Matreshka#isMK
@importance 3
@summary ``isMK`` always equals ``true``. This property is used for defining whether an object is an instance of the {@link Matreshka} class
@example
alert(object.isMK);
*/


/**
@member {$nodes} Matreshka#$sandbox
@importance 2
@since 0.4
@summary The property contains HTML sandbox as collection (jQuery, Zepto, bQuery)
@see {@link Matreshka#bindNode}
@example
this.bindNode('sandbox', '.app');
this.$sandbox; // the same as $('.app')
*/


/**
@member {node} Matreshka#sandbox
@importance 2
@since 0.4
@summary The property contains HTML sandbox as DOM node
@see {@link Matreshka#bindNode}
@example
this.bindNode('sandbox', '.app');
this.sandbox; // the same as $('.app')[0]
*/


/**
@member {$nodes} Matreshka#$nodes
@importance 2
@since 1.1
@summary An object contains collections (jQuery, Zepto, bQuery) of bound nodes for quick access.
@see {@link Matreshka#bindNode}
@example
this.bindNode('myKey', '.my-node');
this.$nodes.myKey; // the same as $('.my-node')
*/


/**
@member {node} Matreshka#nodes
@importance 2
@since 1.1
@summary The object contains bound elements in the form of separate DOM nodes for quick access.
@desc Pay attention, every object property has got the first node of the bound ones to the corresponding property. Use {@link Matreshka#$nodes} for getting all the nodes bound to a certain property.
@see {@link Matreshka#bindNode}
@example
this.bindNode('myKey', '.my-node');
this.nodes.myKey; // the same as $('.my-node')[0]
*/

/**
@method Matreshka#on
@importance 1
@fires addevent
@fires addevent:NAME
@summary Adds an event handler
@desc The {@link Matreshka#on} method adds an event handler for an instance of the ``Matreshka`` class. Refer to the complete list of possible events with the description here: {@link #typedef-eventNames}.
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@param {eventNames} names - An event name or some names which are separated by a space (for example, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} callback - A function which is caused by the event
@param {boolean} [triggerOnInit=false] - If ``triggerOnInit`` argument equals ``true``, the handler will be called immediately after event initialization.
@param {object} [context] - A context of the handler. In other words, ``this`` when called ``callback``
@returns {matreshka} self
@example
this.on('foo', function() {
	alert('Custom Event is fired');
});

this.trigger('foo');
@example <caption>Passing a context</caption>
this.on('foo', function() {
	alert(this.a); // 5
}, {a: 5});

this.trigger('foo', 'Hello world');
@example <caption>Calling a handler immediately after event initialization</caption>
// Displays "bar" at once and waits for a firing of "foo" event
this.on('foo', function() {
	alert('bar');
}, true);
*/


/**
@method Matreshka#on
@importance 2
@variation 2
@since 1.1
@summary Alternative syntax: "eventname-handler" pairs
@desc In the {@link Matreshka#on} method the object with the key-element pairs can be passed to avoid multiple invocation of the method and reduce your code.

@param {object} evtnameHandlerObject - An object where keys are event names and values are event handlers
@param {boolean} [triggerOnInit=false] - If ``triggerOnInit`` argument  equals ``true``, all handlers will be called immediately after event initialization.
@param {object} [context] - A context of the handler
@returns {matreshka} self
@example
this.on({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});

@example <caption>ECMAScript 2015</caption>
this.on({
	'custom': evt => ...,
	'click::x': evt => ...,
	'change:y': evt => ...,
});
*/


/**
@method Matreshka#onDebounce
@importance 2
@fires addevent
@fires addevent:NAME
@summary Adds an event handler which is called only once during a definite period of time
@desc The method allows to add an event handler to an instance of the {@link Matreshka} class, debouncing the handler. Callback function can be called only once during a definite period of time. As to the rest the method works the same as {@link Matreshka#on}.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@see {@link Matreshka.debounce}
@see {@link http://davidwalsh.name/javascript-debounce-function JavaScript Debounce Function}
@param {eventNames} names - An event name or some names which are separated by a space (for example, ``"change:x ajaxcomplete change:y"``).
@param {eventHandler} callback - A handler which is caused by an event
@param {number} [debounceDelay=0] - A delay
@param {boolean} [triggerOnInit=false] - If ``triggerOnInit`` argument equals ``true``, the handler will be called immediately after event initialization.
@param {object} [context] - A context of a handler. In other words, ``this`` when called ``callback``
@returns {matreshka} self
@example
this.onDebounce('change:x', function() {
	alert('x = ' + this.x); // x = 100
}, 300);

this.x = 1;

for(var i = 0; i < 100; i++) {
	this.x++;
}
*/


/**
@method Matreshka#onDebounce
@importance 2
@variation 2
@since 1.1
@summary Alternative syntax: "eventname-handler" pairs
@see {@link Matreshka#on(2)}
@param {object} evtnameHandlerObject - An object where keys are event names and values are event handlers
@param {number} [debounceDelay=0] - A delay
@param {boolean} [triggerOnInit=false] - If ``triggerOnInit`` argument equals ``true``, all handlers will be called immediately after event initialization
@param {object} [context] - A context of a handler
@returns {matreshka} self
@example
this.onDebounce({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});
*/

/**
@method Matreshka#once
@importance 2
@fires addevent
@fires addevent:NAME
@summary Adds an event handler which can be called only once
@desc The method works the same as {@link Matreshka#on} but the passing handler can be called only once. Note the method lacks the ``triggerOnInit`` argument.
@see {@link Matreshka#on}
@see {@link Matreshka#off}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} names - An event name or some names which are separated by a space (for example, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} callback - A handler which is caused by an event
@param {object} [context] - A context of a handler
@returns {matreshka} self
@example
this.x = 1;

this.once('change:x', function() {
	alert('x is changed');
});

this.x = 2; // displays 'x is changed'

this.x = 3; // does nothing
*/


/**
@method Matreshka#once
@importance 2
@variation 2
@since 1.1
@summary Alternative syntax: "eventname-handler" pairs
@see {@link Matreshka#on(2)}
@param {object} evtnameHandlerObject - An object where keys are event names and values are event handlers
@param {object} [context] - A context of a handler
@returns {matreshka} self
@example
this.once({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});
*/

/**
@method Matreshka#off
@importance 1
@fires removeevent
@fires removeevent:NAME
@summary Deletes an event handler
@desc It deletes a handler which has been created before. All the three arguments are optional. You can delete both all the events (without passing any argument) and separate ones (having passed only the event name, the event name and the handler, the event name and the handler and the context)
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} [names] - A list of event names which are separated by spaces (for example, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} [callback] - A function-handler
@param {object} [context] - A context
@returns {matreshka} self
@example
this.off('change:x bind');
@example <caption>The deletion of all events</caption>
this.off();
@example <caption>The deletion of an event with definite handler</caption>
var handler = function() {
	//...
}
this.on('change:x', handler);
this.off('change:x', handler);
@example <caption>The deletion of an event with definite context</caption>
var object = {};
this.on('change:x', handler, object);
this.off('change:x', handler, object);
*/


/**
@method Matreshka#trigger
@importance 1
@summary Fires an event
@desc After adding event handlers using {@link Matreshka#on}, {@link Matreshka#onDebounce} or {@link Matreshka#once}, any event can be fired manually using this method.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#off}
@param {eventNames} [names] - An event name or some names which are separated by a space
@param {...*} [arg] - Any arguments which will be passed to every handler
@returns {matreshka} self
@example
this.on('foo bar', function(a, b, c) {
	alert(a + b + c);
});
this.trigger('foo', 1, 2, 3); // alerts 6
*/


/**
@method Matreshka#bindNode
@importance 1
@fires bind
@fires bind:KEY
@summary Binds a property of an object to HTML node, implementing two-way data binding
@desc {@link Matreshka#bindNode} is the only method of the {@link Matreshka} class  which is responsible for changing DOM (except array renderer). It creates a bridge between value of a property and state of HTML node on the page: from a simple input to a complicated widget (the complexity of elements is unlimited). ``bindNode``can be truly regarded as the main method of the framework. After using this method, it isn't necessary to monitor the synchronizations between model and view.

The method acepts three arguments: **a property name** (key), **HTML node** (or a selector) and a **binding rule** (a binder). In its turn, a binder is an ordinary object and it can have the following properties: ``on``, ``getValue``, ``setValue``, ``initialize`` (Read more here: {@link #typedef-binder}). All the four properties are optional. It also allows to declare one-way data bindings (any direction).

> The ``bindNode`` method  supports the many-to-many bindings. Several elements can be bound to one property and several properties can be bound to one element, including ones from different instances of various classes.

```js
this.bindNode('myKey', '.my-element', {
	on: 'click',
	getValue: function() { ... },
	setValue: function() { ... }
});
```

For example, you want to bind a property of an object to a ``input[type="checkbox"]`` node:
```js
this.bindNode('myKey', '.my-checkbox', {
	// when is element state changed?
	// - after 'click' event
	on: 'click',
	// how to extract element state?
	// - return 'checked' value
	getValue: function() {
		return this.checked;
	},
	// how to set element state?
	// - set 'checked' value
	setValue: function(v) {
		this.checked = !!v;
	}
});
```

After binding is declared, you can set value of an object property in your most habitual way and HTML node (in this case, a checkbox) will change its state in no time. After clicking on the checkbox, the property value will be changed to the corresponding one as well.
```js
// sets checked = true
this.myKey = true;
```

> If a property value of class instance is not given, after a binding Matreshka will try to extract its value from the HTML node using ``getValue``. This behavior can be cancelled by passing the ``assignDefaultValue: false`` property to event object.
```js
this.bindNode('myKey', '.my-element', binder, {
	assignDefaultValue: false
});
```

More complicated example: binding object property to jQuery UI widget
```html
<div class="my-slider"></div>
```

```js
this.bindNode('myKey', '.my-slider', {
	// when is element state changed?
	// - after 'slide' event
	on: 'slide',
	// how to extract element state?
	// - return 'value' of the widget
	getValue: function() {
		return $(this).slider('option', 'value');
	},
	// how to set element state?
	// - set 'value'
	setValue: function(v) {
		$(this).slider('option', 'value', v);
	},
	// how to initialize the widget?
	// you can initialize the slider in any way,
	// but 'initialize' function provides some syntactic sugar
	initialize: function() {
		$(this).slider({min: 0, max: 100});
	}
});
```

```js
// will set the slider value 42
this.myKey = 42;
```

It looks easy but you may ask a question: "What should I do to avoid writing these rules every time?". The question is absolutely correct. Indeed, there can be a lot of elements of the same type on the page: text fields, drop down menus, new fields from the HTML5 specification as well as third party widgets (see the example above).

As observed in this documentation, the third argument is not obligatory for the ones of the {@link Matreshka#bindNode} method (see below). This problem is solved by the {@link Matreshka.defaultBinders} array which contains functions checking an HTML node against a set of rules. You get an opportunity to reduce your code a great deal, putting  binding rules into a separate part of your code and to use a syntax for binding without the third argument:
```js
this.bindNode('myKey', '.my-element');
```
How to do it? You should add the function checking  your element against a set of rules to the beginning of the {@link Matreshka.defaultBinders} array. The example below can be used as a template for creating your **default binder**.
```js
// add the binder to the collection of binders
// it is necessary to keep the possibility of overriding
Matreshka.binders.checkbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return this.checked;
		},
		setValue: function(v) {
			this.checked = !!v;
		}
	}
};

// the unshift method adds the function
// to the beginning of the Matreshka.defaultBinders array
Matreshka.defaultBinders.unshift(function(node) {
	// check if the element is a checkbox
	if(node.tagName == 'INPUT' && node.type == 'checkbox') {
		// if checking is OK, return a new binder
		return Matreshka.binders.checkbox();
	}
});
```
```js
this.bindNode('myKey', '.my-checkbox');
this.myKey = true;
```

What should you do if you need to pass arguments for initializing some plug-in or a widget? It is a piece of cake: you can do with adding the binder to the {@link Matreshka.binders} collection without creating a function for {@link Matreshka.defaultBinders}.
```js
Matreshka.binders.uiSlider = function(min, max) {
	return {
		on: 'slide',
		getValue: function() {
			return $(this).slider('option', 'value');
		},
		setValue: function(v) {
			$(this).slider('option', 'value', v);
		},
		initialize: function() {
			$(this).slider({min: min, max: max});
		}
	}
};
```
```js
this.bindNode('myKey1', '.my-slider1', Matreshka.binders.uiSlider(0, 100));
this.bindNode('myKey2', '.my-slider2', Matreshka.binders.uiSlider(1, 1000));
this.myKey1 = 42;
this.myKey2 = 999;
```

> DOM changes are happening synchronously after every change of a property. You can "debounce" all changes passing ``debounce: true`` property to ``eventOptions`` argument. Look at {@link Matreshka.debounce}

To change this

Изменения DOM происходят синхронно, сразу после изменения свойства. Для того, чтоб DOM менялся после небольшой задержки только один раз, несмотря на то, как часто меняется свойство, передайте в аргумент ``eventOptions`` свойство ``debounce: true``.

{@link Matreshka.defaultBinders} OOB, starting with the version 0.3, has a support for **all form elements** without any exception: ``select`` (including ``multiple``), ``textarea``, ``output``, ``input`` (including all types from the specification of HTML5: ``text``, ``checkbox``, ``radio``, ``range``, ``number``, ``date``, ``search``, ``time``, ``datetime``, ``datetime-local``, ``color`` and others). That means it is not necessary to designate a binder for standard elements.
```html
<input type="color" class="my-color-input">
```
```js
this.bindNode('myColor', '.my-color-input');
this.myColor = '#66bb6a';
```

Besides, after the binding, a new non-standard ``:bound(KEY)`` CSS selector is available for you.
```js
this.bindNode('myKey', '.my-element');

// will find the element '.my-inner-element' inside '.my-element'
this.bindNode('myAnotherKey', ':bound(myKey) .my-inner-element');
```

And the syntax of possible event names is extended:
```js
this.bindNode('myKey', '.my-element');

// will handle the click on the .my-element element
this.on('click::myKey', function() { ... });

// will handle the click on the .my-element .my-inner-element
this.on('click::myKey(.my-inner-element)', function() { ... });
```


#### The creation of a sandbox
{@link Matreshka#bindNode} can associate a class instance with the "main" HTML element on the page creating so-called **sandbox**. It is necessary to limit the instance influence on HTML nodes contained in another sandbox (i. e. inside another HTML node). A special property ``'sandbox'`` is used for binding a sandbox.
```html
<div class="my-sandbox">
	<!-- your HTML code -->
</div>
```

```js
this.bindNode('sandbox', '.my-sandbox');
```

The definition of the sandbox adds lots of conveniences for you. For example:
+ allows to use the {@link Matreshka#select} and {@link Matreshka#$} methods
+ allows to use the {@link Matreshka#sandbox} and {@link Matreshka#$sandbox}
+ adds a new ``:sandbox`` selector for the {@link Matreshka#bindNode}, {@link Matreshka#select}, {@link Matreshka#$} methods and others
+ adds syntactic sugar for delegated DOM events in the {@link Matreshka#on} method

> Also you can try {@link Matreshka#bindSandbox} which does the same thing but requires only one argument.

```js
// declare a sandbox
this.bindNode('sandbox', '.my-sandbox');

// .my-element is being searched for in the sandbox
this.bindNode('myKey', ':sandbox .my-element');

// it is not required to specify a key
// for the delegated events inside a sandbox
this.on('click::(.my-button)', function() { ... });

// will put the .inner-node element
// which is inside the sandbox into the console
console.log(this.$('.inner-node'));
```

#### Deep binding
Since version 1.1, the ``bindNode`` method supports the new feature called "deep binding". The method can bind DOM node to some property of nested object. For example, you have some nested object:
```js
this.a = {b: {c: {d: 42}}};
```

And you want to bind some DOM node to ``d``. The only thing you need is to pass a path to needed property and Matreshka will listen all changes throughout a tree of nested object by breaking a binding then re-creating it again:
```js
this.bindNode('a.b.c.d', '.my-node');
```

When some changes appear in the nested tree ``bindNode`` catches them and recreates binding again.
```js
this.a.b = {c: {d: 41}};
```

> This behavior is cancelable. You can set ``deep: false`` property for ``eventOptions`` object to ignore dot in a property name.

Это поведение можно отменить, передав свойство ``deep: false`` в объект события (``eventOptions``), тогда точка в имени свойства будет проигнорирована.


@see {@link Matreshka#unbindNode}
@see {@link Matreshka#bindOptionalNode}
@see {@link Matreshka#$}
@see {@link Matreshka.binders}
@see {@link Matreshka.defaultBinders}


@param {string|matreshka} key - A key (a property name)
@param {string|node|$nodes} node - An HTML element which must be bound to a ``key``
@param {binder} [binder] - A binder containing the following properties: ``on`` - which event must happen to an HTML node, informing that a user has changed something (for example, ``keyup`` or ``click``), ``getValue`` -  how to get a value from an HTML node, ``setValue`` - how to set a new value to a node and ``initialize`` - a function which is executed once after the initialization of binding. You can get more detailed information about binders in their documentation: see {@link #typedef-binder}.
@param {eventOptions} [eventOptions] - An event object which accepts ``"silent"`` (don't fire ``"bind"`` and ``"bind:KEY"``), ``"assignDefaultValue"`` (etract current node value), ``"debounce"`` (optimize DOM changes), ``"deep"`` (use "deep binding" or ignore a dot in a property name) or some custom data for event handlers.
@returns {matreshka} self

@example <caption>A custom checkbox. This example demonstrates the creation of custom element whose ``"checked"`` class is changed after clicking on it.</caption>
this.bindNode('myKey', '.custom-checkbox', {
	on: 'click',
	getValue: function() {
		return $(this).hasClass('checked');
	},
	setValue: function(v) {
		$(this).toggleClass('checked', !!v);
	},
	// initialize element behavior
	// the presence of 'checked' class name is changed after clicking on the element
	initialize: function() {
		$(this).on('click', function() {
			$(this).toggleClass('checked');
		});
	}
});

@example <caption>A custom checkbox 2. This example is the same as the previous one but it uses {@link Matreshka#defaultBinders}, and checks the element if the ``custom-checkbox``. class is present. If checking is OK, it returns the binder.</caption>
// add the binder to the 'binders' namespace
Matreshka.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $(this).hasClass('checked');
		},
		setValue: function(v) {
			$(this).toggleClass('checked', !!v);
		},
		initialize: function() {
			$(this).on('click', function() {
				$(this).toggleClass('checked');
			});
		}
	}
};

MK.defaultBinders.unshift(function(element) {
	// check if the element has the "custom-checkbox" class
	if($(element).hasClass('custom-checkbox')) {
		// if checking is OK, return a new binder
		return Matreshka.binders.customCheckbox();
	}
});

this.bindNode('myKey', '.my-custom-checkbox');

@example <caption>The ``"bind"`` event which is fired after any binding</caption>
this.on('bind', function() {
	alert('ok!');
});

this.bindNode('myKey', '.my-element'); // alerts "ok!"

@example <caption>The ``"bind:KEY"`` event which is fired after binding of specific property to HTML node</caption>
this.on('bind:myKey', function() {
	alert('ok!');
});

this.bindNode('myKey', '.my-element'); // alerts "ok!"

@example <caption>DOM event overriding for default binder. For example, we want to bind ``input[type="text"]`` to a property. By default, the standard binder contains ``"on"`` property with the ``"input"`` value for this kind of node. It means that a value of an instance property and node state will be synchronized when a user releases a key of the keyboard or pastes text from clipboard. In case if you want synchronization to be performed after the ``"blur"`` DOM event,  you will have to pass the object containing the only ``"on"`` property as the third argument. This object will join the default binder, having retained ``getValue`` and ``setValue`` values.</caption>
this.bindNode('myKey', '.my-input', {on: 'blur'});

@example <caption>If an element is not found, the ``"Bound element is missing"`` exception is thrown. In order to avoid the error, use the {@link Matreshka#bindOptionalNode} method</caption>
var $el = $();
this.bindNode('x', $el); // an error because $el is empty

@example <caption>Synchronization of a property value and HTML contents of a node</caption>
this.bindNode('myKey', '.my-element', {
	setValue: function(v) {
		this.innerHTML = v;
	}
});

// it can be done easier
this.bindNode('myKey', '.my-element', MK.binders.html());
*/


/**
@method Matreshka#bindNode
@importance 2
@variation 2
@summary Alternative syntax: "key-element" pairs
@desc In the {@link Matreshka#bindNode} method an object with the key-element pairs can be passed to avoid multiple invocation of the method and reduce the code.

@param {object} keyElementPairs - (see the example)
@param {binder} [binder] - (see above)
@param {eventOptions} [eventOptions] - (see above)

@example
this.bindNode({
	myKey1: '.custom-checkbox',
	myKey2: 'textarea'
});

@example <caption>Starting version 1.1 the syntax of the method is extended: you can pass an array with node and binder instead of just a node</caption>
this.bindNode({
	myKey1: ['.custom-checkbox', MK.binders.customCheckbox()],
	myKey2: 'textarea',
	myKey3: ['.my-node', {
		setValue: function(v) {
			// do something
		}
	}]
});
*/


/**
@method Matreshka#bindNode
@importance 2
@variation 3
@summary Alternative syntax: "heap of arguments"
@desc Another syntax for the {@link Matreshka#bindNode} method. This way may seem unattractive but sometimes you have need of binding lots of nodes to different properties at one operation. With such a syntax you can assign definite binders to some variable and then easily delete all at once using {@link Matreshka#unbindNode}.

@param {array} setOfArguments - The array of arrays (see the example)
@param {eventOptions} [eventOptions] - (see above)

@example
this.bindNode([
	[{
		myKey1: '.my-element1',
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3',
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5',
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
]);
*/

/**
@method Matreshka#bindOptionalNode
@importance 2
@since 0.3
@summary Works just the same as {@link Matreshka#bindNode} but it does not throw an exception if the ``node`` argument is an empty array, ``undefined`` or non-existent.
@see {@link Matreshka#bindNode}
@example
this.bindOptionalNode('myKey', '.my-element');
*/

/**
@method Matreshka#bindSandbox
@fires bind
@fires bind:sandbox
@importance 3
@since 1.5
@summary Binds a sandbox
@desc Optimized method for quick ``"sandbox"`` declaration.
@param {string|node|$node} node - A sandbox DOM node
@param {eventOptions} [eventOptions] -  Event object (``"silent"`` key disables firing the events ``"unbind"`` and ``"unbind:KEY"``)
@see {@link Matreshka#bindNode}
@example
this.bindSandbox('.my-element');
*/

/**
@method Matreshka#unbindNode
@importance 2
@fires unbind
@fires unbind:KEY
@summary Breaks a binding between given property and HTML node.
@desc Using this method you can delete the binding between a property and HTML node, which has been added recently and no longer needed.
@param {string|null} The key or a list of keys which are separated by spaces. If you pass ``null`` instead of the key, all bindings for the given instance will be deleted
@param {string|node|$nodes} [node] - HTML node
@param {eventOptions} [eventOptions] -  Event object (``"silent"`` key disables firing the events ``"unbind"`` and ``"unbind:KEY"``)
@returns {matreshka} self
@example
this.bindNode('myKey', '.my-element');

// changes the property value and the state of the HTML element
this.myKey = true;

this.unbindNode('myKey', '.my-element');

// only the property value is being changed now
this.myKey = false;
*/


/**
@method Matreshka#unbindNode
@importance 2
@variation 2
@summary Alternative syntax "key-element" for {@link Matreshka#unbindNode}
@see {@link Matreshka#bindNode(2)}
@param {object} keyElementPairs (see the example)
@param {eventOptions} [eventOptions] (see above)
@returns {matreshka} self
@example
this.unbindNode({
	myKey1: '.my-element1'
	myKey1: '.my-element2'
});
*/


/**
@method Matreshka#unbindNode
@importance 2
@variation 3
@summary Alternative syntax "heap of arguments" for {@link Matreshka#unbindNode}
@see {@link Matreshka#bindNode(3)}
@param {array} setOfArguments - An array of arrays (see the example)
@param {eventOptions} [eventOptions] (see above)
@returns {matreshka} self
@example
var temporaryBindings = [
	[{
		myKey1: '.my-element1'
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3'
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5'
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
];

this.bindNode(temporaryBindings);

// these bindings are no longer needed
this.unbindNode(temporaryBindings);
*/


/**
@method Matreshka#selectAll
@importance 2
@summary Returns HTML nodes corresponding to a selector from the sandbox
@desc After sandbox creation by the {@link Matreshka#bindNode} method, you can get and use HTML nodes which are located in it. Besides, the method supports the ``:bound(KEY)`` selector
@param {string} selector - A selector
@returns {$nodes}
@example
this.bindNode('sandbox', '.app');
this.selectAll('.my-element');
// the same as
this.$nodes.sandbox.find('.my-element');
// the same as
$('.app').find('.my-element');

@example <caption>The ``:bound(KEY)`` selector</caption>
this.bindNode('myKey', '.my-element');
this.selectAll(':bound(myKey) .my-another-element');
// the same as
this.$nodes.myKey.find('.my-another-element');
// the same as
$('.my-element').find('.my-another-element');
*/


/**
@method Matreshka#$
@importance 2
@variation instance
@summary Does the same as {@link Matreshka#selectAll}
@example
this.$('.my-element');
*/


/**
@method Matreshka#select
@importance 2
@summary Returns HTML node corresponding to a selector from the sandbox
@desc The method is very similar to {@link Matreshka#selectAll}, but it returns only one element or ``null``
@param {string} selector - A selector
@returns {node|null}
@example
this.bindNode('sandbox', '.app');
this.select('.my-element');
// the same as
this.nodes.sandbox.querySelector('.my-element');
// the same as
$('.app').find('.my-element')[0];
*/


/**
@method Matreshka#mediate
@importance 2
@since 0.1
@summary Transforms property value on its changing
@desc This method is used for transforming the property value on its changing. For example, you want the property value to be always either of a certain type or an integer value, or to be no less than zero and no more than a hundred etc.
@param {string|array} key - A key or an array of keys or a list of keys which are separated by spaces
@param {function} mediator - A function-mediator which returns a new value
@example
this.mediate('x', function(value) {
	return String(value);
});

this.x = 1;

alert(typeof this.x); // "string"
@example <caption>A list of keys which are separated by spaces</caption>
this.mediate('x y', function(value) {
	return String(value);
});
@example <caption>An array of keys</caption>
this.mediate(['x', 'y'], function(value) {
	return String(value);
});
*/


/**
@method Matreshka#mediate
@importance 2
@variation 2
@since 0.1
@summary Alternative syntax of the {@link Matreshka#mediate} method which accepts "key-mediator" object as an argument
@param {object} keyMediatorPairs - An object with key-mediator properties
@example
this.mediate({
	x: String,
	y: Number,
	z: Boolean
});
this.x = 1;
this.y = 2;
this.z = 3;
alert(typeof this.x); // "string"
alert(typeof this.y); // "number"
alert(typeof this.z); // "boolean"
@example <caption>A list of keys which are separated by spaces</caption>
this.mediate({
	'u v': String,
	'w x': Number,
	'y z': Boolean
});
*/


/**
@method Matreshka#setClassFor
@importance 2
@since 1.1
@summary Sets class for a property
@desc The method allows to precisely determine which class instance the set property will be. A developer doesn't have to worry about the fact that a property value will be accidentally rewritten by wrong type of data.

> The method is an addon over {@link Matreshka#mediate} and it overrides a mediator excluding the conflict of two mediators.


Class instance is being created during the launch of {@link Matreshka#setClassFor}  method. The current property value becomes the first argument of the class constructor. Provisions should be made so that either undefined (if a property hasn’t contained any data before), or an object you should do something with (for example, to extend class instance by object properties) will get into the class constructor.

> It looks easy in practice: you create an ordinary class which almost always receives some data to be handled (for example, to use them in {@link Matreshka.Object#jset} method).

While attempting to assign another value (an object or an array) to the property, the inner mechanism of ``setClassFor`` method performs the following instead of  assignment:
+ If ``updateCallback`` function is given, the method launches it with two arguments: the current property value and the data which code is trying to assign.
+ If given class is inherited from {@link Matreshka.Object}, the instance is updated with new data using {@link Matreshka.Object#jset} method.
+ If given class is inherited from M{@link Matreshka.Array}, the instance is updated with new data using {@link Matreshka.Object#recreate} method.
+ If ``updateCallback`` function isn’t given and class isn’t inherited from {@link Matreshka.Object} or {@link Matreshka.Array}, the instance is extended by object properties which code is trying to assign.

> A cool feature of this method is the absence of limitations on the class source. Any function-constructor that can be initialized using ``new`` operator and not only {@link Matreshka}'s successors can act as a class.

@param {string|array} key - Key or an array of keys or a list of keys which are separated by spaces.
@param {function} class - Class you want to assign to the property
@param {function} [updateCallback] - Function which is called at every attempt of assigning new data to the property, allowing to customize logic of class instance updating with new data. The function receives two arguments: the current property value (class instance) and data which are attempted to assign.
@example
var SubClass = Class({
	// ...
});

// ...

this.setClassFor('x', SubClass);

// trying to assign another value to property
this.x = {a: 42};

// this.x is still SubClass instance
alert(this.x instanceof SubClass); // true
alert(this.x.a); // 42
@example <caption>The use of ``updateCallback``.</caption>
this.setClassFor('x', SubClass, function(instance, data) {
	updateSomeHow(instance, data);
});
@example <caption>Getting parent and key. Besides data (the first argument), two arguments are passed to class constructor: a link to an instance which has called ``setClassFor`` and a key of the property.</caption>
var MySubClass = Class({
	'extends': Matreshka,
	constructor: function(data, parent, key) {
		// parent - is MyClass instance
		// key equals to "x"
	}
});

var MyClass = Class({
	'extends': Matreshka,
	constructor: function() {
		this.setClassFor('x', MySubClass);
	}
});

@example <caption>A non-standard way of using ``updateCallback`` for ignoring any changes of the property.</caption>
// MK.noop - is an empty function
this.setClassFor('x', SubClass, MK.noop);
@example <caption>In case if your class doesn’t support the use of ``new`` operator, use @link Matreshka#mediate} method instead of ``setClassFor``.</caption>
this.mediate('x', function(data, currentValue) {
	return currentValue instanceof SomeClass
		? Object.assign(currentValue, data)
		: SomeLib.initInstance(SomeClass, data);
});
@example <caption>An abstract example with large nested data (for brevity, ECMAScript 7 syntax is used)</caption>
// app.js
class App extends MK {
	constructor(appData) {
		this.appData = appData;
		this.setClassFor('appData', AppData);
	}
}

// app-data.js
class AppData extends MK.Object {
	constructor(data) {
		super(data)
			.setClassFor({
				friends: Friends,
				settins: Settings
			});
	}
}

// friend.js
class Friend extends MK.Object {
	constructor(data) {
		super(data);
	}
}

// friends.js
class Friends extends MK.Array {
	Model = Friend;
	trackBy = 'id';
	constructor(data) {
		super(...data);
	}
}

// settings.js
class Settings extends MK.Object {
	constructor(data) {
		super(data)
			.setClassFor('credentials', Credentials);
	}
}

// credentials.js
class Credentials extends MK.Object {
	constructor(data) {
		super(data);
	}
}

// app-init.js
var app = new App({
	settings: {
		name: 'Vasiliy Vasiliev',
		credentials: {
			email: 'vasia.vasia@gmail.com'
		}
	},
	friends: [{
		name: 'Yulia Zuyeva',
		id: 1
	}, {
		name: 'Konstantin Konstantinopolsky',
		id: 2
	}, {
		name: 'nagibator3000',
		id: 3
	}]
});

// data can be serialized and passed to the server
JSON.stringify(app.appData);


// next just to assign new data to appData property
// yet the class structure won’t be changed
app.appData = {
	settings: {
		name: 'Petr Petrov',
		credentials: {
			email: 'petr.petrov@gmail.com'
		}
	},
	friends: [{
		name: 'Yulechka Zuyeva',
		id: 1
	}, {
		name: 'Konstantin Konstantinopolsky',
		id: 2
	}]
};
*/


/**
@method Matreshka#setClassFor
@importance 2
@variation 2
@since 1.1
@summary Additional syntax for {@link Matreshka#setClassFor}, which accepts key-class object as the first argument.
@param {object} keyClassPairs - key-class object
@param {function} [updateCallback] - Function which is called at every attempt of assigning new data to the property.
@example
this.setClassFor({
	x: Class1,
	y: Class2,
	z: Class3
}, function(data) {
	instance.jset(data);
});
*/


/**
@method Matreshka#linkProps
@importance 1
@since 0.1
@summary Creates a dependency of one property value on values of others
@desc The ``linkProps`` method creates a dependency of a property value (target property, the first argument) on values of other properties (source properties, the second argument). The method is protected from circular references (for example, ``a`` depends on ``b``, ``b`` depends on ``c`` and ``c`` depends on ``a``) and if there is a calculation error, it does not block the page and does not throw an exception about the stack over-flow.

In Matreshka 1.5 the ``setOnInit`` (4th argument) is replaced by ``eventOptions`` which gives more useful features to the method.

### Passing data to a property-change event handler and special flags
You can pass some data to ``change:KEY`` event handler via ``eventOptions``.

```js
this.on('change:a', function(evt) {
	alert(evt.foo); // 'bar'
});

this.linkProps('a', 'b c', function(b, c) {
	return b + c;
}, {
	foo: 'bar'
});
```

Besides, ``eventOptions`` allows you to pass special flags (eg. ``silent: true``)
```js
this.on('change:a', function(evt) {
	alert('foo');
});

this.linkProps('a', 'b c', function(b, c) {
	return b + c;
}, {
	silent: true
});

this.b = 1;
```

In the example above when ``linkProps`` mechanism changes a source property, event handler isn't called.


> If the target property is changed in some other way eg via direct assignment (``this.a = 42``) then ``change:KEY`` handler still will be called.

The full list of supported flags you can find at {@link Matreshka#set}.

### Immediate property calculation on  ``linkProps`` call

By default, a property will be calculated immediately after ``linkProps`` is called.

```js
var handler = function(b, c) {
	return b + c;
};

this.b = 1;
this.c = 2;
this.linkProps('a', 'b c', handler);
alert(this.a); // 3
```

To cancel this behavior pass ``setOnInit: false`` flag into the  ``eventOptions`` object. This flag is helpful when source properties aren't set yet and you don't want to get a "bad" value of the target property. In the example below ``linkProps`` is calculating a sum of ``b`` and ``c`` as ``undefined + undefined`` and  ``a`` becomes ``NaN``.

```js
var handler = function(b, c) {
	return b + c;
};

this.linkProps('a', 'b c', handler);
alert(this.a); // NaN
```

```js
this.linkProps('a', 'b c', handler, {
	setOnInit: false // everything is OK now
});
```

### Immediate calculation
A process of recalculation of a target property is instantaneous and synchronous. That means every change of source property triggers ``linkProps`` mechanism immediately. Look at this example:

```js
var handler = function(b, c) {return b + c;};

this.linkProps('a', 'b c', handler);
this.b = 1;
this.c = 2;
```
The ``handler`` is going to be called thrice. The first call is on ``linkProps`` call (if ``setOnInit`` isn't used), the second call is on ``b`` assignment and the third call is on ``c`` assignment. This behavior is based on one idea: "all reactions on every change have to occur consistently and predictably". If you want to optimize this behavior pass ``debounce: true`` property to the ``eventOptions`` object. Look at the {@link Matreshka.debounce}.

```js
var handler = function(b, c) {
	return b + c;
};

this.linkProps('a', 'b c', handler, {
	debounce: true
});
this.b = 1;
this.c = 2;
```
In the example above the ``handler`` will be called only once after tiny delay.


@param {string|array} targetKeys - A property (properties) which depends on other ones
@param {string|array} sourceKeys - Which properties the desired property (properties) is depended on
@param {function} [handler=function(v){return v}] - A function which returns a new value
@param {object} [eventOptions] - An object which can contain some special flags or data for ``change:KEY`` handler (see above)
@example
this.linkProps('greeting', 'name', function() {
	return 'Hello, ' + this.name + '!';
});

this.name = 'Joe';

alert(this.greeting); // 'Hello, Joe!'

@example <caption>A complicated example: the calculation of the rectangle perimeter with two sides known (and the calculation of the sides with the perimeter known). As you see, ``linkProps`` can be used for the solution of mathematical problems as well, where every member of equation can be used as the unknown</caption>
this.a = 3;

this.b = 4;

this.linkProps('p', 'a b', function(a, b) {
	return (a + b) * 2;
});

this.linkProps('a', 'p b', function(p, b) {
	return p/2 - b;
});

this.linkProps('b', 'p a', function(p, a) {
	return p/2 - a;
});

alert(this.p); // 14

this.on('change:p', function() {
	alert('The perimeter has been changed and equals ' + this.p);
});

this.a = 5; // alerts "The perimeter has been changed and equals 18"

@example <caption>Starting the v1.1, you can pass a path to target property</caption>
this.a = {b: {c: 21}};

this.linkProps('x', 'a.b.c', function(c) {
	return c * 2;
});

alert(this.x); //42
*/


/**
@method Matreshka#linkProps
@importance 1
@variation 2
@since 0.2
@summary An additional possibility of the {@link Matreshka#linkProps} method: a dependency on property values of other instances
@param {string|array} targetKeys - A property (properties) which depends on other ones
@param {array} instancesAndKeys - An array which contains instances (even elements) and their keys (uneven elements), which a desired property (properties) is depended on. This syntax which may seem strange is the consequence of JavaScript syntax constraints.
@param {function} [handler=function(v){return v}] - A function which returns a new value
@param {object} [eventOptions] - An object which can contain some special flags or data for ``change:KEY`` handler (see above)
@example <caption>The ``sum`` property is a sum of ``a`` and ``b`` values of other instances and it is calculated every time on their changing</caption>
anotherInstance1.a = 2;

anotherInstance2.b = 3;

this.linkProps('sum', [
	anotherInstance1, 'a',
	anotherInstance2, 'b'
], function(a, b) {
	return a + b;
});

alert(this.sum); // 5

this.on('change:sum', function() {
	alert('this.sum equals ' + this.sum);
});

anotherInstance1.a = 5; // "this.sum equals 8"
*/


/**
@method Matreshka#get
@importance 3
@summary Returns a value of property
@param {string} key
@example
// the same as this['myKey'] or this.myKey
this.get('myKey');
*/


/**
@method Matreshka#set
@importance 1
@fires change
@fires change:KEY
@fires beforechange
@fires beforechange:KEY
@summary Sets a property value allowing to pass an event object as the third argument
@desc The list of the supported flags:
+ ``silent`` -  do not call the ``change`` and ``change:KEY`` events
+ ``silentHTML`` - do not change states of bound HTML nodes
+ ``force`` - call the ``change`` and ``change:KEY`` events even though the property value has not been changed
+ ``forceHTML`` - change a state of bound element even though the property value has not been changed. This option is usable if the bound element has been rendered after the binding (for example, some ``option`` tags have been added to ``select`` tag)
+ ``skipMediator`` - prevents the property transformation by a mediator (see {@link Matreshka#mediate})
+ ``skipLinks`` - prevents the work of dependencies created with {@link Matreshka#linkProps}
@param {string} key - A key
@param {*} value - A value
@param {eventOptions} [eventOptions] - An event object
@example
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// the same as this['myKey'] = 3
// or this.myKey = 3
// alerts 3
this.set('myKey', 3);
@example <caption>Using ``eventOptions``</caption>
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// handler isn't called
this.set('myKey', 4, {
	silent: true
});

@example <caption>Passing custom data to a handler</caption>
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.myCustomFlag);
});

// displays 42
this.set('myKey', 4, {
	myCustomFlag: 42
});
*/


/**
@method Matreshka#set
@variation 2
@summary Alternative "key-value" syntax of the {@link Matreshka#set} method
@param {object} keyValuePairs - An object containing key-value pairs
@param {eventOptions} [eventOptions] - An event object
@example
this.set({
	myKey1: 1,
	myKey2: 2
});
@example <caption>Passing  ``eventOptions`` as second argument</caption>
this.set({
	myKey: 3
}, {
	myFlag: 'Jigurda'
});
*/


/**
@method Matreshka#remove
@importance 3
@fires delete
@fires delete:KEY
@summary Deletes a property
@param {string} key - A key or keys which are separated by a space
@param {eventOptions} [eventOptions] - An event object
@returns {matreshka} self
@example
this.remove('myKey');
this.remove('myKey1 myKey2');
@example <caption>Using  ``eventOptions``</caption>
this.remove('myKey', {
	silent: true
});
*/


/**
@method Matreshka#parseBindings
@importance 2
@since 1.1
@summary Parses DOM tree, declaring property bindings which are double braced.
@desc Starting with 1.1 version, Matreshka includes a simple DOM parser that handles double braced syntactic constructions. ``parseBindings`` method receives one optional argument: HTML string, DOM node or selector corresponding to DOM node. If argument isn’t set, parser handles a sandbox (see {@link Matreshka#bindNode}).

As the method is DOM template engine (and not HTML-replace parser), all child DOM nodes of the passed element remain in their same state (for example, DOM events aren’t erased).

### The supported syntax
1. HTML binding
```html
<!--
will create DOM node in place of &#123;{user.name}}
and will bind name property from user object to this node
JS: this.user = {name: 'Joe'}
-->
<span>Hello, &#123;{user.name}}</span>
```

2. Binding form elements.
```html
<!--
will bind "x" instance property to a text field (two-way data binding)
JS: this.x = 'some value';
-->
<input type="text" value="&#123;{x}}">
<!--
For binding textarea and select you should use value attribute
-->
<textarea value="&#123;{x}}"></textarea>
<select value="&#123;{x}}">...</select>
<!--
will bind "x" instance property to a checkbox (two-way data binding)
JS: this.x = true;
-->
<input type="checkbox" checked="&#123;{x}}">
```

3. Attributes binding.
```html
<!--
href attribute value will depend on "category"
and "someObject.page" value (one-way data binding)
JS:
 this.category = 'matreshka';
 this.someObject = {page: 42}
-->
<a href="http://example.com/&#123;{category}}/&#123;{someObject.page}}">A link</a>
<!--
The result:
<a href="http://example.com/matreshka/42">A link</a>
-->
```

#### Why do we need this method?
In case if you develop a large form with standard HTML5 fields, the method will help you save time on declaring numerous bindings. Besides, ``parseBindings`` is useful in case of creating a very simple collection which doesn’t require implementation of a complicated {@link Matreshka.Array#Model model}.

#### Is it compatible with Matreshka ideology ("all logic must be included into JavaScript file")?
Yes, no cycles, conditional operators or any other logic are supported in the parser. Only declaration of simple bindings is available for a developer using ``parseBindings`.

#### Performance
The method works a little slower than manual declaration of bindings with {@link Matreshka#bindNode} method. You should bear that in mind while creating applications with very strict performance requirements. The speed decreases a little only during the process of binding. As for the rest, bindings work as fast as with {@link Matreshka#bindNode}.

> If you want to use something else instead of braces look at {@link Matreshka.parserBrackets}

@param {string|node|$nodes} [node] - HTML string, selector, DOM node or collection of DOM nodes
@returns {$nodes} A collection of DOM nodes (usually contained single node), which is passed to the method as an argument; or a sandbox, in case when there are no arguments are passed.

@example <caption>Parsing of given node</caption>
this.parseBindings(node);

@example <caption>Parsing of nodes matching given selector</caption>
this.parseBindings('.my-node');

@example <caption>HTML string parsing</caption>
var $node = this.parseBindings('<h3>Hello, &#123;{name}}</h3>');
this.name = 'Arthur Philip Dent';

@example <caption>Sandbox parsing</caption>
this.bindNode('sandbox', '.my-node');
this.parseBindings();
*/
