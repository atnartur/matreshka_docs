/**
@class Matreshka
@importance 1
@lang en
@author Andrey Gubanov <a@odessite.com.ua>
@license {@link https://raw.github.com/finom/matreshka/master/LICENSE MIT}
Version 2.0, January 2004
@alias MK
@see {@link Class}
@classdesc The class ``Matreshka`` is a core of the Matreshka.js framework which is inherited by {@link Matreshka.Array}, {@link Matreshka.Object} and every class of the application you create. It contains the main functionality of the framework, among which there are some very useful functions, such as {@link Matreshka#mediate mediators}, {@link Matreshka#linkProps dependencies}, {@link Matreshka#bindNode two-way data binding}, {@link Matreshka#on an event engine}, etc. The inheritance of this class, the same as the inheritance of any other class, is carried out with the help of the {@link Class} function.

This class, (like {@link Matreshka.Array} and {@link Matreshka.Object}), usually isn't used directly. Instead, it is inherited by the classes that you create. Therefore, the examples to the properties and methods in this documentation, as a rule, will be given with the use of ``this`` keyword.
@example <caption>Creating of an instance</caption>
var mk = new Matreshka();
@example <caption>You can use ``MK`` variable instead of ``Matreshka``</caption>
var mk = new MK();
@example <caption>Inheritance</caption>
var MyClass = MK.Class({
	'extends': Matreshka,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});
@example <caption>Matreshka uses prototypes for implementing the inheritance. The {@link Class} function just brings in some syntactic sugar. That's why you can use any other way of the inheritance you like, for example, using classes from ECMAScript 2015</caption>
class MyClass extends Matreshka {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}
*/


/**
@member {boolean} Matreshka#isMK
@importance 3
@summary ``isMK`` always equals ``true``. This property is used for defining whether an object is an instance of the {@link Matreshka} class
@example
alert(object.isMK);
*/


/**
@member {$nodes} Matreshka#$nodes
@importance 2
@since 1.1
@summary An object contains collections (jQuery, Zepto, built-in micro-library instance inherited from ``Array.prototype``) of bound nodes for quick access.
@see {@link Matreshka#bindNode}
@example
this.bindNode('myKey', '.my-node');
this.$nodes.myKey; // the same as $('.my-node')
*/


/**
@member {node} Matreshka#nodes
@importance 2
@since 1.1
@summary The object contains bound elements in the form of separate DOM nodes for quick access.
@desc Pay attention, every object property has got the first node of the bound ones to the corresponding property. Use {@link Matreshka#$nodes} for getting all the nodes bound to a certain property.
@see {@link Matreshka#bindNode}
@example
this.bindNode('myKey', '.my-node');
this.nodes.myKey; // the same as $('.my-node')[0]
*/

/**
@method Matreshka#on
@importance 1
@fires addevent
@fires addevent:NAME
@summary Adds an event handler
@desc The {@link Matreshka#on} method adds an event handler for an instance of the ``Matreshka`` class. Refer to the complete list of possible events with the description here: {@link #typedef-eventNames}.
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@param {eventNames} names - An event name or some names which are separated by a space (for example, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} callback - A function which is caused by the event
@param {boolean} [triggerOnInit=false] - If ``triggerOnInit`` argument equals ``true``, the handler will be called immediately after event initialization.
@param {object} [context] - A context of the handler. In other words, ``this`` when called ``callback``
@returns {matreshka} self
@example
this.on('foo', function() {
	alert('Custom Event is fired');
});

this.trigger('foo');
@example <caption>Passing a context</caption>
this.on('foo', function() {
	alert(this.a); // 5
}, {a: 5});

this.trigger('foo', 'Hello world');
@example <caption>Calling a handler immediately after event initialization</caption>
// Displays "bar" at once and waits for a firing of "foo" event
this.on('foo', function() {
	alert('bar');
}, true);
*/


/**
@method Matreshka#on
@importance 2
@variation 2
@since 1.1
@summary Alternative syntax: "eventname-handler" pairs
@desc In the {@link Matreshka#on} method the object with the key-element pairs can be passed to avoid multiple invocation of the method and reduce your code.

@param {object} evtnameHandlerObject - An object where keys are event names and values are event handlers
@param {boolean} [triggerOnInit=false] - If ``triggerOnInit`` argument  equals ``true``, all handlers will be called immediately after event initialization.
@param {object} [context] - A context of the handler
@returns {matreshka} self
@example
this.on({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});

@example <caption>ECMAScript 2015</caption>
this.on({
	'custom': evt => ...,
	'click::x': evt => ...,
	'change:y': evt => ...,
});
*/


/**
@method Matreshka#onDebounce
@importance 2
@fires addevent
@fires addevent:NAME
@summary Adds an event handler which is called only once during a definite period of time
@desc The method allows to add an event handler to an instance of the {@link Matreshka} class, debouncing the handler. Callback function can be called only once during a definite period of time. As to the rest the method works the same as {@link Matreshka#on}.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#off}
@see {@link Matreshka#trigger}
@see {@link Matreshka.debounce}
@see {@link http://davidwalsh.name/javascript-debounce-function JavaScript Debounce Function}
@param {eventNames} names - An event name or some names which are separated by a space (for example, ``"change:x ajaxcomplete change:y"``).
@param {eventHandler} callback - A handler which is caused by an event
@param {number} [debounceDelay=0] - A delay
@param {boolean} [triggerOnInit=false] - If ``triggerOnInit`` argument equals ``true``, the handler will be called immediately after event initialization.
@param {object} [context] - A context of a handler. In other words, ``this`` when called ``callback``
@returns {matreshka} self
@example
this.onDebounce('change:x', function() {
	alert('x = ' + this.x); // x = 100
}, 300);

this.x = 1;

for(var i = 0; i < 100; i++) {
	this.x++;
}
*/


/**
@method Matreshka#onDebounce
@importance 2
@variation 2
@since 1.1
@summary Alternative syntax: "eventname-handler" pairs
@see {@link Matreshka#on(2)}
@param {object} evtnameHandlerObject - An object where keys are event names and values are event handlers
@param {number} [debounceDelay=0] - A delay
@param {boolean} [triggerOnInit=false] - If ``triggerOnInit`` argument equals ``true``, all handlers will be called immediately after event initialization
@param {object} [context] - A context of a handler
@returns {matreshka} self
@example
this.onDebounce({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});
*/

/**
@method Matreshka#once
@importance 2
@fires addevent
@fires addevent:NAME
@summary Adds an event handler which can be called only once
@desc The method works the same as {@link Matreshka#on} but the passing handler can be called only once. Note the method lacks the ``triggerOnInit`` argument.
@see {@link Matreshka#on}
@see {@link Matreshka#off}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} names - An event name or some names which are separated by a space (for example, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} callback - A handler which is caused by an event
@param {object} [context] - A context of a handler
@returns {matreshka} self
@example
this.x = 1;

this.once('change:x', function() {
	alert('x is changed');
});

this.x = 2; // displays 'x is changed'

this.x = 3; // does nothing
*/


/**
@method Matreshka#once
@importance 2
@variation 2
@since 1.1
@summary Alternative syntax: "eventname-handler" pairs
@see {@link Matreshka#on(2)}
@param {object} evtnameHandlerObject - An object where keys are event names and values are event handlers
@param {object} [context] - A context of a handler
@returns {matreshka} self
@example
this.once({
	'custom': function(evt) { ... },
	'click::x': function(evt) { ... },
	'change:y': function(evt) { ... }
});
*/

/**
@method Matreshka#off
@importance 1
@fires removeevent
@fires removeevent:NAME
@summary Deletes an event handler
@desc It deletes a handler which has been created before. All the three arguments are optional. You can delete both all the events (without passing any argument) and separate ones (having passed only the event name, the event name and the handler, the event name and the handler and the context)
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#trigger}
@param {eventNames} [names] - A list of event names which are separated by spaces (for example, ``"change:x ajaxcomplete change:y"``)
@param {eventHandler} [callback] - A function-handler
@param {object} [context] - A context
@returns {matreshka} self
@example
this.off('change:x bind');
@example <caption>The deletion of all events</caption>
this.off();
@example <caption>The deletion of an event with definite handler</caption>
var handler = function() {
	//...
}
this.on('change:x', handler);
this.off('change:x', handler);
@example <caption>The deletion of an event with definite context</caption>
var object = {};
this.on('change:x', handler, object);
this.off('change:x', handler, object);
*/


/**
@method Matreshka#trigger
@importance 1
@summary Fires an event
@desc After adding event handlers using {@link Matreshka#on}, {@link Matreshka#onDebounce} or {@link Matreshka#once}, any event can be fired manually using this method.
@see {@link Matreshka#on}
@see {@link Matreshka#once}
@see {@link Matreshka#onDebounce}
@see {@link Matreshka#off}
@param {eventNames} [names] - An event name or some names which are separated by a space
@param {...*} [arg] - Any arguments which will be passed to every handler
@returns {matreshka} self
@example
this.on('foo bar', function(a, b, c) {
	alert(a + b + c);
});
this.trigger('foo', 1, 2, 3); // alerts 6
*/


/**
@method Matreshka#bindOptionalNode
@importance 2
@since 0.3
@summary Works just the same as {@link Matreshka#bindNode} but it does not throw an exception if the ``node`` argument is an empty array, ``undefined`` or non-existent.
@see {@link Matreshka#bindNode}
@example
this.bindOptionalNode('myKey', '.my-element');
*/

/**
@method Matreshka#bindSandbox
@fires bind
@fires bind:sandbox
@importance 3
@since 1.5
@summary Binds a sandbox
@desc Optimized method for quick ``"sandbox"`` declaration.
@param {string|node|$node} node - A sandbox DOM node
@param {eventOptions} [eventOptions] -  Event object (``"silent"`` key disables firing the events ``"unbind"`` and ``"unbind:KEY"``)
@see {@link Matreshka#bindNode}
@example
this.bindSandbox('.my-element');
*/


/**
@method Matreshka#selectAll
@importance 2
@summary Returns HTML nodes corresponding to a selector from the sandbox
@desc After sandbox creation by the {@link Matreshka#bindNode} method, you can get and use HTML nodes which are located in it. Besides, the method supports the ``:bound(KEY)`` selector
@param {string} selector - A selector
@returns {$nodes}
@example
this.bindNode('sandbox', '.app');
this.selectAll('.my-element');
// the same as
this.$nodes.sandbox.find('.my-element');
// the same as
$('.app').find('.my-element');

@example <caption>The ``:bound(KEY)`` selector</caption>
this.bindNode('myKey', '.my-element');
this.selectAll(':bound(myKey) .my-another-element');
// the same as
this.$nodes.myKey.find('.my-another-element');
// the same as
$('.my-element').find('.my-another-element');
*/


/**
@method Matreshka#$
@importance 2
@variation instance
@summary Does the same as {@link Matreshka#selectAll}
@example
this.$('.my-element');
*/


/**
@method Matreshka#select
@importance 2
@summary Returns HTML node corresponding to a selector from the sandbox
@desc The method is very similar to {@link Matreshka#selectAll}, but it returns only one element or ``null``
@param {string} selector - A selector
@returns {node|null}
@example
this.bindNode('sandbox', '.app');
this.select('.my-element');
// the same as
this.nodes.sandbox.querySelector('.my-element');
// the same as
$('.app').find('.my-element')[0];
*/


/**
@method Matreshka#mediate
@importance 2
@since 0.1
@summary Transforms property value on its changing
@desc This method is used for transforming the property value on its changing. For example, you want the property value to be always either of a certain type or an integer value, or to be no less than zero and no more than a hundred etc.
@param {string|array} key - A key or an array of keys or a list of keys which are separated by spaces
@param {function} mediator - A function-mediator which returns a new value
@example
this.mediate('x', function(value) {
	return String(value);
});

this.x = 1;

alert(typeof this.x); // "string"
@example <caption>A list of keys which are separated by spaces</caption>
this.mediate('x y', function(value) {
	return String(value);
});
@example <caption>An array of keys</caption>
this.mediate(['x', 'y'], function(value) {
	return String(value);
});
*/


/**
@method Matreshka#mediate
@importance 2
@variation 2
@since 0.1
@summary Alternative syntax of the {@link Matreshka#mediate} method which accepts "key-mediator" object as an argument
@param {object} keyMediatorPairs - An object with key-mediator properties
@example
this.mediate({
	x: String,
	y: Number,
	z: Boolean
});
this.x = 1;
this.y = 2;
this.z = 3;
alert(typeof this.x); // "string"
alert(typeof this.y); // "number"
alert(typeof this.z); // "boolean"
@example <caption>A list of keys which are separated by spaces</caption>
this.mediate({
	'u v': String,
	'w x': Number,
	'y z': Boolean
});
*/


/**
@method Matreshka#setClassFor
@importance 2
@since 1.1
@summary Sets class for a property
@desc The method allows to precisely determine which class instance the set property will be. A developer doesn't have to worry about the fact that a property value will be accidentally rewritten by wrong type of data.

> The method is an addon over {@link Matreshka#mediate} and it overrides a mediator excluding the conflict of two mediators.


Class instance is being created during the launch of {@link Matreshka#setClassFor}  method. The current property value becomes the first argument of the class constructor. Provisions should be made so that either undefined (if a property hasn’t contained any data before), or an object you should do something with (for example, to extend class instance by object properties) will get into the class constructor.

> It looks easy in practice: you create an ordinary class which almost always receives some data to be handled (for example, to use them in {@link Matreshka.Object#jset} method).

While attempting to assign another value (an object or an array) to the property, the inner mechanism of ``setClassFor`` method performs the following instead of  assignment:
+ If ``updateCallback`` function is given, the method launches it with two arguments: the current property value and the data which code is trying to assign.
+ If given class is inherited from {@link Matreshka.Object}, the instance is updated with new data using {@link Matreshka.Object#jset} method.
+ If given class is inherited from M{@link Matreshka.Array}, the instance is updated with new data using {@link Matreshka.Object#recreate} method.
+ If ``updateCallback`` function isn’t given and class isn’t inherited from {@link Matreshka.Object} or {@link Matreshka.Array}, the instance is extended by object properties which code is trying to assign.

> A cool feature of this method is the absence of limitations on the class source. Any function-constructor that can be initialized using ``new`` operator and not only {@link Matreshka}'s successors can act as a class.

@param {string|array} key - Key or an array of keys or a list of keys which are separated by spaces.
@param {function} class - Class you want to assign to the property
@param {function} [updateCallback] - Function which is called at every attempt of assigning new data to the property, allowing to customize logic of class instance updating with new data. The function receives two arguments: the current property value (class instance) and data which are attempted to assign.
@example
var SubClass = MK.Class({
	// ...
});

// ...

this.setClassFor('x', SubClass);

// trying to assign another value to property
this.x = {a: 42};

// this.x is still SubClass instance
alert(this.x instanceof SubClass); // true
alert(this.x.a); // 42
@example <caption>The use of ``updateCallback``.</caption>
this.setClassFor('x', SubClass, function(instance, data) {
	updateSomeHow(instance, data);
});
@example <caption>Getting parent and key. Besides data (the first argument), two arguments are passed to class constructor: a link to an instance which has called ``setClassFor`` and a key of the property.</caption>
var MySubClass = MK.Class({
	'extends': Matreshka,
	constructor: function(data, parent, key) {
		// parent - is MyClass instance
		// key equals to "x"
	}
});

var MyClass = MK.Class({
	'extends': Matreshka,
	constructor: function() {
		this.setClassFor('x', MySubClass);
	}
});

@example <caption>A non-standard way of using ``updateCallback`` for ignoring any changes of the property.</caption>
// MK.noop - is an empty function
this.setClassFor('x', SubClass, MK.noop);
@example <caption>In case if your class doesn’t support the use of ``new`` operator, use @link Matreshka#mediate} method instead of ``setClassFor``.</caption>
this.mediate('x', function(data, currentValue) {
	return currentValue instanceof SomeClass
		? Object.assign(currentValue, data)
		: SomeLib.initInstance(SomeClass, data);
});
@example <caption>An abstract example with large nested data (for brevity, ECMAScript 7 syntax is used)</caption>
// app.js
class App extends MK {
	constructor(appData) {
		this.appData = appData;
		this.setClassFor('appData', AppData);
	}
}

// app-data.js
class AppData extends MK.Object {
	constructor(data) {
		super(data)
			.setClassFor({
				friends: Friends,
				settins: Settings
			});
	}
}

// friend.js
class Friend extends MK.Object {
	constructor(data) {
		super(data);
	}
}

// friends.js
class Friends extends MK.Array {
	Model = Friend;
	trackBy = 'id';
	constructor(data) {
		super(...data);
	}
}

// settings.js
class Settings extends MK.Object {
	constructor(data) {
		super(data)
			.setClassFor('credentials', Credentials);
	}
}

// credentials.js
class Credentials extends MK.Object {
	constructor(data) {
		super(data);
	}
}

// app-init.js
var app = new App({
	settings: {
		name: 'Vasiliy Vasiliev',
		credentials: {
			email: 'vasia.vasia@gmail.com'
		}
	},
	friends: [{
		name: 'Yulia Zuyeva',
		id: 1
	}, {
		name: 'Konstantin Konstantinopolsky',
		id: 2
	}, {
		name: 'nagibator3000',
		id: 3
	}]
});

// data can be serialized and passed to the server
JSON.stringify(app.appData);


// next just to assign new data to appData property
// yet the class structure won’t be changed
app.appData = {
	settings: {
		name: 'Petr Petrov',
		credentials: {
			email: 'petr.petrov@gmail.com'
		}
	},
	friends: [{
		name: 'Yulechka Zuyeva',
		id: 1
	}, {
		name: 'Konstantin Konstantinopolsky',
		id: 2
	}]
};
*/


/**
@method Matreshka#setClassFor
@importance 2
@variation 2
@since 1.1
@summary Additional syntax for {@link Matreshka#setClassFor}, which accepts key-class object as the first argument.
@param {object} keyClassPairs - key-class object
@param {function} [updateCallback] - Function which is called at every attempt of assigning new data to the property.
@example
this.setClassFor({
	x: Class1,
	y: Class2,
	z: Class3
}, function(data) {
	instance.jset(data);
});
*/


/**
@method Matreshka#set
@importance 1
@fires change
@fires change:KEY
@fires beforechange
@fires beforechange:KEY
@summary Sets a property value allowing to pass an event object as the third argument
@desc The list of the supported flags:
+ ``silent`` -  do not call the ``change`` and ``change:KEY`` events
+ ``silentHTML`` - do not change states of bound HTML nodes
+ ``force`` - call the ``change`` and ``change:KEY`` events even though the property value has not been changed
+ ``forceHTML`` - change a state of bound element even though the property value has not been changed. This option is usable if the bound element has been rendered after the binding (for example, some ``option`` tags have been added to ``select`` tag)
+ ``skipMediator`` - prevents the property transformation by a mediator (see {@link Matreshka#mediate})
+ ``skipLinks`` - prevents the work of dependencies created with {@link Matreshka#linkProps}
@param {string} key - A key
@param {*} value - A value
@param {eventOptions} [eventOptions] - An event object
@example
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// the same as this['myKey'] = 3
// or this.myKey = 3
// alerts 3
this.set('myKey', 3);
@example <caption>Using ``eventOptions``</caption>
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.value);
});

// handler isn't called
this.set('myKey', 4, {
	silent: true
});

@example <caption>Passing custom data to a handler</caption>
this.on('change:myKey', function(eventOptions) {
	alert(eventOptions.myCustomFlag);
});

// displays 42
this.set('myKey', 4, {
	myCustomFlag: 42
});
*/


/**
@method Matreshka#set
@variation 2
@summary Alternative "key-value" syntax of the {@link Matreshka#set} method
@param {object} keyValuePairs - An object containing key-value pairs
@param {eventOptions} [eventOptions] - An event object
@example
this.set({
	myKey1: 1,
	myKey2: 2
});
@example <caption>Passing  ``eventOptions`` as second argument</caption>
this.set({
	myKey: 3
}, {
	myFlag: 'Jigurda'
});
*/


/**
@method Matreshka#remove
@importance 3
@fires delete
@fires delete:KEY
@summary Deletes a property
@param {string} key - A key or keys which are separated by a space
@param {eventOptions} [eventOptions] - An event object
@returns {matreshka} self
@example
this.remove('myKey');
this.remove('myKey1 myKey2');
@example <caption>Using  ``eventOptions``</caption>
this.remove('myKey', {
	silent: true
});
*/
