
/**
@method Matreshka#bindNode
@importance 1
@fires bind
@fires bind:KEY
@summary Binds a property of an object to HTML node, implementing two-way data binding
@desc {@link Matreshka#bindNode} is the only method of the {@link Matreshka} class  which is responsible for changing DOM (except array renderer). It creates a bridge between value of a property and state of HTML node on the page: from a simple input to a complicated widget (the complexity of elements is unlimited). ``bindNode``can be truly regarded as the main method of the framework. After using this method, it isn't necessary to monitor the synchronizations between model and view.

The method acepts three arguments: **a property name** (key), **HTML node** (or a selector) and a **binding rule** (a binder). In its turn, a binder is an ordinary object and it can have the following properties: ``on``, ``getValue``, ``setValue``, ``initialize``, ``destroy`` (Read more here: {@link #typedef-binder}). All the five properties are optional. It also allows to declare one-way data bindings (any direction).

> The ``bindNode`` method  supports the many-to-many bindings. Several elements can be bound to one property and several properties can be bound to one element, including ones from different instances of various classes.

```js
this.bindNode('myKey', '.my-element', {
	on: 'click',
	getValue: function() { ... },
	setValue: function() { ... }
});
```

For example, you want to bind a property of an object to a ``input[type="checkbox"]`` node:
```js
this.bindNode('myKey', '.my-checkbox', {
	// when is element state changed?
	// - after 'click' event
	on: 'click',
	// how to extract element state?
	// - return 'checked' value
	getValue: function() {
		return this.checked;
	},
	// how to set element state?
	// - set 'checked' value
	setValue: function(v) {
		this.checked = !!v;
	}
});
```

After binding is declared, you can set value of an object property in your most habitual way and HTML node (in this case, a checkbox) will change its state in no time. After clicking on the checkbox, the property value will be changed to the corresponding one as well.
```js
// sets checked = true
this.myKey = true;
```

More complicated example: binding object property to jQuery UI widget
```html
<div class="my-slider"></div>
```

```js
this.bindNode('myKey', '.my-slider', {
	// when is element state changed?
	// - after 'slide' event
	on: 'slide',
	// how to extract element state?
	// - return 'value' of the widget
	getValue: function() {
		return $(this).slider('option', 'value');
	},
	// how to set element state?
	// - set 'value'
	setValue: function(v) {
		$(this).slider('option', 'value', v);
	},
	// how to initialize the widget?
	// you can initialize the slider in any way,
	// but 'initialize' function provides some syntactic sugar
	initialize: function() {
		$(this).slider({min: 0, max: 100});
	}
});
```

```js
// will set the slider value 42
this.myKey = 42;
```

It looks easy but you may ask a question: "What should I do to avoid writing these rules every time?". The question is absolutely correct. Indeed, there can be a lot of elements of the same type on the page: text fields, drop down menus, new fields from the HTML5 specification as well as third party widgets (see the example above).

As observed in this documentation, the third argument is not obligatory for the ones of the {@link Matreshka#bindNode} method (see below). This problem is solved by the {@link Matreshka.defaultBinders} array which contains functions checking an HTML node against a set of rules. You get an opportunity to reduce your code a great deal, putting  binding rules into a separate part of your code and to use a syntax for binding without the third argument:
```js
this.bindNode('myKey', '.my-element');
```
How to do it? You should add the function checking  your element against a set of rules to the beginning of the {@link Matreshka.defaultBinders} array. The example below can be used as a template for creating your **default binder**.
```js
// add the binder to the collection of binders
// it is necessary to keep the possibility of overriding
Matreshka.binders.checkbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return this.checked;
		},
		setValue: function(v) {
			this.checked = !!v;
		}
	}
};

// the unshift method adds the function
// to the beginning of the Matreshka.defaultBinders array
Matreshka.defaultBinders.unshift(function(node) {
	// check if the element is a checkbox
	if(node.tagName == 'INPUT' && node.type == 'checkbox') {
		// if checking is OK, return a new binder
		return Matreshka.binders.checkbox();
	}
});
```
```js
this.bindNode('myKey', '.my-checkbox');
this.myKey = true;
```

What should you do if you need to pass arguments for initializing some plug-in or a widget? It is a piece of cake: you can do with adding the binder to the {@link Matreshka.binders} collection without creating a function for {@link Matreshka.defaultBinders}.
```js
Matreshka.binders.uiSlider = function(min, max) {
	return {
		on: 'slide',
		getValue: function() {
			return $(this).slider('option', 'value');
		},
		setValue: function(v) {
			$(this).slider('option', 'value', v);
		},
		initialize: function() {
			$(this).slider({min: min, max: max});
		}
	}
};
```
```js
this.bindNode('myKey1', '.my-slider1', Matreshka.binders.uiSlider(0, 100));
this.bindNode('myKey2', '.my-slider2', Matreshka.binders.uiSlider(1, 1000));
this.myKey1 = 42;
this.myKey2 = 999;
```

{@link Matreshka.defaultBinders} OOB, starting with the version 0.3, has a support for **all form elements** without any exception: ``select`` (including ``multiple``), ``textarea``, ``output``, ``input`` (including all types from the specification of HTML5: ``text``, ``checkbox``, ``radio``, ``range``, ``number``, ``date``, ``search``, ``time``, ``datetime``, ``datetime-local``, ``color`` and others). That means it is not necessary to designate a binder for standard elements.
```html
<input type="color" class="my-color-input">
```
```js
this.bindNode('myColor', '.my-color-input');
this.myColor = '#66bb6a';
```

Besides, after the binding, a new non-standard ``:bound(KEY)`` CSS selector is available for you.
```js
this.bindNode('myKey', '.my-element');

// will find the element '.my-inner-element' inside '.my-element'
this.bindNode('myAnotherKey', ':bound(myKey) .my-inner-element');
```

And the syntax of possible event names is extended:
```js
this.bindNode('myKey', '.my-element');

// will handle the click on the .my-element element
this.on('click::myKey', function() { ... });

// will handle the click on the .my-element .my-inner-element
this.on('click::myKey(.my-inner-element)', function() { ... });
```


#### The creation of a sandbox
{@link Matreshka#bindNode} can associate a class instance with the "main" HTML element on the page creating so-called **sandbox**. It is necessary to limit the instance influence on HTML nodes contained in another sandbox (i. e. inside another HTML node). A special property ``'sandbox'`` is used for binding a sandbox.
```html
<div class="my-sandbox">
	<!-- your HTML code -->
</div>
```

```js
this.bindNode('sandbox', '.my-sandbox');
```

The definition of the sandbox adds lots of conveniences for you. For example:
+ allows to use the {@link Matreshka#select} and {@link Matreshka#$} methods
+ adds a new ``:sandbox`` selector for the {@link Matreshka#bindNode}, {@link Matreshka#select}, {@link Matreshka#$} methods and others
+ adds syntactic sugar for delegated DOM events in the {@link Matreshka#on} method

> Also you can try {@link Matreshka#bindSandbox} which does the same thing but requires only one argument.

```js
// declare a sandbox
this.bindNode('sandbox', '.my-sandbox');

// .my-element is being searched for in the sandbox
this.bindNode('myKey', ':sandbox .my-element');

// it is not required to specify a key
// for the delegated events inside a sandbox
this.on('click::(.my-button)', function() { ... });

// will put the .inner-node element
// which is inside the sandbox into the console
console.log(this.$('.inner-node'));
```

-----govno start

> If a property value of class instance is not given, after a binding Matreshka will try to extract its value from the HTML node using ``getValue``. This behavior can be cancelled by passing the ``assignDefaultValue: false`` property to event object.
```js
this.bindNode('myKey', '.my-element', binder, {
	assignDefaultValue: false
});
```
> DOM changes are happening synchronously after every change of a property. You can "debounce" all changes passing ``debounce: true`` property to ``eventOptions`` argument. Look at {@link Matreshka.debounce}
#### Deep binding
Since version 1.1, the ``bindNode`` method supports the new feature called "deep binding". The method can bind DOM node to some property of nested object. For example, you have some nested object:
```js
this.a = {b: {c: {d: 42}}};
```

And you want to bind some DOM node to ``d``. The only thing you need is to pass a path to needed property and Matreshka will listen all changes throughout a tree of nested object by breaking a binding then re-creating it again:
```js
this.bindNode('a.b.c.d', '.my-node');
```

When some changes appear in the nested tree ``bindNode`` catches them and recreates binding again.
```js
this.a.b = {c: {d: 41}};
```

> This behavior is cancelable. You can set ``deep: false`` property for ``eventOptions`` object to ignore dot in a property name.

-----govno end

@see {@link Matreshka#unbindNode}
@see {@link Matreshka#bindOptionalNode}
@see {@link Matreshka#$}
@see {@link Matreshka.binders}
@see {@link Matreshka.defaultBinders}


@param {string|matreshka} key - A key (a property name)
@param {string|node|$nodes} node - An HTML element which must be bound to a ``key``
@param {binder} [binder] - A binder containing the following properties: ``on`` - which event must happen to an HTML node, informing that a user has changed something (for example, ``keyup`` or ``click``), ``getValue`` -  how to get a value from an HTML node, ``setValue`` - how to set a new value to a node and ``initialize`` - a function which is executed once after the initialization of binding. You can get more detailed information about binders in their documentation: see {@link #typedef-binder}.
@param {eventOptions} [eventOptions] - An event object which accepts ``"silent"`` (don't fire ``"bind"`` and ``"bind:KEY"``), ``"assignDefaultValue"`` (etract current node value), ``"debounce"`` (optimize DOM changes), ``"deep"`` (use "deep binding" or ignore a dot in a property name) or some custom data for event handlers.
@returns {matreshka} self

@example <caption>A custom checkbox. This example demonstrates the creation of custom element whose ``"checked"`` class is changed after clicking on it.</caption>
this.bindNode('myKey', '.custom-checkbox', {
	on: 'click',
	getValue: function() {
		return $(this).hasClass('checked');
	},
	setValue: function(v) {
		$(this).toggleClass('checked', !!v);
	},
	// initialize element behavior
	// the presence of 'checked' class name is changed after clicking on the element
	initialize: function() {
		$(this).on('click', function() {
			$(this).toggleClass('checked');
		});
	}
});

@example <caption>A custom checkbox 2. This example is the same as the previous one but it uses {@link Matreshka#defaultBinders}, and checks the element if the ``custom-checkbox``. class is present. If checking is OK, it returns the binder.</caption>
// add the binder to the 'binders' namespace
Matreshka.binders.customCheckbox = function() {
	return {
		on: 'click',
		getValue: function() {
			return $(this).hasClass('checked');
		},
		setValue: function(v) {
			$(this).toggleClass('checked', !!v);
		},
		initialize: function() {
			$(this).on('click', function() {
				$(this).toggleClass('checked');
			});
		}
	}
};

MK.defaultBinders.unshift(function(element) {
	// check if the element has the "custom-checkbox" class
	if($(element).hasClass('custom-checkbox')) {
		// if checking is OK, return a new binder
		return Matreshka.binders.customCheckbox();
	}
});

this.bindNode('myKey', '.my-custom-checkbox');

@example <caption>The ``"bind"`` event which is fired after any binding</caption>
this.on('bind', function() {
	alert('ok!');
});

this.bindNode('myKey', '.my-element'); // alerts "ok!"

@example <caption>The ``"bind:KEY"`` event which is fired after binding of specific property to HTML node</caption>
this.on('bind:myKey', function() {
	alert('ok!');
});

this.bindNode('myKey', '.my-element'); // alerts "ok!"

@example <caption>DOM event overriding for default binder. For example, we want to bind ``input[type="text"]`` to a property. By default, the standard binder contains ``"on"`` property with the ``"input"`` value for this kind of node. It means that a value of an instance property and node state will be synchronized when a user releases a key of the keyboard or pastes text from clipboard. In case if you want synchronization to be performed after the ``"blur"`` DOM event,  you will have to pass the object containing the only ``"on"`` property as the third argument. This object will join the default binder, having retained ``getValue`` and ``setValue`` values.</caption>
this.bindNode('myKey', '.my-input', {on: 'blur'});

@example <caption>If an element is not found, the ``"Bound element is missing"`` exception is thrown. In order to avoid the error, use the {@link Matreshka#bindOptionalNode} method</caption>
var $el = $();
this.bindNode('x', $el); // an error because $el is empty

@example <caption>Synchronization of a property value and HTML contents of a node</caption>
this.bindNode('myKey', '.my-element', {
	setValue: function(v) {
		this.innerHTML = v;
	}
});

// it can be done easier
this.bindNode('myKey', '.my-element', MK.binders.html());
*/


/**
@method Matreshka#bindNode
@importance 2
@variation 2
@summary Alternative syntax: "key-element" pairs
@desc In the {@link Matreshka#bindNode} method an object with the key-element pairs can be passed to avoid multiple invocation of the method and reduce the code.

@param {object} keyElementPairs - (see the example)
@param {binder} [binder] - (see above)
@param {eventOptions} [eventOptions] - (see above)

@example
this.bindNode({
	myKey1: '.custom-checkbox',
	myKey2: 'textarea'
});

@example <caption>Starting version 1.1 the syntax of the method is extended: you can pass an array with node and binder instead of just a node</caption>
this.bindNode({
	myKey1: ['.custom-checkbox', MK.binders.customCheckbox()],
	myKey2: 'textarea',
	myKey3: ['.my-node', {
		setValue: function(v) {
			// do something
		}
	}]
});
*/


/**
@method Matreshka#bindNode
@importance 2
@variation 3
@summary Alternative syntax: "heap of arguments"
@desc Another syntax for the {@link Matreshka#bindNode} method. This way may seem unattractive but sometimes you have need of binding lots of nodes to different properties at one operation. With such a syntax you can assign definite binders to some variable and then easily delete all at once using {@link Matreshka#unbindNode}.

@param {array} setOfArguments - The array of arrays (see the example)
@param {eventOptions} [eventOptions] - (see above)

@example
this.bindNode([
	[{
		myKey1: '.my-element1',
		myKey2: '.my-element2'
	}],
	[{
		myKey3: '.my-element3',
		myKey4: '.my-element4'
	}, {
		on: 'click',
		getValue: function() { ... },
		setValue: function() { ... }
	}],
	[{
		myKey5: '.my-element5',
		myKey6: '.my-element6'
	}, {
		on: 'somethingelse',
		getValue: function() { ... },
		setValue: function() { ... }
	}]
]);
*/
